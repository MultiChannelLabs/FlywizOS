{"./":{"url":"./","title":"About us","keywords":"","body":"About us Goal Make development easier and more efficient; let users have more convenient and customized development programs. Valuable Professional: Casting professional products with professional technology Innovation: Continuous innovation to provide customers with a steady stream of value Responsibility: Use technology to change lives About the display module Why do we make Linux display solutions At present, with the development of technology, the human-computer interaction scheme has been upgrading. And the development of human-computer interaction in some traditional fields is relatively slow. In the traditional field, there are many display solutions based on single-chip microcomputer, single-chip microcomputer + FPGA, which have solved the difficult problem of interactive development of color screen display for many customers. But with the increase in user needs and interactive content, traditional hardware limitations can no longer meet most of the customer needs, so we made this product. Empower the convenient human-computer interaction experience solution in the traditional field + the access capability of the IoT, and help the development of the IoT. Product advantages Compared with the traditional single-chip serial port screen or single-chip + FPGA display solution Provides the latest interactive experience like mobile phones and tablet computers, with high customer acceptance, low product learning costs, and good display effects The technology of multi-layer virtualization is realized through software, which solves the problem that the traditional display scheme limits the number of layers Support png format decoding ability, so that the image layer overlay effect is better From the system level, it supports WiFi, Ethernet, 2G, and 4G access capabilities to provide customers with more convenient access to the network; at the same time, it is convenient to quickly access WeChat IoT, WeChat Pay, Alipay and other platforms, which can be shared the industry provides fast IoT terminal solutions. Provide video decoding capabilities, more convenient to display information to users. Comparing Android and traditional Linux solutions Provides a stable hardware for testing, saving the cycle of testing and verification of hardware development Provide system development work for the IoT + display, saving the time for the system to re-develop and debug the system on the IoT and display Provides low-cost and high-efficiency operating capabilities: The current system runs on 1G single-core CPU, 64MBDDR2, 16MB Flash, saving more than 50% of hardware costs Provide development tools with configuration + user logic source code to facilitate customers to quickly complete customized development; the development cycle is at least 60% less than the traditional method. The deeply customized system has the ability to quickly start up in 3 seconds and safely run 24 hours * 365 days. Application scenario Smart home： Smart Appliances Shared industry Elevator indicator Advertising machine Charging pile Evaluation machine As long as you need to display, maybe we can help you powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"system_introdoction.html":{"url":"system_introdoction.html","title":"FlywizOS system introduction","keywords":"","body":"FlywizOS system framework introduction This system is based on Linux system development, adding a self-developed system framework and GUI interactive system. We call it the FlywizOS system. System target scenario : The current Internet of Things industry is developing rapidly. With the drop in the price of liquid crystal display, the demand for user window display, screening is coming. All displays will become displays. In view of the current development, Multi Channel Labs has proposed a more suitable display solution at the current stage. Replace the use of Android in the following small application scenarios, such as home appliances, access control and other product scenarios with simple functions, high system stability requirements, and high cost-effective requirements Replace the traditional black-and-white display or MCU-driven color display solution, and improve the interactive experience in a low-cost way. The arrival of the IoT and sharing scenarios has brought more demand for display windows and interaction. Provide system support with high cost performance and high stability. System configuration Kernel Based on the open source Linx3.4 kernel version Tailored and optimized for the IoT industry System Autonomous GUI framework Network API Multimedia service IoT platform access Payment platform access capability Remote update system capabilities Ability to push messages remotely Development support Provide WYSIWYG configuration GUI development tools Provide complete logic code Continuously updated documentation and sample Continuously updated control package and system upgrade service powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"docs_brief.html":{"url":"docs_brief.html","title":"Getting started","keywords":"","body":"Getting started Here is an introductory guide. Tools Before starting to use our screen, you must first install the development tool; Open the tool, and simply get familiar with Development Environment, you can try Create a new project, browse what is there, don’t have to delve into the details inside. There is nothing on the newly created project UI. We can drag and drop a text control on it, and then compile and run to see the effect on our screen; Note: If you have a wifi version of the board, you must configure the ADB IP to download normally; refer to the document; We have provided a large number of Sample Code, select the code package of the corresponding platform size, download it, unzip it, and Import into the tool; there are many projects, These later chapters will introduce in detail, here we can select the example we are interested in run to see the effect on our screen; At this point, the simple use of the tool, I believe you will do it too. Rules After getting acquainted with the tools, let’s take a look at the development rules of this screen; Understand the [directory structure] (project_structure.md) of the project, you can know what the project contains, and in which directory our code, UI and resources are stored. Next, let's take a look at what content is automatically generated by the tool, what is the correspondence between the UI file and the source code and the control naming rule on the UI. Understand after this, we know where our code needs to be filled in and how to operate the control. Control The development interface is inseparable from the use of each control. In the navigation bar of the document, there is a special chapter to introduce the use of each control-Control Introduction. Uart First, we must know the communication model of the uart on our screen. Then try it out according to the provided case, and then add some protocols and functions on this basis. Then go to study the realization of communication framework; Update There are two update methods: Make image file —— update.img file; in this way, the program is solidified into the machine, and the program is still there after power off. Pay attention to the normal download ) The difference between debugging; this method is also our most commonly used; Make a flash card —— format the whole machine; the system has a new version update, we will officially provide the corresponding sd file, make it into a flash card and flash the machine to upgrade. The system cannot be turned on or the system is needed supporting new functions or fixing related bugs, etc.. Only need to refresh in these cases. Debug Currently, the program can only be debugged by Add Log. Module See Core Module Instructions Hardware See Hardware Instructions FAQ Here are some common problems and solutions; powered by Gitbooklast modified: 2020-12-14 10:49:43 "},"download.html":{"url":"download.html","title":"Environmental installation","keywords":"","body":"Build a development environment Install FlywizOS IDE and SDK Windows FlywizOS IDE（20191231-0229） powered by Gitbooklast modified: 2021-01-15 17:35:39 "},"flywizOS_ide_snapshot.html":{"url":"flywizOS_ide_snapshot.html","title":"First use","keywords":"","body":"First use of FlywizOS integrated development tool If you have successfully installed FlywizOS IDE, then on your desktop, fine the shortcut and double-click to run it.If you delete the shortcut, you can also find it in the bin folder in the installation directory, find and run it directly. Choose a workspace When you run the tool, the following interface will pop up. Workspace is used to store related settings and historical records. You can understand it as a container, which can manage multiple projects at the same time, so there is no need to run multiple development tools at the same time. Welcome screen If you open the software for the first time, or choose a new workspace, then you will see a welcome interface like the picture below. It provides two shortcut functions: New Project and Import Project New ProjectIt will guide you step by step How to create a new FlywizOS project Import Project Through it, you can import existing projects into the current workspace and continue previous development. How to import a project We are not in a hurry to New Project, first select in the upper left corner to close the welcome interface. If you want to reopen the welcome interface, on the top menu bar, select Help -> Welcome menu. ​ powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"flywizOS_ide_layout_introduce.html":{"url":"flywizOS_ide_layout_introduce.html","title":"Work area introduction","keywords":"","body":" FlywizOS IDE Introduction to the use of work area When your new project is completed, you will see the following interface The editor is roughly divided into six areas. The respective functions are as follows : ① Area-Project Explorer It displays the resource files and code files in the project folder in the form of a tree diagram. You can expand/collapse freely, double-click the file to directly open it for editing. The specific demonstration is as follows: ② Area-UI edit box is mainly responsible for the editing and instant preview of the UI interface, it is the main operation area in the development ③ Area-Control Panel It contains all the built-in controls. You can click to select the control you need, and drag it to ②area to complete the creation of the control. The specific demonstration is as follows: ④ Area-Properties Table When you select a control in area②, all its properties will be displayed in the form of a table here, and you can customize and modify it in the table. For example, to modify the text size, the specific demonstration is as follows: ⑤Area-Outline View It displays all the created controls in the form of a tree diagram; it also supports free expansion/collapse; can clearly understand the hierarchical relationship between controls; and you can directly drag a node, quickly Adjust the position of the hierarchy; double-click the node to quickly show/hide the controls. This is very easy to use when the hierarchy is complicated. The specific demonstration is as follows: ⑥ Area-Console When compiling the code, this location will output the compilation log. If the compilation fails, double-click error prompt content to jump directly to the corresponding code. As shown in the figure below, it demonstrates that double-click the error message and jump directly to the code. After learning the above basics, now, we can officially start development. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"new_flywizOS_project.html":{"url":"new_flywizOS_project.html","title":"New project","keywords":"","body":"How to create a new FlywizOS project Creating a new FlywizOS project is very simple. Specific steps are as follows : In the menu bar at the top of the editor, select File -> New -> FlywizOS Application Project After the selection in the previous step is completed, the FlywizOS New Wizard prompt box will pop up. Fill in the parameters related to the new project as required. These parameters are: Project nameThe name of the project; it can be a combination of letters and numbers. LocationThe storage path of the project. PlatformChoose the corresponding platform according to the serial screen you own, currently there are Z11S Z6S After filling in the required parameters as above, you can directly select Finish to quickly complete the creation. But for now, we choose Next to customize more parameters. After clicking Next, we will see more parameter definitions The meaning and function of each attribute of the project : Screen saver timeout FlywizOS system provides screensaver function. If there is no touch operation on the serial port screen within the specified time, or you have not reset the screen saver timing through the code, then the system will automatically enter the screen saver. If the time is -1 second, it means that the screen saver function is disabled. Serial portSpecify the communication serial port, and generally do not need to be modified. Baud rateSpecify the baud rate of the communication serial port Resolution Specify the width and height of the screen in pixels Screen rotationFor some screen coordinate axis directions, you can check this option to rotate the displayed content by 90° to achieve normal display. FontFlywizOS supports custom fonts. If you are not satisfied with the default fonts, you can cancel the defaults and select your font file. Input methodIf you need Chinese input, you can check it, and cooperate with Edit Text box control to solve Chinese input. The above attributes can be modified again later, so don't worry too much about filling in errors. (How to modify the attributes of an existing project) After the attributes are filled in and confirmed, click Finish to end the creation. The creation process will take some time and wait patiently. After the project is created, you should first understand FlywizOS project code structure introduction powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"import_project.html":{"url":"import_project.html","title":"Import project","keywords":"","body":"How to import FlywizOS project We can import the downloaded sample code into the current workspace.The import steps are as follows. Find the menu bar at the top of the tool, and select the menu File -> Import in turn. In the pop-up box, select General -> Existing Project to Workspace, and then select Next. In the pop-up box, select the Browse button, and specify the folder where the project needs to be imported. Click OK, it will automatically parse the items contained in the folder. If the project file is not damaged, you can see the identified project, and then click Finish directly, the imported project will appear in the Project Explorer, and you can continue to view/edit it. Import animation powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"new_flywizOS_ui_file.html":{"url":"new_flywizOS_ui_file.html","title":"New UI file","keywords":"","body":"How to create a new FlywizOS UI file Creating a new UI file is similar to New FlywizOS Project. In the Project Explorer, expand the project that needs to create the UI file, select the ui folder under the project, then right-click, and in the pop-up menu, select the menu New -> FlywizOS UI file. After the above operations, a New FlywizOS UI File Wizard box will pop up, as shown below: There are three parameters you want you to specify : File nameYou need to specify the file name of the UI file. The file name is named with letters and numbers, with ftu (FlywizOS UI File) as the suffix. Resolution You can control the width and height of the UI interface by adjusting the resolution, in pixels; UI Type There are currently four window types: Normal, Status Bar, Navigation Bar, and Screensaver. In general, we can keep the normal option. For specific explanations of the other three types, please refer to System Application Introduction After confirming the parameters, select Finish to end the creation process. You can see the newly created UI file in the project's ui folder in the project explorer. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"how_to_compile_flywizOS.html":{"url":"how_to_compile_flywizOS.html","title":"Compile project","keywords":"","body":"How to compile FlywizOS project Compiling the FlywizOS project is very simple. According to different operation methods, there are three ways to compile as follows. 1. Choose Compile from Project Explorer The specific steps are: In the Project Explorer, left-click to select the name of the project to be compiled, then right-click, and in the pop-up menu, select the Compile Project option to automatically compile the project. The animation of the operation is as follows : 2. Select compile via toolbar There is a shortcut to compile on the toolbar at the top of the software. Similarly, first in the project explorer, left-click to select the name of the project to be compiled, and then find on the toolbar Click the green triangle button to compile the selected project. 3. Compile via shortcut keys You may have noticed the compilation shortcut in the above two steps, that is, Ctrl + Alt + Z. It is strongly recommended to use this method for compilation. After editing the code, directly Ctrl + Alt + Z quickly completes the compilation, which is very convenient. How to clean up the project After the project is compiled, some compiled object files and intermediate files are usually left. For example, libs and obj folders, their existence is to speed up compilation and achieve incremental compilation. You can delete them manually, or automatically clean them up through the menu. Manually deleteFirst select the folder to be deleted, right-click, and in the pop-up menu, select the Delete option. Automatic cleaningIf you always perform the deletion manually, it may cause misoperation and cause the loss of important files. Therefore, using automatic cleaning can effectively avoid this situation. Similarly, first select the name of the project to be operated, right-click, and select the Clear Project option in the pop-up menu. It will automatically delete the compiled intermediate files in the libs folder and obj folder.It is recommended to use this method to clean up files. Note: If you encounter strange problems during compilation, or the source code is not compiled into the program, you can try to clean the project first, and then recompile. Especially when you import other people's projects, this situation tends to happen frequently. How to recompile If you want to completely recompile the code, then you can clean up the project and compile again powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"run_project.html":{"url":"run_project.html","title":"Run project","keywords":"","body":"How to run the project After the project passes compile, it can be put to run on the real machine. According to different equipment models, there are several operating modes as follows: Use WIFI to connect devices quickly This method only supports models with WIFI, and the currently supported device models are: sw480272043B_CW 4.3inch sw480272043B_CWM 4.3inch sw80480043B_CW 4.3inch sw48854050B_CW 5inch sw80480070A_CW 7inch sw80480070A_CWM 7inch sw80480070AI_CW 7inch sw80480070AI_CWM 7inch sw10600070A_CW 7inch Product model description After confirming that the device supports WIFI, follow the steps below to complete the configuration: First enter the WIFI setting activity of the device, and connect the device to the same wireless network as the computer, that is, the computer and the machine must be connected to the same WIFI. (If a different network will cause the subsequent download procedure to fail). After the wireless network connection is successful, click the menu in the upper right corner of the WIFI setting activity to check the IP address of the device. At this time, go back to the development tool on the computer, on the menu bar, select the menu FlywizOS -> ADB Configuration, in the pop-up box, select Net for the ADB connection method, and Fill in the IP address of the device and save the application. After completing the connection configuration, select the Download and Debug menu item, it will temporarily synchronize the project code to the connected device to run. Fast operation with USB connected device For models without WIFI function, almost all support USB cable connection. Note: If there is WIFI function, the USB cable connection is invalid. Connect the device to the computer via a USB cable. If the computer can recognize the device as an Android device, the connection is normal. If you can't connect normally, the computer prompts a driver problem, you can try Download Driver. When the computer recognizes the device correctly, return to the development tool on the computer, in the menu bar, select the menu FlywizOS -> ADB Configuration, in the pop-up box, select the ADB connection method USB and save. After the configuration is complete, select the Download and Debug menu item, it will temporarily synchronize the project code to the connected device to run. Boot from TF card If for other reasons, both USB and WIFI cannot be used normally or are occupied, you can start the program from the TF card with the help of a TF card. For specific steps, please refer to Start the program from the TF card powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"project_structure.html":{"url":"project_structure.html","title":"Project structure introduction","keywords":"","body":"FlywizOS project code structure introduction Before you start to write code, you must first understand the basic structure of a FlywizOS project, and then you can know where your code should be added.For a basic FlywizOS project, its directory structure is like this : It is roughly divided into three folders: jni, resources, ui. The role of each folder is explained below. ui folder Expand ui folder You can see that a main.ftu file is included by default. ftu is the suffix of the UI file of the FlywizOS project. Each ftu file corresponds to an application interface. Usually, an application contains multiple interfaces, so you need to create multiple ftu files in the ui folder. To add a new ftu file, please refer to How to create a new FlywizOS UI file. For the convenience of description, in the following tutorials, the ftu file will be referred to as the UI file. You can double-click to open the UI file, edit it, and preview the effect instantly. For the specific steps of editing the UI file, please refer to the tutorial of Introduction to Controls. After editing, you can start \"compile\" (How to compile) [!Note] Note: The compilation mentioned here is not only the compilation of the source code, but also a series of operations such as the preprocessing of the ui file and the generation of the template code, but these are all automated, and you do not need to manually operate. For all the specific operations behind compiling this action, please refer to The specific compilation process and the correspondence between the UI file and the source code. After reading it, I believe you will be easier to understand and get started quickly resources folder The content of this folder is relatively simple, mainly used to store various resource files of the project, including pictures, fonts, input method configuration files, etc. However, due to the limitation of the machine's own storage space, it is not recommended to store large files in this directory. It is recommended that you store large resource files in the TF card. We can get the absolute path of a file in the resources directory in the code. For example: The following code can obtain the absolute path of resources/test.txt. #include \"manager/ConfigManager.h\" std::string resPath = CONFIGMANAGER->getResFilePathEx(\"test.txt\"); jni folder This folder is mainly for storing code files, and it also contains multiple parts of code. We expand the jni folder As you can see, it contains 6 parts of activity, include, logic, uart, Main.cpp, Makefile, each the functions of each part are as follows: activity subfolder Store the basic class code of the UI file. After each UI file is compiled, an Activity class and a Logic.cc file with the same prefix name will be generated. For example: there is a main.ftu in the ui folder, then after compilation, mainActivity.h, mainActivity.cpp and mainLogic.cc will be generated, and the mainActivity class will be stored in In the activity folder, the mainLogic.cc file will be stored in the logic folder. [!Warning] It is strongly recommended not to manually modify the code in the activity folder, except in special cases logic subfolder Store specific logic codes. Same as the description above, every UI file will generate a Logic.cc file with the corresponding prefix name after compilation. *Note: Our custom code is mainly added to these Logic.cc files *. include subfolder The header files related to the system and all control related header files are mainly stored here. uart subfolder As the name implies, this folder stores serial port operation related codes, including reading and writing serial ports, protocol analysis, etc. Main.cpp The entry code of the entire FlywizOS application, including the interface for selecting the boot and some initialization, generally does not need to modify this file. Makefile/Android.mk、Application.mk Compilation configuration file, which contains the specific source code compilation process, generally does not need to be modified After the compilation is passed, the libs directory and the obj directory will be generated under the project, which are the compiled target storage directory and the compiled intermediate file directory, both of which can be cleaned up or deleted directly. It doesn't matter. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"ftu_and_source_relationships.html":{"url":"ftu_and_source_relationships.html","title":"UI file and generated code explanation","keywords":"","body":"The FlywizOS compilation process and the correspondence between UI files and source code How are controls in UI files associated with pointer variables FlywizOS separates the UI and code for easy management. In the following, UI files refer to all ftu files in the ui folder of the project. In order to reduce the repetitive code written during development, we improved the compilation process. Before the real source code is compiled, the tool will generate a Logic.cc file with the same prefix name according to the UI file. For example, main.ftu will generate a paired mainLogic.cc file. Here you need to pay attention to:The generation of the Logic.cc file is not a direct overwrite, but an incremental modification.When compiling, the tool will traverse each UI file and read the controls contained in the UI file. And declare a pointer variable for this control, in the code, through this pointer, you can operate the corresponding control. Pointer variables are defined in the Activity.cpp file with the same prefix name. Take main.ftu as an example, like this: As you can see in the figure, all pointers are static global variables, and they all have the same naming rules. For specific naming rules, please refer to Naming Rules for Control ID Names and Pointer Variable Names ; And, you should also notice the statement #include \"logic/mainLogic.cc\" in the screenshot, which includes the mainLogic.cc file into mainActivity.cpp, and our code is written in mainLogic.cc file, so we can fully use these control pointers in mainLogic.cc. If you are interested in the initialization of these pointers, you can find it in the onCreate function of mainActivity. The relationship between UI files and Logic.cc files Now, you probably already know how the controls in the UI file are connected to these pointers. Let's take another look at what code is automatically generated for us in the mainLogic.cc file. If you don't add any controls to your UI file, your mainLogic.cc file will look like this : /** * Register timer * Fill the array to register the timer * Note: id cannot be repeated */ static S_ACTIVITY_TIMEER REGISTER_ACTIVITY_TIMER_TAB[] = { //{0, 6000}, //Timer id=0, period 6 second //{1, 1000}, }; /** * Triggered when the interface is constructed */ static void onUI_init(){ //Add the UI initialization display code here, for example : //mText1Ptr->setText(\"123\"); } /** * Triggered when switching to this interface */ static void onUI_intent(const Intent *intentPtr) { if (intentPtr != NULL) { //TODO } } /* * Triggered when the interface is displayed */ static void onUI_show() { } /* * Triggered when the interface is hidden */ static void onUI_hide() { } /* * Triggered when the interface completely exits */ static void onUI_quit() { } /** * Serial data callback interface */ static void onProtocolDataUpdate(const SProtocolData &data) { } /** * Timer trigger function * It is not recommended to write time-consuming operations in this function, otherwise it will affect UI refresh * Parameter : id * The id of the currently triggered timer is the same as the id at registration * Return : true * Keep running the current timer * false * Stop running the current timer */ static bool onUI_Timer(int id){ switch (id) { default: break; } return true; } /** * Triggered when there is a new touch event * Parameter : ev * new touch event * Return : true * Indicates that the touch event is intercepted here, and the system will no longer pass this touch event to the control * false * Touch events will continue to be passed to the control */ static bool onmainActivityTouchEvent(const MotionEvent &ev) { switch (ev.mActionStatus) { case MotionEvent::E_ACTION_DOWN://Touch press // LOGD(\"event time = %ld axis x = %d, y = %d\", ev.mEventTime, ev.mX, ev.mY); break; case MotionEvent::E_ACTION_MOVE://Touch move break; case MotionEvent::E_ACTION_UP: //Touch up break; default: break; } return false; } The specific functions of these functions are as follows: REGISTER_ACTIVITY_TIMER_TAB[ ] arrayUsed for register timer; The array member type is the following structure typedef struct { int id; // Timer ID, cannot be repeated int time; // Timer interval, unit millisecond }S_ACTIVITY_TIMEER; In essence, this array will be referenced in the rigesterActivityTimer() function of mainActivity.cpp and registered to the system in turn by calling the void registerTimer(int id, int time) function. void onUI_init()It is used for activity initialization. If you need to initialize some content when opening this UI activity, then you can add code to this function.In essence, this function will be called in the onCreate() method of mainActivity.cpp. You can understand it as the structure of mainActivity. void onUI_quit()Used to exit the activity, if you need to do some operations when the UI activity exits, then you can add the code to this function. In essence, this function will be called in the destructor of mainActivity.cpp void onProtocolDataUpdate(const SProtocolData &data)Used to receive serial port data. When the serial data frame is parsed, this function will be called.The essence is that in onCreate() of mainActivity.cpp, void registerProtocolDataUpdateListener(OnProtocolDataUpdateFun pListener) is called by default to register to receive serial port data, and the registration is cancelled in the destruction of mainActivity.cpp. When the serial port reads the data, the registered UI activity is called in turn through the void notifyProtocolDataUpdate(const SProtocolData &data) in ProtocolParser.cpp.This is the serial port analysis function in ProtocolParser.cpp, combined with the process described above, you should be able to understand how the serial port data is distributed on each activity: /** * Parse each frame of data */ static void procParse(const BYTE *pData, UINT len) { switch (MAKEWORD(pData[3], pData[2])) { case CMDID_POWER: sProtocolData.power = pData[5]; break; } // Notify protocol data update notifyProtocolDataUpdate(sProtocolData); } bool onUI_Timer(int id)Timer callback function; When a timer reaches the specified time interval, the system will call this function. When multiple timers are added, you can use the id parameter to distinguish the timers. The id parameter is the same as the id filled in the structure array above.Return true to continue running the current timer;Return false to stop running the current timer;If you stopped the timer by returning false, how do you start it again? Please refer to How to start and stop the timer arbitrarily bool onmainActivityTouchEvent(const MotionEvent &ev)Touch event callback function. Able to get all touch messages.Similarly, this function is also registered by default in mainActivity.cpp through the registerGlobalTouchListener function; touch messages can only be obtained after registration.Return true means that the touch event is intercepted here and is no longer passed to the controlReturn false means that touch events will continue to be passed to the control Learn more about the handling of touch events The above is Logic.cc generated by compiling the default UI file. When we add controls to the UI file and compile again, the tool will generate different associated functions according to different controls to the corresponding Logic.cc file.For example : I added two button controls to the UI file of main.ftu, their IDs are Button1 and Button2, then, after compilation, the following two related functions will be generated in the mainLogic.cc file. static bool onButtonClick_Button1(ZKButton *pButton) { //LOGD(\" ButtonClick Button1 !!!\\n\"); return false; } static bool onButtonClick_Button2(ZKButton *pButton) { //LOGD(\" ButtonClick Button2 !!!\\n\"); return false; } Pay attention to the naming of the function. The function name contains the ID name of the control, so we require the ID naming of the control to conform to the C language naming standard.If you continue to add controls, more related functions will be generated into the mainLogic.cc file after compilation.Usually, during development, we will add, delete, and modify controls many times in the UI file. For these situations, the current solutions are as follows : For the case of adding a control, the tool will generate a correlation function based on the control ID name at compile time. If the same correlation function already exists, it will be skipped. Will not have any impact on the Logic.cc file. In the case of deleting a control, if you delete an existing control in the UI file, the tool will not delete its associated function. If the associated function is also deleted, it is likely to cause the loss of customer code, so we choose to keep it. In the case of modifying the control, the generation of the associated function is only related to the control ID name. If you modify other properties of the control except the ID name in the UI file, it will not affect the associated function; if you modify the control ID name property , then when compiling, it will be processed according to the situation of adding controls, and the old associated functions will be retained. We only took button controls as an example to describe the relationship between the controls in the UI file and the associated functions generated in Logic.cc. FlywizOS also provides associated functions for generating other controls, such as sliders, lists, and sliding windows, to understand the correlation function of other controls, please refer to Explanation of the correlation function automatically generated by the control Finally, use a picture to summarize the correspondence between the ftu file and the code : powered by Gitbooklast modified: 2020-12-11 14:47:13 "},"named_rule.html":{"url":"named_rule.html","title":"Control naming rules","keywords":"","body":"Control naming rules Most of the controls we add to the UI file will automatically generate a corresponding pointer variable and a macro-defined integer value after being compiled. Naming rules for control ID names and pointer variable names The pointer variable name consists of three parts. Respectively fixed lowercase m as the prefix + ID name + Ptr as the endTake the control whose ID property is Textview1 as an example After compilation, the corresponding pointer variable name generated is mTextview1Ptr The type of pointer variable depends on the type of control. The pointer types corresponding to each control are as follows:The header files of each class can be found in the project jni/include folder. Control name Class name ZKQRCode ZKEditText ZKButton ZKTextView ZKSeekBar ZKPointer ZKCircleBar ZKDigitalClock ZKVideoView ZKCameraView ZKWindow ZKListView ZKSlideWindow ZKDiagram Control ID name and macro definition integer value naming rules This macro definition represents the mapping relationship of controls in the UI file. The macro definition consists of three parts. They are composed of fixed uppercase ID, uppercase UI file name, and control ID property name.Take the control whose ID property is Textview1 as an example After compilation, the corresponding macro statement generated is #define ID_MAIN_TextView1 50001 [!Warning] Do not change the integer value of the macro definition at will, otherwise it will cause the program to be abnormal. Explanation of associated functions automatically generated by the control Some controls will automatically generate associated functions. The specific explanation of the associated functions generated by these controls is as follows : [!Note] The XXXX in the function represents the control ID name. Please replace it yourself in the actual process Button control static bool onButtonClick_XXXX(ZKButton *pButton) { return false; } When the button is clicked, this function is called. The parameter ZKButton *pButton is the pointer of the clicked button. A series of operations can be performed on the control through the member functions of the pointer. This pointer is the same object as the object pointed to by the global variable mXXXXPtr. Edit Text control static void onEditTextChanged_XXXX(const std::string &text) { } When the text in the input box changes, the system will automatically call this function. The parameter std::string &text is the complete string in the current input box. Seek Bar control static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress) { } When the current progress value of the Seek Bar changes, the system will automatically call this function. Parameter ZKSeekBar *pSeekBar is the pointer of the Seek Bar control, and a series of operations can be performed on the control through the member functions of the pointer. Parameter int progress is the progress value of the current Seek Bar. Slide window control static void onSlideItemClick_XXXX(ZKSlideWindow *pSlideWindow, int index) { } When you click an icon in the Slide window control, the system will automatically call this function. Parameter ZKSlideWindow *pSlideWindow is the pointer of the Slide window control, and a series of operations can be performed on the control through the member functions of the pointer. Parameter int index is the index value of the currently clicked icon. For example, a total of 10 icons are added to the Slide window, and the index value range is [0, 9] List control The list control is the most complex control, it will create three associated functions. Although there are many functions, it is very easy to understand according to the following steps. First, if the system wants to draw a list control, it needs to know how many items it has. So there is the following correlation function static int getListItemCount_XXXX(const ZKListView *pListView) { return 0; } Parameter const ZKListView *pListView is the pointer of the List control, which points to the same object as the global variable mXXXXPtr. Return value is an integer, which means how many items there are in the list, which can be defined according to your needs. After the system knows the number that needs to be drawn. But it is not enough. It also needs to know what content you display for each item. So with the following function, it will be called multiple times to let you set the display content of each item until each item is processed. static void obtainListItemData_XXXX(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { //pListItem->setText(index) } Parameter ZKListView *pListView is the pointer of the List control, which points to the same object as the global variable mXXXXPtr. Parameter ZKListView::ZKListItem *pListItem is the pointer of the list item, corresponding to the Item in the UI file Parameter int index is the index value of pListItem in the entire list. It has a certain range,For example: The return value of the getListItemCount_XXXX function is 10, which means there are 10 items in the list, so the range of index is [0, 9],Combining pListItem and index, you can know where the set list item is in the entire list. In this function, you can set the display content of each item separately according to index.For example: The commented statement in the function means: each list item displays its corresponding index number. Similar to the button control, the list control also has a click event, but it judges which list item is currently clicked based on the index value. static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); } When the list control is clicked, the system will calculate the index number of the list item, and will automatically call this function. Parameter ZKListView *pListView is the pointer of the List control, which points to the same object as the global variable mXXXXPtr. Parameter int index is the index value of the currently clicked list item in the entire List control Parameter int id is the id of the currently clicked control. Note that this id is different from the ID name in the properties table.Its specific macros are defined in the corresponding Activity.h file. For example in mainActivity.h The function of this id parameter is that when there are multiple sub-items in the list item, it can be used to distinguish which sub-item is currently clicked.For example: As shown in the figure below, I added two list items to the list item, and added a picture decoration as a switch button. The property ID names are SubItem1 and SubItem2 respectively. When I click on SubItem1, by judging the equal relationship between the parameter id and ID_MAIN_SubItem1 and ID_MAIN_SubItem2, You can determine which switch was clicked.Specific code： static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); switch(id) { case ID_MAIN_SubItem1: //LOGD(\"Clicked the first subitem of item %d in the list\", index); break; case ID_MAIN_SubItem2: //LOGD(\"Clicked the second subitem of item %d in the list\", index); break; } } Finally, we use a picture to summarize the rules between them: Other controls and so on powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"editor_tip.html":{"url":"editor_tip.html","title":"Common skills in development tools","keywords":"","body":"Common settings for development tools Quick jump to related functions When we add too many controls to the UI file, multiple associated functions will also be generated in the Logic.cc file. If you want to find the associated function of a certain control is quite time-consuming.Fortunately, the tool provides a function to quickly jump from the UI control to the relevant code.On the preview, select a control, right-click, and select Goto relative code in the pop-up menu to open the corresponding Logic.cc file, and position the cursor to the associated function of the control. Note: This function is only valid for control types that automatically generate associated functions, such as the control types mentioned above. If you choose other control types, the function will only jump to the corresponding Logic.cc file , And position the cursor at the bottom of the file. Modify font/font size On the menu bar of the tool, select Window -> Preferences In the pop-up box, select according to the following figure in turn to set the font. Code smart completion When editing the code, you first need to input the starting part, and then press \"Alt + /\" to turn on the code completion function.As shown in the figure below, I input the two letters UA, and then press \"Alt + /\" shortcut key, you can see that there are multiple completion options, which can be selected with the up and down arrow keys. Enter key confirms the selection. Reindex If the code completion function fails, or the editor prompts a code error, but there is no problem with the compilation, please try to rebuild the index. The steps to rebuild the index are as follows : powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"ctrl_common.html":{"url":"ctrl_common.html","title":"General property","keywords":"","body":"Common properties Before we start to introduce each control, let's have a basic understanding of some common properties and setting interfaces of the control ; Control ID value The ID value is the unique identifier of the control. The control ID value in each ftu file is not allowed to have the same name. The control ID value in different ftu files is allowed to have the same name; after setting the ID value, it will be compiled in *activity *The corresponding macro definition is generated in the corresponding header file in the directory: Get the ID value of the control: /** * The interface is defined in the control base class \"ZKBase\" * Header file location: include/control/ZKBase.h * * Note: The following interfaces, unless otherwise specified, mean that all controls defined in the ZKBase class directly or * indirectly inherit the ZKBase class, so all controls can call the public interface in the ZKBase class */ int getID() const; /* Operation example: Click the button control to print the ID value of the control */ static bool onButtonClick_Button1(ZKButton *pButton) { int id = pButton->getID(); LOGD(\"onButtonClick_Button1 id %d\\n\", id); return false; } Control location We open any ftu file, select any control, in the property box, we can see the attribute coordinates, which determines the display position of the control : The coordinates of the upper left corner are relative to the upper left corner of the parent control ; Set and get the position of the control through code : /* Interface description */ // Set location void setPosition(const LayoutPosition &position); // Get location const LayoutPosition& getPosition(); /* Operation esample */ // Click the button control to set the button position static bool onButtonClick_Button1(ZKButton *pButton) { // left：0，top：0，width：100，height：200 LayoutPosition pos(0, 0, 100, 200); pButton->setPosition(pos); return false; } // Click the button control to get the button position static bool onButtonClick_Button2(ZKButton *pButton) { // The mLeft, mTop, mWidth, and mHeight variables of pos correspond to the coordinate values respectively. LayoutPosition pos = pButton->getPosition(); return false; } Background color This is simple, modify the color to see the effect ; Code to set the background color : /* When color is -1, the background is set to transparent; other color values are 0xRGB, and the color value does not support alpha */ void setBackgroundColor(int color); /* Operation example : Click the button control and set the background color to red */ static bool onButtonClick_Button1(ZKButton *pButton) { pButton->setBackgroundColor(0xFF0000); return false; } Background picture After selecting the picture, you can see the effect Here we focus on explaining how to set the background image through code : /** * The pPicPath parameter can have the following two ways : * 1. The absolute path, such as : \"/mnt/extsd/pic/bg.png\" * 2. Relative resource directory path, you only need to put the picture in the resources directory of the project, after * compiling, you can use it. If there is a bg.png picture in the resource directory, just set \"bg.png\". */ void setBackgroundPic(const char *pPicPath); /* Operation example */ mButton1Ptr->setBackgroundPic(\"/mnt/extsd/pic/bg.png\"); // Set the absolute path mButton1Ptr->setBackgroundPic(\"bg.png\"); // Set the bg.png picture in the resource directory Show and hide Through this property, we can set the default display or hidden state of the control. Double-click the control in the outline view to quickly modify the state : In addition, we can also dynamically set the control display and hide through code : void setVisible(BOOL isVisible); BOOL isVisible() const; /* Operation example */ mButton1Ptr->setVisible(TRUE); // Show the button control mButton1Ptr->setVisible(FALSE); // Hide the button control /** * Window controls can also use the following interface, the same function * Header file location : include/window/ZKWindow.h */ void showWnd(); // Show window void hideWnd(); // Hide window bool isWndShow() const; // Whether the window is displayed /* Operation example */ mWindow1Ptr->showWnd(); mWindow1Ptr->hideWnd(); Control state For text, button, and list item, they have 5 states, here we need to explain : normal/pressed/selected/pressed and selected /invalid state. After setting, it will affect the background color, text color and display picture of the corresponding state of the control; The pressed state does not need to be set by code, the touch control which is the pressed state ;Operation interface of selected state and invalid state : // Set selected state void setSelected(BOOL isSelected); BOOL isSelected() const; /* Operation sample */ mButton1Ptr->setSelected(TRUE); mButton1Ptr->setSelected(FALSE); /** * Invalid state function description: when the control is set to the invalid state, the touch control has no effect, that is, * it does not respond to the press and lift event */ // Set invalid state void setInvalid(BOOL isInvalid); BOOL isInvalid() const; /* Operation example */ mButton1Ptr->setInvalid(TRUE); mButton1Ptr->setInvalid(FALSE); Example description We use the following small examples to understand the simple usage of related interface functions of common attributes. 1.Create control First, we create a new FlywizOS project, double-click to open the main.ftu file under the project UI folder, and drag the button control and text control in the control bar. 2.Compile the project (If you are not sure about the specific operation, please see the \"How to compile the FlywizOS project\" chapter) 3.Call control property function After the compilation is complete, open the jni/logic/mainLogic.cc file in the project and you can see that the onButtonClick_Button1 function is generated at the bottom of the file. We will call the getID() function in this function to get the ID value of the Button1 control , and call the setText() function to display it in the TextView1 control. (If you are not clear about the corresponding rules between the pointer variable name and the control ID in the UI file, click here) 4.Download and debugging In the project manager, select the project name, right-click, and select Download and Debug in the pop-up menu to temporarily download the program to the screen and run it. After running, click the button to see the ID value of Button1 control is 20001. Note : To learn more about the setting interface functions of the common properties of the control, you can open the /jni/include/control/ZKBase.h file, and the main property setting interface functions have been commented. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"textview.html":{"url":"textview.html","title":"Text","keywords":"","body":"Text View control Note If you don’t know how to modify the common properties of the text, please refer to 《Common properties》 I need to display a text/label, what should I do? If you need to display text, you can quickly implement it with the existing Text View. The specific steps are as follows : Double click to open the main.ftu file Find the Text View control in the right control collection Left-click the Text View control and hold it, then drag it to any position, release the left button, and you can see the automatically generated text view control. How to dynamically update text view content through code? In the use of the serial port screen, the text view content is often updated dynamically. Then in the code, we can dynamically update the content of the text view control through the pointer corresponding to the Text View control. The specific steps are as follows : First of all, you need to know the pointer variable corresponding to the text view control in the code (If you don’t know the corresponding rules of the pointer variable name and the control ID in the UI file, click here), here is the text with the ID of Textview1. Take the text control with ID Textview1 as an example, its corresponding pointer variable is mTextview1Ptr. If we want to modify the content of the Textview1 to \"Hello World\", it can be implemented by calling the member function of the text view control void setText(const char *text), in the corresponding Logic.cc file, The specific code is: mTextview1Ptr->setText(\"Hello World\"); Examples of actual usage : The function of the following code is: when the button with ID Button1 is pressed, the text with ID Textview1 is set to \"Hello World\" static bool onButtonClick_Button1(ZKButton *pButton) { mTextview1Ptr->setText(\"Hello World\"); return false; } In addition to setting strings, the text control also supports setting number and character: /* function definition header file: include/control/ZKTextView.h */ void setText(int text); // set number void setText(char text); // set character /* Operation example */ mTextview1Ptr->setText(123); // Textview1 control will display the string \"123\" mTextview1Ptr->setText('c'); // The Textview1 control will display the'c' character How to modify the color of text? The default text is displayed in white, which usually cannot meet the requirements. You can modify the text color in the following two ways. Modify the color of the control directly in the property bar In the project explorer, select a UI file and double-click to open it. On the preview interface, find the control you want to modify, left-click on it, and you can see the corresponding properties table of the control on the right side of the editor. At this time, you can fill in the custom property values as needed. As with Excel, find the property you need to modify, and then click modify. In the text view control, you can see that there are 3 table items related to the color property, namely Foreground Colors This property can set the color value of the text in each state of the control separately Background color Set the background color of the entire rectangular area of the control (will not change according to the state of the control) Background colors To extend the background color property, you can set the background color in each state of the control separately Example： Preview： The above figure is a screenshot of the color part of the properties table. The meaning is: the background color is set to black, and the text color is set to white. When the control is set to the selected state, the text color changes to red. Control color change through code Setting the color in the properties table is intuitive and convenient, but it lacks flexibility. Therefore, in the code, the color can be dynamically controlled by calling the corresponding member function through the control pointer. Take the text control with ID Textview1 as an example, the following functions can implement the purpose of modifying the color.(If you are not sure about the corresponding rules of the pointer variable name and the control ID in the UI file, click here) void setInvalid(BOOL isInvalid) //Set the control Textview1 to the invalid state; if the `color when invalid` property in the propert table is not empty, //set it to the specified color, otherwise there is no change. mTextview1Ptr->setInvalid(true); void setSelected(BOOL isSelected) //Set the control Textview1 to the selected state; if the `color when selected` property in the property table is not //empty, set it to the specified color, otherwise there is no change. mTextview1Ptr->setSelected(true); void setPressed(BOOL isPressed) //Set the control Textview1 to the pressed state; if the `color when pressed` property in the property sheet is not empty, //set it to the specified color, otherwise there is no change. mTextview1Ptr->setPressed(true); void setTextColor(int color) //The parameter color represents RGB color in hexadecimal. //Set the control Textview1 to red. mTextview1Ptr->setTextColor(0xFF0000); How to display decimals The Text View control provides an interface for setting string. /** * @brief Set string text */ void setText(const char *text); If you want to display any number, you can first use the snprintf function to format the number into a string, and then set the string to achieve the purpose of displaying content at will.Example： float n = 3.1415; char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%.3f\", n); //Fixed display 3 decimal places, extra decimal places will be ignored, if not enough, //0 will be added mTextView1Ptr->setText(buf); snprintf is a C language standard function, you can search for relevant information on the Internet, or check here Brief introduction and usage example. Implement animation Since the text control can add a background image, we can use it to simply display a picture.One step further, if we dynamically switch the background image of the text control in the code, as long as the switching time interval is short enough, the animation effect can be implemented. Picture resource preparation A smooth frame animation necessarily requires multiple image resources. Here we have prepared a total of 60 photos. You can see that each picture represents a frame and is named uniformly according to the serial number, which is mainly to facilitate subsequent use. Note: The system will consume more resources when loading pictures. In order to run the interface smoothly, it is strongly recommended that the pictures should not be too large. For example, the size of a single image in the example is only about 5KB Copy these pictures to the resources directory of the project. You can create subfolders under the resources directory to facilitate the sorting of various image resources. Create a text view control Create a text view control arbitrarily in the UI file. And set the background image of the text view control to one of the images. Here I set the first picture as the background picture. This step is just to automatically adjust the width and height of the text view control to the width and height of the picture, you can also choose not to set it. The complete properties are shown in the figure : Compile the project, register the timer After adding the text view control, compile the project again, register a timer in the generated Logic.cc file and set the time interval to 50 ms. We use the timer to switch a picture every 50ms. How to compile the project? How to register timer? Dynamically switch the background of the text view controlIn the corresponding Logic.cc file, add the following function to switch the background image, and call it in the timer trigger function bool onUI_Timer(int id). static void updateAnimation(){ static int animationIndex = 0; char path[50] = {0}; snprintf(path, sizeof(path), \"animation/loading_%d.png\", animationIndex); mTextviewAnimationPtr->setBackgroundPic(path); animationIndex = ++animationIndex % 60; } There are two points in the above function that we need to pay attention to : Switching the background image of the text view control is implemented by the setBackgroundPic(char* path) function. The parameter of the setBackgroundPic(char* path) function is the relative path of the picture. The path is relative to the resources folder in the project. For example: as shown in the figure below, our image is placed under the folder resources/animation/ in the project, then the relative path of loading_0.png is animation/loading_0.png The setBackgroundPic(char* path) function can also accept absolute paths. For example: if you put the image example.png in the root directory of TF card, its corresponding absolute path is /mnt/extsd/example.png, where /mnt/extsd/ is the mount directory of the TF card.. We recommend that all image resources be placed in the project's resoources folder or its subfolders, because image resources in other paths will not be automatically packaged into the software. Download and run, check the effect Complete sample download Use of picture character sets We know that, according to the definition of ascii code, there is a correspondence between character char and integer int. For example, the ascii code of the character 0 is 48. The picture character set is a function of mapping the ascii code to the picture. After setting this function, when we display a string, the system will try to map each character in the string to a specified picture, and finally display a string of pictures on the screen. Setting method Find the Picture Character Set in the text view control, click on the More option on the right, and a picture character set selection box will pop up. Select the import button in the upper right corner to add the picture to the character set. After adding the picture, you can modify the corresponding ascii code or character as the mapping character of the picture. Then click Save If you want to verify whether the picture character set is added successfully, you can modify the text, and the preview effect will be synchronized on the preview.Note: If you set a picture character set, the system will try to map each character to a picture specified in the character set; if a character is not set to a picture, then this character will not be displayed on the screen. Use In the above picture character set setting box, we have mapped the characters 0-9 and: colon as pictures respectively. Then in the code, set the string through the setText(char* str) function. Since we set a special character set in the TextTime text view control, the characters are converted to corresponding pictures. The renderings are as follows: static void updateTime() { char timeStr[20]; struct tm *t = TimeHelper::getDateTime() sprintf(timeStr, \"%02d:%02\", t->tm_hour, t->tm_min); mTextTimePtr->setText(timeStr); } If you only need to display a single character, you can directly set the ascii code or character without converting it into a string.Example : mTextTimePtr->setText((char)48); //Set the ascii code directly, it needs to be //converted to char mTextTimePtr->setText('0'); //Set character directly Sample code Since there are many properties of text controls, please refer to the TextViewDemo project in Sample Code for more property effects. Preview : powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"button.html":{"url":"button.html","title":"Button","keywords":"","body":"Button class I need a button/key, how to add and modify attributes? If you need a button, you can quickly implement it using the existing Button control. The specific steps are as follows: Double click to open the UI file Find the button control in the control set on the right Left-click on the button control and hold it, then drag it to any position, release the left button. Then you can see the automatically generated button control. Left-click on the button just generated then you can see the related properties of the control on the right side of the editor. In this attribute form, you can freely modify the attributes like filling in an Excel sheet! How to modify the color of buttons/keys? Refer to \"How to modify the color of text\" How to add more animation effects to the button? Refer to \"How to use pictures to enrich the style of buttons/keys\" How to use pictures to enrich the style of buttons/keys The default button control is pure color, which looks a bit boring. But you can add pictures to beautify the buttons. Here are the specific steps : First add a button control to the UI file. How to add button controls Left-click to select the button control you just added, and you can see the attribute table of the button in the property bar on the right side of the editor. It is observed that the attributes related to the picture among all the attributes are: Picture settings This attribute can set the pictures in each state of the button, so that the button can automatically switch the corresponding picture according to the state change. Picture location By default, the picture is centered and zoomed to fill the entire button rectangle area. You can adjust the position of the picture and zoom in and out at will. Background picture Set the picture as the background of the button, the picture will cover the entire area of the button, and automatically zoom. Example： Effect picture : The above figure is a screenshot of the parameter part of the attribute table image, and its meaning is: The button displays off_normal.png by default, and it displays on_normal.png when the button is selected The four parameters of the left, top, width, and height of the picture determine the display area of the picture (in pixels). The upper left corner of the button rectangle area is the starting point coordinates (0, 0), and right and down are the positive direction. The end point coordinates are (67, 31). If the actual width and height of the picture are not equal to the specified width and height parameters, the picture will be scaled according to the specified width and height: Understand the hierarchical relationship of button controls For general button controls, it will draw four levels of content, which are from top to bottom: The text of the button The picture of the button The background picture of the button The background color of the button How to add picture buttons/keys? Refer to \"How to add more animation effects to buttons\" When pressing this key/button, where or how to add your own operation code？ In actual development, button is a kind of control that is used very frequently. Usually, after the button click event occurs, some processing is done, such as writing to the serial port or refreshing the UI content. To respond to the click time of the button is very simple. The following are the specific steps : First create a button control and the property ID as Button1. How to create a button control In the Project Explorer, select the current project, right-click, and select the Compile FlywizOS option in the pop-up menu. The function of this step is to automatically generate template code based on all UI files in the current project. Learn more about code generation details Take the UI file main.ftu as an example. After the previous step is completed, the file jni/logic/mainLogic.cc will be generated in the current project folder, as shown below : Note: main.ftu corresponds to mainLogic.cc, the prefixes of both are the same. Learn more about code generation details Double-click to open mainLogic.cc, you should see the following function at the end of the file, static bool onButtonClick_Button1(ZKButton *pButton) { //LOGD(\" ButtonClick Button1 !!!\\n\"); return false; } When the button control is clicked on the serial port screen, the system will automatically call the associated function. So, if you need to add your own processing code, just write it directly in the associated function. As you can see, the function name is generated according to certain rules. Take the button control as an example, its function name generation rule is onButtonClick_XXXX(ZKButton *pButton), where XXXX will be replaced with the control ID, So multiple button controls will generate different associated functions. Learn more about the associated functions of controls System buttons In addition to the ID value defined by itself, the button also retains two system button values: sys_back and sys_home. From the name, we can roughly know their functions: Back button and Home button ; Click the back button, the activity will return to the previous activity, if you enter a multi-level activity, click the Home button to directly return to the main activity (start activity). We only need to set the ID value to sys_back or sys_home in the attribute box of the button to achieve the corresponding function. Learn more about activity interaction How to handle long key press events If you need to handle the long press event of the button, you need to manually add the long press event listener. Specific steps are as follows : In the attribute table of the button, set the long press event trigger time and long press event cycle trigger interval two attributes; in the figure below, I set them to 1000 and 1000 respectively , The unit is milliseconds. After setting the properties, compile and open the corresponding Logic.cc file; at the top of the file, declare class LongClickListener and inherit the ZKBase::ILongClickListener class to implement the virtual void onLongClick(ZKBase *pBase) method. namespace { // Add an anonymous scope to prevent multiple source files from defining the same class name and conflict at runtime //Realize the long press monitoring interface class LongClickListener : public ZKBase::ILongClickListener { virtual void onLongClick(ZKBase *pBase) { LOGD(\"Trigger long press event\"); static int count = 0; char buf[128] = {0}; snprintf(buf, sizeof(buf), \"Long press event trigger times %d\", ++count); //Each time a long press event is triggered, modify the text of the button mLongButtonPtr->setText(buf); } }; } Next, declare it as a static type static LongClickListener longButtonClickListener; Register the button long press monitoring interface in static void onUI_init() function static void onUI_init(){ //Register the button long press monitoring interface mLongButtonPtr->setLongClickListener(&longButtonClickListener); } Un-register the button long press monitoring interface in static void onUI_quit() function static void onUI_quit() { //Un-register the button long press monitoring interface mLongButtonPtr->setLongClickListener(NULL); } After adding the code, compile, download the program to the machine, and long press to test; you can see that the text of the button has been modified, and it means that the onLongClick function has successfully responded. For specific implementation, please refer to Sample Code How to handle button touch events If you need to respond when the button press or lift, you can do by registering the touch monitoring interface. Specific steps are as follows: Implement your own touch monitoring interface : namespace { // Add an anonymous scope to prevent multiple source files from defining the same class name and conflict at runtime // Implement touch monitoring interface class TouchListener : public ZKBase::ITouchListener { public: virtual void onTouchEvent(ZKBase *pBase, const MotionEvent &ev) { switch (ev.mActionStatus) { case MotionEvent::E_ACTION_DOWN: mTouchButtonPtr->setText(\"Press\"); break; case MotionEvent::E_ACTION_UP: mTouchButtonPtr->setText(\"Lift\"); break; default: break; } } }; } Next, declare it as a static type static TouchListener sTouchListener; Register the button touch monitoring interface in the static void onUI_init() function static void onUI_init() { //Register the button touch monitoring interface mTouchButtonPtr->setTouchListener(&sTouchListener); } Un-register the button touch monitoring interface in static void onUI_quit() function static void onUI_quit() { //Un-register the button touch monitoring interface mTouchButtonPtr->setTouchListener(NULL); } After adding the code, compile and download the program to the machine, click touch test; you can see that the text of the button has been modified. For specific implementation, please refer to Sample Code Sample code Since there are many button control properties, please refer to the ButtonDemo project in Sample Code for more property effects Sample preview effect picture : powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"checkbox.html":{"url":"checkbox.html","title":"Checkbox","keywords":"","body":"CheckBox The check box is a control based on the button. If you need a switch button, or a check button, the check box control is more appropriate and easier to use. When the control is clicked, it will automatically switch to the selected state, and click again to switch to the non-selected state. While switching the state, it will automatically switch according to the picture and color set in the properties. How to use Double click to open the UI file Find the Checkbox control in the control collection on the right Left-click the Checkbox control and hold it, then drag it to any position, release the left button, and you can see the automatically generated checkbox control. Left-click the check box control just generated, then you can see the related properties of the control on the right side of the editor. Set the pictures of each state and the color of each state as needed. Pay attention to the picture and color when selected. If you set a picture and find that the size of the picture is displayed abnormally, you can adjust the position and size of the picture in the Picture Position property. Normally, we adjust the picture to the left of the rectangular area and the text to the right of the rectangular area. Compile after the properties are set, and its associated functions will be generated in the corresponding Logic.cc. When you click on the control, the associated function will be called by the system, where the parameter bool isChecked indicates the selected state. static void onCheckedChanged_Checkbox1(ZKCheckBox* pCheckBox, bool isChecked) { if (isChecked) { //Check box is selected LOGD(\"checked\"); } else { //Checkbox is unselected LOGD(\"unchecked\"); } } Download and debug, check the effect. Sample code Please refer to the CheckBoxDemo project in Sample Code. Sample preview effect picture： powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"radiogroup.html":{"url":"radiogroup.html","title":"RadioGroup","keywords":"","body":"RadioGroup For multiple options, single selection, we can directly use the RadioGroup control.When one of the options is clicked, the option will automatically switch to the selected state, and other options in the same group will become non-selected. When these options are switched, they will also be switched automatically according to the pictures and colors set in the properties. How to use Double click to open the UI file Find the RadioGroup control set in the control set on the right Click the left mouse button on the RadioGroup control, then drag it to any position, release the left button, and you will see a rectangular area is automatically generated.It represents a container that can hold the RadioButton control. You can use the same drag and drop operation to add multiple RadioButton controls to the inside of the rectangular area just now. Left-click the added RadioButton control, and its related properties can be seen on the right side of the editor.You can set the picture of each state of each RadioButton and the color of each state according to your needs. Here, pay attention to the Picture and Background Colors property when selected. If you set a picture and find that the picture size is displayed abnormally, you can adjust the position and size of the picture in the Picture Location property.We can also set checked or unchecked in the Default State property Compile after the properties are set, and its associated functions will be generated in the corresponding Logic.cc.When you click on one of the RadioButton, the associated function will be called by the system, where the parameter int checkedID represents the ID of the selected RadioButton.We can determine which RadioButton is currently clicked based on this ID value. This ID is a macro-defined integer value. After the UI file is compiled, each control will automatically generate the corresponding macro ID. (For more information about the macro, please refer to its naming rule),The macro ID of each RadioButton can be found in the corresponding Activity.h header file. E.g Then in the correlation function, the clicked item can be judged. static void onCheckedChanged_RadioGroup1(ZKRadioGroup* pRadioGroup, int checkedID) { LOGD(\"Checked ID = %d\", checkedID); switch (checkedID) { case ID_MAIN_RadioButton1: LOGD(\"First RadioButton\"); break; case ID_MAIN_RadioButton2: LOGD(\"Second RadioButton\"); break; case ID_MAIN_RadioButton3: LOGD(\"Third RadioButton\"); break; default: break; } } Download and debug, check the effect. Sample code Please refer to the RadioGroupDemo project in Sample Code.Sample preview : powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"seekbar.html":{"url":"seekbar.html","title":"Seek Bar","keywords":"","body":"Seek Bar control How to use Seek Bar control In many cases, we will use the seek bar, for example: Volume adjustment Using a few simple pictures, we can quickly implement this effect. First, we prepare four resource pictures Background picture Valid picture Thumb - normal picture Thumb - pressed picture In the editor, create a Seek Bar control If you don’t know how to create controls, Refer to Creating Button Controls The default Seek Bar style is transparent, and we must add enough image resources for it to work properly. In the property table, we set the Valid Picture, Thumb-Normal Picture, Thumb-Pressed Picture and Background Picture. After the previous step is completed, the creation of a Seek Bar is basically completed. If you want to preview the sliding effect of the Seek Bar in the tool, you can modify the max value property and default progress property. In the real-time preview, you can see the position change of the Seek Bar cursor. How to control the progress of the Seek Bar in the code? How to get the current progress of the Seek Bar? If we use a Seek Bar to implement a volume bar, we must know the progress value of the current volume bar, and once the volume bar changes, we must also adjust the volume simultaneously.So, we have the following 3 functions to solve these problems. static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress) Progress value change monitoring function If you create a slider control in the UI file, this function will be automatically added to the corresponding XXXXLogic.cc file after compiling FlywizOS. When sliding the seek bar on the touch screen, or when the current value of the seek bar changes, the system will automatically call this function.static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress) { //LOGD(\"XXXXThe progress value of the seek bar changes to %d !\\n\", progress); } void setProgress(int progress) Used to set the current progress of the slider. E.g://Set the seek bar progress to 28 mSeekbarPtr->setProgress(28) int getProgress() Used to get the progress value of the current seek bar. E.g: int progress = mSeekbarPtr->getProgress(); LOGD(\"The current progress value of the seek bar %s\", progress); Sample For more use of slider controls, please refer to SeekBarDemo project in Sample Code Sample preview : powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"pointer.html":{"url":"pointer.html","title":"Pointer","keywords":"","body":"Pointer control Features If we want to implement an instrument or clock rotation similar effect, this control can be easily implemented. This control is specially designed to handle graphics rotation. Thinking If we want to implement an pointer, we can disassemble it into two parts, the static background image as the dial and the pointer image that rotates on the background image. Therefore, after selecting the background image and the pointer image, we only need to determine the center coordinates of the pointer rotation. How to use We first create an pointer control, you can see that it has the following properties: If you don’t know how to create a control, you can refer to How to create a button controlIn the property picture, you can see that I have added pointer image and background image The adding process is shown in the animation : Judging from the final preview image above, no problems were found, and the background image and pointer position looked normal. However, after the program actually runs, it is wrong. For quick and easy adjustment, we can set the starting angle property to other degrees (default is 0), here we adjust it to 120, we can find that after the pointer is rotated by 120°, the result of the pointer rotation is not what we expect like that.The reason for this is that the coordinates of the center of the circle where the pointer rotates are incorrect.There are two properties that determine the coordinates of the pointer rotation center, they are rotation point coordinates and fixed point coordinates Rotation point coordinatesThe coordinates are with reference to the entire rectangular area of the control. The upper left corner of the rectangular area of the control is [0,0], in pixels. For such an instrument, obviously the coordinates of the rotation point we want are in the center of the dial. , Then the specific coordinates of the corresponding picture are (250, 250), as shown below : Fixed point coordinatesThe coordinates refer to the pointer picture, the upper left corner of the picture is [0,0], and the unit is pixel. For such a pointer picture, the fixed point coordinates of the pointer we want is (30, 210) After filling the two coordinates into the attribute table, you can see that the pointer rotates to the correct position Starting angle supports negative numbers. In the above example, if change the starting angle to -120, the pointer just points to the dial 0 position. Tips on the fixed point of the pointer In the above example, the coordinate of the fixed point of the pointer is located in the pointer picture. In fact, this coordinate can also exceed the range of the picture to achieve the effect of the cursor. As shown in the figure below, the white in the red box is actually a pointer picture, which is relatively small, but in the property on the right, I set the coordinates of the fixed point of the pointer far beyond the real size of the picture, and then adjust the rotation coordinates to implement the effect of the circular cursor. Operation method The most common method for this type of control is to adjust the rotation angle of the pointer through code. //Adjust the pointer to 90 degrees mPointer1Ptr->setTargetAngle(90.0); Sample code For the use of specific pointer controls, refer to the PointerDemo project in Sample Code. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"listview.html":{"url":"listview.html","title":"List","keywords":"","body":"List control Function The list control is often used when a page cannot display all the information, and there are some consistent attribute classifications in each unit information. Scenes WiFi list, device list, table information How to use Open the UI file, create a list control, and add two list item controls to the list. Then you can see the appearance style of the list. The specific operations are as follows: Select the list, you can see that it has the following properties You can try to modify each property, and then download the program to the machine to view the specific changes. Now go to the outline view You can see that an Item node is generated by default under the list, which represents a row or column of the list, and Item contains the two ListSub nodes we added.You can click to select each node to view their respective properties, and the scope of their effects can be seen on the preview.Note: Each list control can add up to 32 list items. The properties of Item and List Subitem controls are similar to the Button controls. You can modify their properties separately and adjust the style. Below is the modified result using the example : After adjusting the general appearance of the list in the UI file, compile (How to compile the FlywizOS project). In the automatically generated correlation function, we need to add specific logic code to draw the specific content of the list. After compiling, in the corresponding Logic.cc source file, each list control will generate three related functions. int getListItemCount_ListView1()： Get the length of the list to be drawn For example: there are 100 data to be displayed, then 100 is returned. void obtainListItemData_List1： Set the specific display content of each item in the list For specific examples, see follow-up documents The above two functions jointly control the display content of the list. onListItemClick_List1： Click event of list control When clicking on an item in the list, the system will call this function, and the parameter index represents the index value of the currently clicked list item. List drawing process When we want to draw a list, the system first needs to know how many items it has in total, so we provide the int getListItemCount_ListView1() function, which will be called by the system to get the length of the list (the total number of items), Note that this function is dynamically obtained. During the running of the program, we can return different values according to needs, and then we can dynamically control the length of the list. Then, the system will call the function void obtainListItemData_ListView1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) multiple times. For each call, we can use the pointer provided by the parameter in this function to control the specific content of each item in detail. Example 1. Set the display content of the list itemstatic void obtainListItemData_ListView1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { //The pListItem pointer represents a list item, which can only be used in this function char buf[32] = {0}; //The parameter index indicates which item of the list is currently drawn, starting from 0. //Here, we format the index value into a string snprintf(buf, sizeof(buf), \"Item %d\", index); //Display the string as text in the list item area pListItem->setText(buf); //If you have configured the list item \"Picture when selected\" in the ui file, //Then, by setting the selected state of the list item through the following line of code, you can control the list item to //display the corresponding state picture pListItem->setSelected(true); } Example 2. Set the display content of the list subitemIf we use the list subitem, we can get the pointer of the list item by the following method, and then manipulate the list item through the newly obtained pointer. static void obtainListItemData_ListView1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { char buf[32] = {0}; //The parameter index indicates which item of the list is currently drawn, starting from 0. //Here, we format the index value into a string snprintf(buf, sizeof(buf), \"The first child of item %d\", index); //We can get the pointer of the list item through the findSubItemByID() function and the ID of the list item //Same as the pListItem pointer, the list item pointer that is found can only be used in this function ZKListView::ZKListSubItem* subitem1 = pListItem->findSubItemByID(ID_MAIN_SubItem1); if (subitem1 != NULL) { //Set the text of list item 1 subitem1->setText(buf); } snprintf(buf, sizeof(buf), \"The second child of item %d\", index); ZKListView::ZKListSubItem* subitem2 = pListItem->findSubItemByID(ID_MAIN_SubItem2); if (subitem2 != NULL) { //Set the text of list item 2 subitem2->setText(buf); } } The idea of list In our system, the list is a mapping of a series of rule data. If we want to modify the list, such as adding a piece of data, or modifying a certain item, we should modify the data first, then trigger the refresh, and then the system will automatically call obtainListItemData_ListView1 function, in this function, set the display content of the list according to the latest data. This idea is reflected in the following example. Sample code We provide a sample list control, refer to the ListViewDemo project in Sample Code. Sample explanation Create a list control We create two list controls in turn and try to set different properties and appearances. Rotation List control: Turn on the cycle list option Compile the project This step will automatically generate the code related to the list to the corresponding Logic.cc file.Specific operation reference \"How to compile FlywizOS project\" The data structure needed to create the List1 listIn general, we will define a structure as a model for each data item in the list typedef struct { //The text displayed in the list item const char* mainText; //The text to be displayed in list sub item 1 const char* subText; //Turn on/off logo bool bOn; } S_TEST_DATA; We define another structure array to simulate list data static S_TEST_DATA sDataTestTab[] = { { \"Test1\", \"testsub1\", false }, { \"Test2\", \"testsub2\", false }, { \"Test3\", \"testsub3\", false }, { \"Test4\", \"testsub4\", true }, { \"Test5\", \"testsub5\", false }, { \"Test6\", \"testsub6\", true }, { \"Test7\", \"testsub7\", false }, { \"Test8\", \"testsub8\", false }, { \"Test9\", \"testsub9\", false }, { \"Test10\", \"testsub10\", false }, { \"Test11\", \"testsub11\", false } }; Add list function code static int getListItemCount_List1(const ZKListView *pListView) { //Use the length of the array as the length of the list return sizeof(sDataTestTab) / sizeof(S_TEST_DATA); } static void obtainListItemData_List1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { //Get the pointer of the list sub item 1 and name it psubText ZKListView::ZKListSubItem* psubText = pListItem->findSubItemByID(ID_MAIN_ListSub1); //Get the pointer of the list sub item 2 and name it psubButton ZKListView::ZKListSubItem* psubButton = pListItem->findSubItemByID(ID_MAIN_ListSub2); pListItem->setText(sDataTestTab[index].mainText); //Take index as the subscript, get the corresponding structure from the array, get the text that needs to be displayed //from the structure, and finally set it to the corresponding list item psubText->setText(sDataTestTab[index].subText); //In the UI file, we set the selected image property for the list sub item 2 //Here, according to the `bOn` value of the structure, the selected state of the list item is set, so that if the member //`bOn` is true, it is set to be selected, and the system will automatically display the selected picture previously set psubButton->setSelected(sDataTestTab[index].bOn); } static void onListItemClick_List1(ZKListView *pListView, int index, int id) { //When you click the index item in the list, modify the bOn variable to reverse bOn. In this way, every time you click on //the list, the picture will switch once //Note that the operation of picture switching is completed in the obtainListItemData_List1 function, and now we only //modify the value of this variable. sDataTestTab[index].bOn = !sDataTestTab[index].bOn; //The last sentence of code modified the structure data, and now we want to refresh the list immediately, and call //refreshListView to force a refresh //After the refresh is triggered, the system will call the two functions getListItemCount_List1 and //obtainListItemData_List1 again, so that the modified data corresponds to the list display. mList1Ptr->refreshListView(); } After adding the code, you can run it to see the actual effect. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"diagram.html":{"url":"diagram.html","title":"Diagram","keywords":"","body":"Diagram Use this control to easily draw a curve or broken line diagram. How to use First, create a diagram control in the UI file, which specifies the drawing area of the waveform, and then add a waveform control to the area just created. You can see a rough preview of the diagram immediately. The specific creation process is as follows: You can add multiple waveforms to the diagram and adjust their appearance. Note: Since we cannot directly select a single waveform control on the preview image, when we need to adjust the specified waveform properties, we need to select on the outline view. Check the properties of the diagram and waveform controls respectively, you can find that diagram determines the value range of the x-axis, y-axis of the waveform, and the drawing area of the waveform. The waveform determines the appearance style of each waveform. Among them, the two properties of step and erase space in the properties of waveform need to be explained. Step It represents the value of the advance of the waveform image every time you add a piece of data to the waveform. This value will be affected by the x-axis zoom property. Erase SpaceIndicates the width of the vacanct part when the waveform is refreshed The above two properties are only valid when the waveform data is added using the void addData(int index, float data) function. Coordinate axis and scale The image scaling of the entire waveform is done automatically, we don't need to care about it, we only need to determine the x-axis range, y-axis range, and the rectangular display area of the entire waveform image in the property table. Note: The X scale and Y scale properties in the waveform control will multiply the value by the ratio and then draw it on the screen. The default is 1.0, which means no scaling. The coordinate axis of the waveform is determined by x-axis min value, x-axis max value, y-axis min value, and y-axis max value. For example, the default x-axis range is [0, 100], y-axis range is [0,100], then the coordinate axis they form is In general, the value entered in the x-axis min value property is smaller than the value of the x-axis max value property. But if the input minimum and maximum values are reversed, the waveform image drawn with the same data will be reversed; If you use the void setData(int index, const MPPOINT *pPoints, int count) function to add waveform data, the refresh direction will be reversed. Similarly, for the y-axis, drawing a waveform image will cause upside down. Code operating Similarly, the UI file only helps us quickly modify the appearance of the waveform, and the specific waveform data must be added through code. In the public function of the project's jni/include/control/ZKDiagram.h file, you can see all the supported operations. Note: Different from other controls, the Waveform control we added has ID attribute, but it does not generate independent pointer variables. Only the Diagram control that contains Waveform will generate pointer variables. Therefore, to operate a certain waveform, you need to use the Diagram pointer, and then use the index value to indicate which waveform is operated. The value of index starts from 0. void setPenWidth(int index, int width)Set the waveform line width, corresponding to the pen width property on the property sheet void setPenColor(int index, ARGB color)Set the waveform color, corresponding to the pen color property on the property sheet void setXScale(int index, double xScale)Set the x-axis scale, corresponding to the x-axis scale property on the property sheet, void setYScale(int index, double yScale)Set the y-axis scale, corresponding to the y-axis scale property on the property sheet, void setData(int index, const MPPOINT *pPoints, int count) typedef struct _MPPOINT { float x; float y; }MPPOINT; The MMPOINT structure contains the x and y values of a single data. The function means to draw the count points in the pPoints array onto the indexth waveform. Note: The count value cannot be greater than the actual size of the pPoints array, otherwise the array will be out of bounds.The idea of using this function to draw waveforms is : First fill the data to be displayed into the sPoints array, and then draw the points in the array on the waveform at one time. Therefore, if you want to achieve the animation effect of the waveform moving to the left or right, you need to manually offset the value in the array by one subscript as a whole, and then display it on the waveform, and then shift it by one subscript as a whole, and then displayed on the waveform, and so on. Usually such a loop is implemented through a timer.So this method will cause the entire waveform image will be refreshed. void addData(int index, float data) Add a single data to the waveform, data is the y value, you may wonder why there is no x value, because this function number is local waveform refresh, when you call this function to set the y value every time, The system will automatically offset a certain x value, and the size of this offset is the same as the set step property.Comparing void setData(int index, const MPPOINT *pPoints, int count) and void addData(int index, float data) two ways to refresh the waveform, it can be concluded that if the amount of data is large, the second method will have higher refresh efficiency. setData(index, NULL, 0) To clear the waveform data Additional method of wave movement As mentioned earlier, if you use the void setData(int index, const MPPOINT *pPoints, int count) method to draw waveforms, you usually need to offset the values in the array by yourself. static void movePoints(MPPOINT* p,int size){ for(int i =0;i Add timer to refresh waveform data regularly In general, add a timer to match the waveform to facilitate regular refresh Sample code Effect pictureFor the use of specific waveform control, please refer to the DiagramDemo project in Sample Code. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"circlebar.html":{"url":"circlebar.html","title":"Circle Bar","keywords":"","body":"Circular progress bar In some cases, we need to display a \"Loading\" animation. Then the circular progress bar is very suitable. How to use First, open the UI file, create a circular progress bar, and then set the valid picture properties. A basic circular progress bar is created. All its properties are as follows: The circular progress bar essentially displays the fan-shaped area corresponding to the current progress. This area is a crop of the valid picture. For example: If the properties are set according to the above figure, the maximum value is 100, the starting angle is 0, and the rotation direction is clockwise, then when we set the progress of 25, only the 90° fan-shaped area in the upper right corner is displayed. If the progress value is 100, then all valid graphs are displayed. Note: The display area of this sector is only cropped for the valid picture, the background picture will not be cropped. Code operating The operation function provided by the circular progress bar is very simple. //Set current progress void setProgress(int progress); //Get current progress int getProgress()； //Set maximum progress void setMax(int max); //Get maximum progress int getMax()； Sample code In the example, when you slide the upper slide bar, the progress of the two circular progress bars at the bottom will change accordingly. For the specific use of the circular progress bar control, refer to the CircleBarDemo project in Sample Code powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"qrcode.html":{"url":"qrcode.html","title":"QR Code","keywords":"","body":"QR code How to add QR code？ If you need to display a QR code, you can quickly implement it using the existing QR code control. The specific steps are as follows: Double click to open the UI file Find the QR code control in the control set on the right Left-click the QR code control and hold it, then drag it to any position, release the left button, and you can see the control of the automatic QR code. Select the QR code control just generated, and in the property bar on the right side of the editor, you can modify the content of the QR code, and you can see that the QR code image will change simultaneously. Dynamically update the QR code In addition to setting the QR code content through the tool, we can also dynamically set the QR code content through the code : bool loadQRCode(const char *pStr); Sample code For the specific use of the QR code control, refer to the QrCodeDemo project in Sample Code. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"video.html":{"url":"video.html","title":"Video View","keywords":"","body":"Video view FlywizOS also provides controls for video playback. [!Note] The video playback function is not supported by all versions of the machine! If you need to use this function normally, please purchase a machine version with multimedia functions. Use controls to loop video playback First, create a Video view control. The default background color is black. View the property table of Video view Among them, one property is LoopIf you choose Yes, then every time you enter this activity, it will automatically read the configuration file in the TF card directory and play the video specified in the configuration file in a loop. Exit the activity and automatically stop playing. This property is very suitable for scenes where only the video needs to be played without user intervention, such as carousel advertising machines, automatic playback of a short video, etc. If you select No, only a rendering area of the video will be created, and there will be no other operations. Then, you need to operate the video playback yourself. Create video configuration fileAs mentioned above, if it is a Loop, the video configuration file will be automatically read. You need to create it yourself.This configuration file needs to be located in the root directory of the TF card, the file name is XXXX_video_list.txt XXXX represents the corresponding UI file prefix name. For example: I added a video control to main.ftu, then the corresponding configuration file name is main_video_list.txtThe configuration file is in units of lines, and each line is the absolute path of the video file. If the video file is also located in the root directory of the TF card, then directly fill in /mnt/extsd/ and add the video file name. Note: To prevent video file reading failure due to encoding problems, please try to name the video file in English. After the program runs, you can automatically loop the videos in the configuration file. Play the specified video file Create a video view control Set the property Loop to No. Add code to control the playback logic Play //Play the test.mp4 file, starting from time 0 mVideoView1Ptr->play(\"/mnt/extsd/test.mp4\", 0); Pause //Pause playback mVideoView1Ptr->pause(); Resume //Resume playback mVideoView1Ptr->resume(); Stop mVideoView1Ptr->stop(); Jump to the specified time to play //Jump to the 10 second position mVideoView1Ptr->seekTo(10 * 1000); Set playback volume, range 0~1.0 //Set the volume to 0.5 mVideoView1Ptr->setVolume(0.5); Determine if it is playing bool state = mVideoView1Ptr->isPlaying(); if （state) { LOGD(\"Now Playing\"); } Get the total duration of the video, in milliseconds int n = mVideoView1Ptr->getDuration(); Get the current playback position of the video, in milliseconds int n = mVideoView1Ptr->getCurrentPosition(); The video is played asynchronously, and the automatically generated associated function will notify us of the status of the video playback static void onVideoViewPlayerMessageListener_VideoView1(ZKVideoView *pVideoView, int msg) { switch (msg) { case ZKVideoView::E_MSGTYPE_VIDEO_PLAY_STARTED: LOGD(\"Start playback\"); break; case ZKVideoView::E_MSGTYPE_VIDEO_PLAY_COMPLETED: LOGD(\"End playback\"); break; case ZKVideoView::E_MSGTYPE_VIDEO_PLAY_ERROR: LOGD(\"Error\"); break; } } Implementation of a complete video player If you have higher requirements for video playback, you need to control play/pause, drag the video progress bar, etc.You can refer to Complete Video Player Sample (to be continued) Sample code In this example, the loop playback of the video and the adjustment of the video volume are realized.For specific implementation, refer to the VideDemo project in Sample Code. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"edittext.html":{"url":"edittext.html","title":"Edit Text","keywords":"","body":"Edit Text I need a numeric keyboard, and I need the user to manually input Text, what should I do? How to add edit/input box How to add Edit Text box If you need numeric and text input, you can quickly implement it by using the existing Edit Text controls. The specific steps are as follows: Double click to open the main.ftu file Find the Edit Text control in the right control collection Left-click the Edit Text control and hold it, then drag it to any position, release the left button, you can see the control of the automatic edit/input box. In the properties on the right, select Input Type according to your needs. If you need to enter text, then select Text. When the download is running on the machine, click on the Edit Text control, and a built-in input method or numeric keyboard of the system will automatically open, so that you can enter text or numbers. Built-in text input method screenshot Built-in numeric keyboard input screenshot The default Edit Text is white, you can customize the appearance style in the property table on the right. Among them, the relevant properties of the Edit Text are as follows: PasswordIf you choose Yes, when you simulate keyboard input, the character you are typing will be displayed as the specified password character, otherwise no change Password CharIf you select Yes for Password, the character you are typing will be displayed as the specified Password Char, otherwise no change Input TypeThere are two options for this property, respectively are TextMeans that you can enter English and numbers without restriction. NumberIndicates that only numbers can be input, others are restricted. Hint TextWhen the content in the simulated keyboard is empty, the prompt text will be displayed automatically. Hint Text ColorWhen the content in the simulated keyboard is empty, the prompt text will be displayed automatically, and the text color is the specified color. How to get the input content of the simulated keyboard? When the Edit Text is successfully created, select compile FlywizOS, and its associated function will be automatically generated, Open the jni/logic/****Logic.cc file (**** represents the UI file name) in the project directory, and find the automatically generated function(XXXX represents the control ID name) Learn more about the relation function of the control static void onEditTextChanged_XXXX(const std::string &text) { //LOGD(\"The current input is %s \\n\", text.c_str()); } When the simulated keyboard input is finished, the system will automatically call this function, and the parameter text is the complete string on the current simulated keyboard.std::string is a string of C++ language. You can also get the string pointer in C language through the following statement. const char* str = text.c_str(); How to convert a string to a number? In the associated function of the Edit Text, we can only get the string, so when we input the number, we need to convert the number string to the number. The atoi function can convert a string to a corresponding number, for example, \"213\" can be converted to an integer 213If illegal characters are encountered, the conversion will fail or the parsing will be interrupted. E.g:atoi(\"213abc\"); return 213atoi(\"abc\"); return 0static void onEditTextChanged_EditText1(const std::string &text) { int number = atoi(text.c_str()); LOGD(\"String to number = %d\", number); } The atof function can convert a string to a corresponding floating point number, for example, \"3.14\" can be converted to a floating point number 3.14If illegal characters are encountered, the conversion will fail or the parsing will be interrupted. E.g :atoi(\"3.14abc\"); return 3.14atoi(\"abc\"); return 0static void onEditTextChanged_EditText1(const std::string &text) { // The atof function can convert a string to a corresponding floating point number, for example, \"3.14\" can be converted to an // integer 3.14 // If the parameters are not standardized, the conversion will fail, and the number 0 will be returned uniformly double f = atof(text.c_str()); LOGD(\"Convert string to floating point = %f\", f); } How to customize the input method? In addition to using the default input method, we can also customize the input method. Sample Code Package provides a demonstration example ImeDemo project.Currently only supports the customization of numbers and letters input. There are some differences between the implementation of the input method interface and the ordinary interface : The normal interface is implemented by inheriting Activity, and the input method needs to inherit IMEBaseApp ; In addition, the registration method is different. The normal interface registration method: REGISTER_ACTIVITY(****Activity);, the input method interface registration method: REGISTER_SYSAPP(APP_TYPE_SYS_IME, ****Activity);(**\\ \\ indicates the UI file name) These differences have been modified in the ImeDemo project, just migrate to your own project : Copy the UserIme.ftu file in the ui directory to the ui directory of your own project. Copy the files UserImeActivity.h and UserImeActivity.cpp in the activity directory to the activity directory of your own project. Copy the UserImeLogic.cc file in the logic directory to the logic directory of your project. The subsequent operation is consistent with the normal interface programming, and the logic is written in UserImeLogic.cc. powered by Gitbooklast modified: 2020-12-11 14:43:26 "},"window.html":{"url":"window.html","title":"Window","keywords":"","body":"Window control Function description The window is actually a container part. It can contain all the controls, or it can contain a new window again. Can be used in the following scenarios Show and hide a control combination When you need to complete the tab page, you can switch between different windows through multiple windows Pop-up dialog Pop up floating box How to use Create a Window control, the default window is transparent. You can add a background image or modify the background color according to your needs; you can also add other controls to the window. In the above attribute table, there are two attributes that need to be explained : ModalIf it is modal, when this window control is displayed, click outside the window, the window will be automatically hidden.If it is non-modal, the display/hide of the window control must be controlled by itself. Timeout auto hideIf it is a modal window, the window will start counting from the beginning of the display and will be automatically hidden after the Timeout auto hide time. The unit is seconds; if the value is -1, it means that it will not be hidden automatically.If it is non-modal, then this parameter has no effect. Operation code For window controls, we generally involve the following functions //Show window void showWnd(); //Hide window void hideWnd(); //Determine whether the window is displayed bool isWndShow(); Dynamically set background If we spread the window all over the screen and then set the background of this window, we can achieve the effect of modifying the screen background. Related function /** * @brief Set background picture * @param pPicPath Picture path */ void setBackgroundPic(const char *pPicPath); /** * @brief Set background color * @param color When -1, the background is set to transparent; other color values are 0xRGB, and the color value does not * support alpha */ void setBackgroundColor(int color); Usage example //Set the image of the path /mnt/extsd/bg.png as the background image of this window control mWindow1Ptr->setBackgroundPic(\"/mnt/extsd/bg.png\"); //Set the background color of the window with ID window1 to red mWindow1Ptr->setBackgroundColor(0xff0000); //Set the background color of the window with ID window1 to green mWindow1Ptr->setBackgroundColor(0x00ff00); //Set the background color of the window with ID window1 to blue mWindow1Ptr->setBackgroundColor(0x0000ff); Many controls have functions for setting the background color and background image, and the methods are the same. Sample code Demonstrates the use of modal/non-modal window controls For specific use of window controls, refer to the WindowDemo project in Sample Code powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"slidewindow.html":{"url":"slidewindow.html","title":"Slide Window","keywords":"","body":"Slide window control The slide window control is similar to the interface effect of sliding left and right on the main interface of the mobile phone. Consists of a sliding main window and multiple icons. How to use First create a Slide Window control in the UI file, and then add multiple Slide Window Icon controls to the main window control. When adding a Slide window icon control, it will automatically arrange the icons in order. If you add a full page, continue adding it will automatically turn the page. All the added icon controls can be found in Outline. If you want to adjust the position of the sliding window icons, you can select the node in the outline view, and then directly adjust it by dragging. Note the operation of the outline view in the lower left corner of the animation below. In the outline view, select the slide window icon control, you can add pictures and modify the text separately; select the entire slide window to adjust the number of rows and columns, and you can also adjust it uniformly font size, icon size. Code operating If you add a slide window control, then after compiling, an associated function will be automatically generated. For detailed function description, please refer to Slide Window Related Function In general, we only need to scroll up and down by touching and sliding. However, we also provide the corresponding page turning function. Switch to the next page// Switch to the next page with animation mSlideWindow1Ptr->turnToNextPage(true); // Switch to the next page without animation mSlideWindow1Ptr->turnToNextPage(false); Switch to the previous page// Switch to the previous page with animation mSlideWindow1Ptr->turnToPrevPage(true); // Switch to the previous page without animation mSlideWindow1Ptr->turnToPrevPage(false); We can also monitor which page the slide window has turned to through the code : namespace { // Add an anonymous scope to prevent multiple source files from defining the same class name and conflict at // runtime // Implement your own listening interface class MySlidePageChangeListener : public ZKSlideWindow::ISlidePageChangeListener { public: virtual void onSlidePageChange(ZKSlideWindow *pSlideWindow, int page) { LOGD(\"Now switch to page %d\", page); } }; } // Define the listening object static MySlidePageChangeListener sMySlidePageChangeListener; static void onUI_init() { mSlidewindow1Ptr->setSlidePageChangeListener(&sMySlidePageChangeListener); } Get the current page int i = mSlideWindow1Ptr->getCurrentPage(); LOGD(\"Current page %d\", i); Sample code For specific use of sliding window controls, refer to the SlideWindowDemo project in Sample Code. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"painter.html":{"url":"painter.html","title":"Painter","keywords":"","body":"Painter The painter control provides a simple geometric drawing interface. How to use Create a painter control, the default painter control is transparent. You can add a background image or modify the background color according to your needs. Code operating Through the pointer of the painter control, you can call the interface to draw graphics. Almost all functions of this control require code implementation. The example is as follows. static void onUI_init() { /** * Draw a rounded rectangle border */ mPainter1Ptr->setLineWidth(4); mPainter1Ptr->setSourceColor(0x7092be); mPainter1Ptr->drawRect(10, 10, 430, 230, 5, 5); /** * Draw an arc */ mPainter1Ptr->setLineWidth(3); mPainter1Ptr->setSourceColor(0xadc70c); mPainter1Ptr->drawArc(80, 80, 40, 40, -20, -120); /** * fill an arc */ mPainter1Ptr->setLineWidth(3); mPainter1Ptr->setSourceColor(0x008ecc); mPainter1Ptr->fillArc(80, 80, 40, 40, -20, 120); /** * Draw triangle */ mPainter1Ptr->setLineWidth(4); mPainter1Ptr->setSourceColor(0xff804f); mPainter1Ptr->drawTriangle(200, 40, 160, 90, 240, 90);//空心三角形 mPainter1Ptr->fillTriangle(300, 40, 260, 90, 340, 90); //实心三角形 /** * Draw straight line */ MPPOINT points1[] = { {50 , 150}, {150, 150}, {70 , 200}, {100, 120}, {130, 200}, {50 , 150} }; /** Connect to a line according to the provided coordinates of multiple points */ mPainter1Ptr->setLineWidth(2); mPainter1Ptr->setSourceColor(0x88cffa); mPainter1Ptr->drawLines(points1, TABLESIZE(points1)); /** * Draw a curve */ MPPOINT points2[] = { {250, 150}, {350, 150}, {270, 200}, {300, 120}, {330, 200}, {250, 150} }; mPainter1Ptr->setLineWidth(3); mPainter1Ptr->setSourceColor(0xe28ddf); /** Connect as a curve according to the provided multiple point coordinates */ mPainter1Ptr->drawCurve(points2, TABLESIZE(points2)); } Sample code Demonstrates the use of the painter control For the specific usage of the painter control, please refer to the PainterDemo project in Sample Code powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"camera.html":{"url":"camera.html","title":"Camera","keywords":"","body":"Camera The FlywizOS provides camera controls. [!Note] Not all versions of the board support the camera function! If you need to use this function normally, please purchase a version that supports the USB camera function How to use First, create a camera control, default background color is black. View the attribute table of camera Set Auto Preview to OnAccording to the connected camera model, select CVBS signal or not Connect the camera to the board, and then download and run the program, you can see the camera preview screen. Start/Stop preview We can start/stop the preview screen through source code. Start previewmCameraView1Ptr->startPreview(); Stop previewmCameraView1Ptr->stopPreview(); Photo camera Implement the camera callback interface class PictureCallback : public ZKCamera::IPictureCallback { public: virtual void onPictureTakenStarted() { mTextView1Ptr->setText(\"Start taking a photo\"); } virtual void onPictureTakenEnd() { mTextView1Ptr->setText(\"End of photo\"); } virtual void onPictureTakenError() { mTextView1Ptr->setText(\"Photo error\"); } virtual const char* onPictureSavePath() { //Photo save path return \"/mnt/extsd/camera.jpg\"; } }; Instantiate the interface and register //Defined as a global static variable static PictureCallback picture_callback; Register the camera callback interface static void onUI_init(){ mCameraView1Ptr->setPictureCallback(&picture_callback); } static void onUI_quit() { //Remember to empty the registration interface when the interface exits mCameraView1Ptr->setPictureCallback(NULL); } Add a button, when you click the button, request a photostatic bool onButtonClick_Button3(ZKButton *pButton) { //Request a photo mCameraView1Ptr->takePicture(); return false; } Sample code In this example, the camera preview and camera functions, and album functions are implemented. For specific implementation, refer to Sample Code CameraDemo project powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"digital_clock.html":{"url":"digital_clock.html","title":"Digital Clock","keywords":"","body":"Digital clock The digital clock is a control dedicated to time display. In many scenarios, we need to display the time. This control will automatically display according to the system time. How to use Double click to open the UI file Find the digital clock control in the control set on the right Left-click the digital clock control and hold it, then drag it to any position, release the left button, and you can see the digital clock control. Select the digital clock control just generated, in the property bar on the right side of the editor, you can modify its property content, mainly modify the following five properties. FormatThis property sets the display format of the time, you can choose a 24-hour system or a 12-hour system, and control whether the seconds are displayed. BlinkingThis property controls whether the : in the clock is static or beating. ColorThis property sets the color display of the clock text. Font sizeThe text size of the digital clock Picture Character SetWe know that, according to the definition of ascii code, there is a correspondence between character char and integer int. For example, the ascii code of the character 0 is 48. The special character set is a function of mapping the ascii code to the picture. After setting this function, when we display a string, the system will try to map each character in the string to a specified picture, and finally display a string of pictures on the screen. For specific usage, please refer to Use of Special Character Set in the text control Save, download and debug, after running, you can see the effect. If you want to modify the time, you can refer to the System Time document to modify. Sample code Refer to the DigitalClockDemo project in Sample Code powered by Gitbooklast modified: 2020-12-11 14:42:18 "},"relation_function.html":{"url":"relation_function.html","title":"Introduction to correlation functions","keywords":"","body":"Explanation of associated functions automatically generated by controls Some controls will automatically generate associated functions. The specific explanation of the associated functions generated by these controls is as follows : [!Note] The XXXX in the function represents the control ID, please replace it yourself in the actual process Button control static bool onButtonClick_XXXX(ZKButton *pButton) { return false; } When the button is clicked, this function is called. The parameter ZKButton *pButton is the pointer of the clicked button. A series of operations can be performed on the control through the member functions of the pointer. This pointer is the same object as the object pointed to by the global variable mXXXXPtr. Edit Text control static void onEditTextChanged_XXXX(const std::string &text) { } When the text in the Edit Text box changes, the system will automatically call this function. Parameter std::string &text is the complete string in the current Edit Text box. Seek Bar control static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress) { } When the current progress value of the Seek bar changes, the system will automatically call this function. Parameter ZKSeekBar *pSeekBar is the pointer of the Seek Bar control, and a series of operations can be performed on the control through the member functions of the pointer. Parameter int progress is the progress value of the current Seek Bar Slide window control static void onSlideItemClick_XXXX(ZKSlideWindow *pSlideWindow, int index) { } When you click an icon in the sliding window control, the system will automatically call this function. Parameter ZKSlideWindow *pSlideWindow is the pointer of the slide window control, and a series of operations can be performed on the control through the member functions of the pointer. Parameter int index is the index value of the currently clicked icon. For example, a total of 10 icons are added to the slide window, and the index value range is [0, 9] List control The list control is the most complex control, it will create three associated functions. Although there are many functions, it is very easy to understand according to the following steps. First, if the system wants to draw a list control, it needs to know how many items it has. So there is the following correlation function static int getListItemCount_XXXX(const ZKListView *pListView) { return 0; } Parameter const ZKListView *pListView is the pointer of the list control, which points to the same object as the global variable mXXXXPtr. Return value is an integer, which means how many items there are in the list, which can be defined according to your needs. After the system knows the number that needs to be drawn, it is not enough. It also needs to know what content you display for each item. So with the following function, it will be called multiple times, allowing you to set the display content of each item until each item is processed. void obtainListItemData_XXXX(ZKListView *pListView, ZKListView::ZKListItem *pListItem, int index) { //pListItem->setText(index) } Parameter ZKListView *pListView is the pointer of the list control, which points to the same object as the global variable mXXXXPtr. Parameter ZKListView::ZKListItem *pListItem is the pointer of the list item, corresponding to the Item in the UI file Parameter int index is the index value of pListItem in the entire list. It has a certain range. For example: The return value of the getListItemCount_XXXX function is 10, which means there are 10 items in the list. Then the range of index is [0, 9], combining pListItem and index, you can know where the list item you set now is in the entire list.In this function, you can set the display content of each item separately according to index.For example: The commented statement in the function means: each list item displays its corresponding index number as text. Similar to the button control, the list control also has a click event, but it judges which list item is currently clicked based on the index value. static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); } When the list control is clicked, the system will calculate the index number of the list item and will automatically call this function. Parameter ZKListView *pListView is the pointer of the list control, which points to the same object as the global variable mXXXXPtr. Parameter int index is the index value of the currently clicked list item in the entire list control Parameter int id is the id of the currently clicked control. Note that this id is different from the ID name in the attribute table. Its specific macros are defined in the corresponding Activity.h file. For example in mainActivity.h The function of this id parameter is that when there are multiple sub-items in the list item, it can be used to distinguish which sub-item is currently clicked.For example: As shown in the figure below, I added two list items to the list item and added a picture decoration as a switch button. The attribute ID names are SubItem1 and SubItem2 respectively. When I click on SubItem1 in the case of, by judging the equal relationship between the parameter id and ID_MAIN_SubItem1 and ID_MAIN_SubItem2, which switch is clicked can be determined.Example code : static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); switch(id) { case ID_MAIN_SubItem1: //LOGD(\"Clicked the first subitem of item %d in the list\", index); break; case ID_MAIN_SubItem2: //LOGD(\"Clicked the second subitem of item %d in the list\", index); break; } } powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"first_app.html":{"url":"first_app.html","title":"The first startup activity","keywords":"","body":"When we create a new project, there is a Main.cpp file in the generated template code, path: jni/Main.cpp; the template code is as follows: The code in the red box is the startup interface code, and the interface is mainActivity. The corresponding UI resource file is main.ftu. Specifically, we can look at the code in jni/activity/mainActivity.cpp. It is clear which UI resource is corresponding: powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"open_close_app.html":{"url":"open_close_app.html","title":"Open/close application activity ","keywords":"","body":"We have already learned about the startup activity. After entering the startup interface, we can open other activity, enter the second and third levels, etc.; next we will learn how to open and close other activity; Open the application activity For example, now we need to open the activity corresponding to sub.ftu. According to the previous analysis of the start activity, we can know that the activity object corresponding to the UI resource is subActivity. These are the codes automatically generated by the tool for us. We don't need to pay attention to too many details, just understand it briefly. Then we can start the activity with the following code: EASYUICONTEXT->openActivity(\"subActivity\"); If we want to jump to the sub.ftu activity through a button click, we can call the above statement in the callback function of the button click event: static bool onButtonClick_Button1(ZKButton *pButton) { // Jump to the sub.ftu activity EASYUICONTEXT->openActivity(\"subActivity\"); return false; } Under normal circumstances, the above calling code is sufficient. If some information needs to be passed between the activity and the activity, such as the payment page, we need to use the second parameter of openActivity to pass parameters : Intent *pIntent = new Intent(); pIntent->putExtra(\"cmd\", \"open\"); pIntent->putExtra(\"value\", \"ok\"); EASYUICONTEXT->openActivity(\"subActivity\", pIntent); In this way, it can be received in the onUI_intent callback of subLogic.cc : static void onUI_intent(const Intent *intentPtr) { if (intentPtr) { // Key value analysis std::string cmd = intentPtr->getExtra(\"cmd\"); // \"open\" std::string value = intentPtr->getExtra(\"value\"); // \"ok\" ...... } } Note： 1. The new Intent does not need to be manually deleted, it is automatically deleted within the framework. 2. putExtra only provides the key-value pair method of string. If you need to pass int or other types of values, you need to convert to string type, and then do the corresponding conversion after receiving it in onIntent Close the application activity Through the openActivity function above, we opened the subActivity. At this time, we want to go back to the original activity. What should we do? We can return to the previous activity through the following code: EASYUICONTEXT->goBack(); If the return is triggered by a button, we can directly use the tool to set the button ID value to sys_back, and the system will respond to the return function; If we enter a more hierarchical activity and want to directly go back to our first startup interface, we can implement it with the following code : EASYUICONTEXT->goHome(); It returns to the main activity. In addition, if it is also triggered by a button, we can also use the tool to set the button's ID value to sys_home, and the system will also respond to the function of returning to the main activity; Finally, we can also close the activity through the closeActivity function of EasyUIContext, for example, we want to close the subActivity : EASYUICONTEXT->closeActivity(\"subActivity\"); This function requires the caller to know the name of the activity to be closed; in addition, this method cannot close the startup activity, which is always present. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"activity_life_cycle.html":{"url":"activity_life_cycle.html","title":"Activity life cycle","keywords":"","body":"Activity life cycle Before introducing the activity life cycle, let's first understand the hierarchical relationship of the activity First of all, our application will first enter the mainActivity, which is the startup activity, and then open the subActivity through the openActivity method, and then enter the thirdActivity . The hierarchical effect seen in the above figure is formed; the activity opened later is at the upper level of the hierarchy, and a relationship of stack is formed between them; Activity flow when opening Let's take a look at the process of the program after calling the openActivity method. Here are two scenarios: There is no activity to be opened in the activity stack; Let's take a look at the onUI_init function in subLogic.cc. Only when the activity does not exist in the activity stack, this function will be used when it is opened for the first time. Going here means that all the control pointers are initialized. In this function we can start to perform some operations on them, as follows: static void onUI_init() { //Tips :Add the display code of UI initialization here, such as:mTextView1Ptr->setText(\"123\"); LOGD(\"sub onUI_init\\n\"); mTextView1Ptr->setText(\"123\"); } Data is transferred when the interface is opened and it is received and processed in the onUI_intent callback function: static void onUI_intent(const Intent *intentPtr) { LOGD(\"sub onUI_intent\\n\"); // Judge not empty if (intentPtr) { // Key value analysis std::string cmd = intentPtr->getExtra(\"cmd\"); // \"open\" std::string value = intentPtr->getExtra(\"value\"); // \"ok\" ...... } } onUI_show function - Activity display completion callback; There is the activity to be opened in the activity stack In this case, only the corresponding activity in the activity stack is moved to the top level, and the onUI_init process is not followed; Opening an activity to display means that the previous top-level interface is hidden; assuming that the subActivity is opened in the mainActivity , their activity flow is as follows: Here we focus on the mainActivity hide ------> subActivity display process; Activity flow when closing When we call the goBack() function, the top-level activity will pop up until the activity is started; When the activity is closed, the onUI_quit callback function will be called. If some resources are requested after the activity is opened, remember to release it here; After exiting the top-level activity, the next-level activity will be displayed and will call the onUI_show function of the next-level activity;When we call the goHome() function, we will directly go back to the startup activity and pop up all other activity; When we call the closeActivity(\"xxx\") function, we can remove any activity except the startup activity; when the activity is not the top-level activity, the next-level activity will not call onUI_show function; powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"internal_app.html":{"url":"internal_app.html","title":"System built-in activity","keywords":"","body":"In addition to the activity customized by the developer, our system also has several commonly used activity built in, such as the activity that appears when the card is upgraded, which is one of the built-in activity ; In addition, there is a system setting activity, open method : EASYUICONTEXT->openActivity(\"ZKSettingActivity\"); We can click on a button to jump to this activity to see the effect (the effects of several other built-in interfaces can be viewed in the following ways) : static bool onButtonClick_Button1(ZKButton *pButton) { EASYUICONTEXT->openActivity(\"ZKSettingActivity\"); return false; } After each item is clicked in, there is a new built-in activity, open the network settings : EASYUICONTEXT->openActivity(\"NetSettingActivity\"); Open WIFI settings : EASYUICONTEXT->openActivity(\"WifiSettingActivity\"); If the target machine supports wifi, turn on the switch in the upper right corner, the searched wifi information will be displayed on the activity; Open the hotspot setting activity: EASYUICONTEXT->openActivity(\"SoftApSettingActivity\"); Back to the system setting activity just now, we click to open the language setting activity: EASYUICONTEXT->openActivity(\"LanguageSettingActivity\"); Touch calibration interface: EASYUICONTEXT->openActivity(\"TouchCalibrationActivity\"); Developer options activity : EASYUICONTEXT->openActivity(\"DeveloperSettingActivity\"); Currently there are only ADB debugging switch options. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"system_app.html":{"url":"system_app.html","title":"System application","keywords":"","body":"System activity type The application activity introduced above is classified as a normal window, which is usually enough. When creating a new UI activity through the tool, the default window type is normal window： If some scenes require a display area floating above the UI interface, then ordinary windows will not be able to do the job, and we need to use several other types of windows. In the UI type options, there are three special types of window options, these three special types have special file names, corresponding to statusbar.ftu navibar.ftu screensaver.ftu After clicking Finish, the tool will automatically generate the corresponding code for us; the operations of these three types of windows are the same as those of ordinary windows; Status bar Explanation: This status bar has the same concept as the status bar of Android and iOS phones. It is a general display area floating above the UI interface. Usually used to display some common information, or to place the return button or home button, etc. The following effects: The system provides two interfaces that can be used to operate the status bar: Show status bar： EASYUICONTEXT->showStatusBar(); Hide status bar： EASYUICONTEXT->hideStatusBar(); For the complete source code, please refer to the StatusBarDemo project in Sample Code Package Navigation bar Explanation: This navigation bar has the same concept as the navigation bar of Android phones. It is a general operation or display area floating above the UI interface, generally at the bottom of the page. Usually used to display some operation keys. The navigation bar is actually no different from the status bar. Show navigation bar： EASYUICONTEXT->showNaviBar(); Hide navigation bar： EASYUICONTEXT->hideNaviBar(); Screensaver Explanation: The screensaver means that when the user no longer interacts with the system and the time exceeds a specified length of time then the system automatically opens a page. Right-click the project, select the Properties option, in the pop-up properties box, we can set the screensaver timeout time, the unit is seconds, -1 means not enter the screensaver. We can also make some settings through code, see jni/include/entry/EasyUIContext.h : Required header file #include \"entry/EasyUIContext.h\" Set screensaver timeout time //Set the screensaver timeout time to 5 seconds EASYUICONTEXT->setScreensaverTimeOut(5); Set whether to allow screensaver EASYUICONTEXT->setScreensaverEnable(false); //Turn off screensaver detection EASYUICONTEXT->setScreensaverEnable(true); //Turn on screensaver detection Application scenario: If the upgrade interface cannot enter the screensaver mode, you can turn off the screensaver detection in the upgrade application EASYUICONTEXT->setScreensaverEnable(false). Enter the screensaver EASYUICONTEXT->screensaverOn(); Exit the screensaver EASYUICONTEXT->screensaverOff(); Determine whether to enter the screensaver EASYUICONTEXT->isScreensaverOn(); The complete source code can be found in the ScreensaverDemo project in Sample Code Package powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"timer.html":{"url":"timer.html","title":"Timer","keywords":"","body":"Timer In some cases, we may need to do some operations regularly. For example, send heartbeat packets at regular intervals, regularly query data to refresh the UI interface, or do some polling tasks. If you have these requirements, then the timer is a good choice. How to use the timer Register timer For ease of use, we add a timer in the form of a filled structure. In the Logic.cc file, there will be such a structure array by default : /** * Register timer * Just add to this array */ static S_ACTIVITY_TIMEER REGISTER_ACTIVITY_TIMER_TAB[] = { //{0, 6000}, //Timer id=0, Period 6second //{1, 1000}, }; If we want to add a timer, we only add a structure to this array. The definition of this structure is as follows: typedef struct { int id; // Timer ID, can not redefine int time; // Timer period unit/ms }S_ACTIVITY_TIMEER; Add timer logic codeAfter registering the timer in the array, when a timer is triggered, the system will call the void onUI_Timer(int id) function in the corresponding Logic.cc file. All operation codes for this timer are Added to this function, the function is specifically defined as follows: /** * Timer trigger function * It is not recommended to write time-consuming operations in this function, otherwise it will affect UI refresh * @param id * The id of the currently triggered timer is the same as the id at registration * @return true * Keep running the current timer * false * Stop running the current timer */ static bool onUI_Timer(int id){ switch (id) { default: break; } return true; } This function is also generated by default with the Logic.cc file.Note that the parameter id of the function is the same as the id value defined in the structure array. We can determine which timer is currently triggered based on the id value, so as to make some targeted operations. [!Note] Note: The timers of each activity are independent, and the id of the timers of different activity can be the same;The registered timer, as long as the activity is not destroyed (see Activity life Cycle), it will always run;No need to stop manually after registration, it will stop automatically when the activity is destroyed. Sample Next, we will describe the use of timers with a specific example.Suppose we need to implement such a function: There is an integer variable, every second, the variable is accumulated by 1, and the latest result is displayed on the screen.The implementation process is as follows: First, we add a text control to the UI file to display the accumulated result. Register the timer, add a structure to the timer array of mainLogic.cc, the timer id is 1, and the time interval is 1 second. Note that the time unit is milliseconds. In timerTestLogic.cc, define a static integer variable and initialize it to 0 In the void onUI_Timer(int id) function, add the accumulation code and display it in the text control. Compile and run Sample code See the TimerDemo project in Sample Code powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"how_to_register_timer.html":{"url":"how_to_register_timer.html","title":"Manually start/stop the timer ","keywords":"","body":"How to start and stop the timer arbitrarily We can add a preset timer in REGISTER_ACTIVITY_TIMER_TAB, but this method is not flexible enough to start/stop arbitrarily. Here is another way to add a timer. There are three methods about timers in the Activity class. The following describes how to use them. /** * Register timer */ void registerUserTimer(int id, int time); /** * Un-register timer */ void unregisterUserTimer(int id); /** * Reset timer */ void resetUserTimer(int id, int time); In logic.cc, add a variable to identify whether the timer has been registered. /** * Whether the timer is registered */ static bool isRegistered = false; #define TIMER_HANDLE 2 Let's add two more buttons. In the click event of the button, we add codes to register and un-registerthe timer respectively. static bool onButtonClick_ButtonTimerOn(ZKButton *pButton) { //Register the timer if not registered if (!isRegistered) { mActivityPtr->registerUserTimer(TIMER_HANDLE, 500); isRegistered = true; } return false; } static bool onButtonClick_ButtonTimerOff(ZKButton *pButton) { //If the timer is already registered, cancel the registration if (isRegistered) { mActivityPtr->unregisterUserTimer(TIMER_HANDLE); isRegistered = false; } return false; } [!Warning] The above-mentioned three functions registerUserTimer, unregisterUserTimer, and resetUserTimer cannot be called in the onUI_Timer function, which will cause deadlock. Sample code Refer to the TimerDemo project in Sample Code.Preview the relevant picture : powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"linux_serial_programming.html":{"url":"linux_serial_programming.html","title":"Linux serial programming","keywords":"","body":"Linux serial programming [!Note] The purpose of this document is to let everyone understand how the code of the serial port part of the FlywizOS project went from zero to something. It is easier to understand the code flow of the serial port part we finally provide.After understanding, you can modify the source code according to your needs. This product is based on the Linux system, so we can completely use standard Linux programming to operate the serial port. The basic steps We divide Linux serial port programming into the following 5 steps: open serial port, configure serial port, read serial port, write serial port, close serial port. Open serial port #include int fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY); open is a system function, responsible for opening a node The above code means: try to open the /dev/ttyS0 serial port in a readable and writable manner. If it is opened successfully, it returns a non-negative value, which represents the serial port descriptor. If it fails, it returns a negative number, which is an error code. . /dev/ttyS0 It can be understood as a serial port number, similar to COM1 on Windows systems. Configure serial portAfter successfully opening the serial port, you need to configure the serial port and set the baud rate and other parameters. int openUart() { int fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY); struct termios oldtio = { 0 }; struct termios newtio = { 0 }; tcgetattr(fd, &oldtio); //Set the baud rate to 115200 newtio.c_cflag = B115200 | CS8 | CLOCAL | CREAD; newtio.c_iflag = 0; // IGNPAR | ICRNL newtio.c_oflag = 0; newtio.c_lflag = 0; // ICANON newtio.c_cc[VTIME] = 0; newtio.c_cc[VMIN] = 1; tcflush(fd, TCIOFLUSH); tcsetattr(fd, TCSANOW, &newtio); //Set to non-blocking mode, this will be used when reading the serial port fcntl(fd, F_SETFL, O_NONBLOCK); return fd; } [!Note] The above is the default serial port configuration of this platform, with 8 data bits, 1 stop bit, and no check. Do not modify for non-special needs.Limited by hardware and drivers, if you modify it to other configurations, it may be invalid. Read serial port #include unsigned char buffer[1024] = {0}; int ret = read(fd, buffer, sizeof(buffer)); read is a system function, which provides the function of reading the serial port. This function requires three parameters: The first parameter is the serial port descriptor, which is the return value of the open function in the step of opening the serial port. The second parameter is the buffer pointer, which is used to save the read serial data. The third parameter is the length of the buffer, which also indicates the maximum number of bytes that can be read this time. Call the function,If the return value is greater than 0, it means that the serial port data has been received correctly, and the return value is equal to the number of bytes of data read.If the return value is less than or equal to 0, it means there is an error or no data is read temporarily. Write serial port #include unsigned char buffer[4] = {0}; buffer[0] = 0x01; buffer[1] = 0x02; buffer[2] = 0x03; buffer[3] = 0x04; int ret = write(fd, buffer, sizeof(buffer)); write is a system function, which provides the function of sending serial port. This function requires three parameters : The first parameter is the serial port descriptor, which is the return value of the open function in the step of opening the serial port. The second parameter is the pointer to the buffer to be sent. The third parameter is the length of the buffer to be sent Call the function, If the return value is greater than 0, and the return value is equal to the third parameter passed, it means the transmission was successful.If the return value is less than or equal to 0, it means an exception. [!Note] The read function only reads the data stream received by the serial port sequentially, but it cannot guarantee that the complete data will be read once.For example, in a short time, the serial port receives 1000 bytes of data, and the length of the buffer is 1024, although 1024> 1000,but maybe we only read part of the data after the first read, so we need to read multiple times to ensure that the data is read completely. Close serial port#include close(fd); close is a system function, and the required parameter is the serial port descriptor, that is, the return value of the open function in the step of opening the serial port. Comprehensive use The following is a complete example of a simple Linux serial port programming. The basic steps mentioned above are all used. #include #include #include int main(int argc, char** argv) { int fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY); if (fd 0) { //Output the read data to the log in turn for (int i = 0; i How to ensure stable communication of serial port from software When we try to apply the above examples to official products, we will inevitably encounter these problems: Serial communication may be disturbed to some extent, and it is unreliable. Therefore, a communication protocol is usually formulated. This protocol generally includes frame header, frame end, frame content, checkout, etc. The use of the protocol can ensure the integrity of the data to the greatest extent, making the serial port communication reliable. For example:If we define the protocol, it starts with 0xFF and 0x55, followed by 8 valid bytes for a complete frame.Then the code of the Linux serial communication example above will probably be modified to look like this : //Only the key parts are listed, the rest of the code is omitted while (true) { unsigned char buffer[1024] = {0}; int ret = read(fd, buffer, sizeof(buffer)); if (ret > 0) { if ((buffer[0] == 0xFF) && (buffer[1] == 0x55)) { if (ret == 10) { LOGD(\"Read a frame of data correctly\"); } else if (ret When we use the above code for actual testing and frequent sending and receiving, it is very likely that the protocol header is correct, but the frame length is wrong. why? Because of Linux system scheduling or other reasons, the read function cannot guarantee that all data received by the serial port will be returned to you at one time. In order to read the serial port data completely, you need to call the read function multiple times, then splice the received data before and after, and then verify the data according to the protocol to find a valid frame. Although the code becomes complicated to do so, it is reasonable. Based on the analysis just now, modify the example code to look like this : //Increase the scope of the buffer array so that the data will not be cleared in the while loop unsigned char buffer[1024] = {0}; // Add a `legacy` variable to indicate the length of data left in the buffer int legacy = 0; while (true) { //According to the size of the legacy, adjust the start pointer and size of the buffer to prevent data overwriting int ret = read(fd, buffer + legacy, sizeof(buffer) - legacy); if (ret > 0) { if ((buffer[0] == 0xFF) && (buffer[1] == 0x55)) { if ((ret + legacy) == 10) { LOGD(\"Read a frame of data correctly\"); //clean legacy legacy = 0; } else if (ret In actual applications, we not only have to deal with serial communication, but also respond to the various buttons on the screen. In the above example, it starts with the main function, followed by a while loop, and then processes the serial port messages all the time, and cannot do other things. The Linux system supports multithreading. Usually, we will create a new child thread, and then put this while loop part in the child thread for processing, so that we will not delay our other operations. How to modify, the code is not given here. Summary In view of the serial communication programming on Linux, many detailed problems need to be dealt with, FlywizOS provides a general code, which solves the following problems : Open, close, read and write operations of serial port Splicing of protocol Provide a unified data callback interface The source code of this part is completely open source, you can create a new FlywizOS project at will, the source code is in the uart folder of the project. If you compare the source code of the UartContext class, you should be able to see the shadow of this document. I hope that through this document, you can be familiar with the serial communication part of the FlywizOS project. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"serial_introdoction.html":{"url":"serial_introdoction.html","title":"Introduction","keywords":"","body":"Introduction to the serial port The picture below is the simplest communication model. The screen and MCU communicate through the serial port, as long as the protocol is established between them, they can interact. Note - The traditional serial screens are used as slave devices and control them by sending corresponding instructions through the MCU. Our serial screens are different. Our screens are logical, and It can realize the interaction by itself, here as the host side. If you develop this part of the communication code from beginning, the workload will be huge. In order to simplify the development process and enable developers to pay more attention to the development of business logic, our tool will automatically generate the serial communication code when building a new project. At the same time, we also provide a callback interface for protocol data and activity interaction: Developers pay more attention to the display of data on the UI interface, while the communication part is automatically completed by our framework. The protocol analysis part of the communication framework needs to be changed according to the communication protocol used by the developer. In the next chapter of Communication Framework Explanation, we will focus on the principle and the parts that need to be modified, and deepen our understanding of this communication framework through some cases in this chapter of Communication Case Practice. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"serial_framework.html":{"url":"serial_framework.html","title":"Communication frame explanation","keywords":"","body":"Communication framework explanation This chapter focuses on the implementation principle of the communication framework. There are many theoretical things. The first time you can give a rough overview of the communication model, you will probably know the communication model. The supporting case do it yourself. it, and then come back. After understanding the principles, reviewing a few times and getting used to them, you can customize the protocol any way you want. Frame The software APP part is divided into two layers Uart -Serial port HAL layer for protocol analysis and encapsulation UartContext：The physical control layer of the serial port, providing the serial port switch, sending and receiving interfaces ProtocolData：Define the communication data structure, used to save the actual variables converted from the communication protocol ProtocolSender：Complete the encapsulation of data transmission. ProtocolParser：Complete the protocol analysis part of the data. Then put the parsed data into the data structure of ProtocolData. At the same time, it manages the callback interface for the application to monitor the serial data changes. APP - application interface layer Through the interface provided by ProtocolParser. Register the serial port data receiving monitor to obtain the updated ProtocolData from the serial port. Through the interface provided by ProtocolSender. Send command information to MCU. Let's refine this process : You can clearly see that the receive and send two processes are up and down, and the functions of each layer are relatively clear; Specific to the process corresponding to the code : Regardless of whether it is a receiving or sending process, it is ultimately necessary to read and write to the serial port through the UartContext. This is a standardized process, so we basically do not need to modify the UartContext, and we can ignore how it is implemented. Yes, of course, you can check it out if you are interested. At this point, we have a general understanding of this communication model, and then we will look at the implementation of the specific code. How to use and modify the protocol receiving part Modification of communication protocol format Here we give an example of a more common communication protocol frame header(2bytes) command(2bytes) length of data(1byte) command data(N) verification(1byte, option) 0xFF55 Cmd len data checksum The CommDef.h file defines synchronization frame header information and minimum data packet size information: // When you need to print the protocol data, open the following macro //#define DEBUG_PRO_DATA // Support checksum verification, open the following macro //#define PRO_SUPPORT_CHECK_SUM /* SynchFrame CmdID DataLen Data CheckSum (Option) */ /* 2Byte 2Byte 1Byte N Byte 1Byte */ // Minimum length with CheckSum: 2 + 2 + 1 + 1 = 6 // Minimum length without CheckSum: 2 + 2 + 1 = 5 #ifdef PRO_SUPPORT_CHECK_SUM #define DATA_PACKAGE_MIN_LEN 6 #else #define DATA_PACKAGE_MIN_LEN 5 #endif // Sync frame header #define CMD_HEAD1 0xFF #define CMD_HEAD2 0x55 ProtocolParser.cpp 文件，配置文件命令格式： /** * Function: Analyze protocol * Parameters: pData - protocol data, len - data length * Return value: the length of the actual protocol */ int parseProtocol(const BYTE *pData, UINT len) { UINT remainLen = len; // Remaining data length UINT dataLen; // Packet length UINT frameLen; // Frame length /** * The following parts need to be modified according to the protocol format to parse out the data of each frame */ while (remainLen >= DATA_PACKAGE_MIN_LEN) { // Find the data header of a frame while ((remainLen >= 2) && ((pData[0] != CMD_HEAD1) || (pData[1] != CMD_HEAD2))) { pData++; remainLen--; continue; } if (remainLen remainLen) { // Incomplete data frame break; } // To print a frame of data, open the DEBUG_PRO_DATA macro in the CommDef.h file when needed #ifdef DEBUG_PRO_DATA for (int i = 0; i The above analysis process is a bit complicated, let’s first give a picture, and then analyze it may be easier to understand. A packet of data may contain 0 to multiple frames of data. In the picture below, we have marked 3 frames of data. Another frame of data is incomplete, and there are 5 less data. The incomplete frame of data will be spliced to the next In a packet of data. Protocol header needs to be modified // 1.Modify the definition of the protocol header. If the length of the protocol header changes, pay attention to modifying the // statement of the protocol header judgment part. #define CMD_HEAD1 0xFF #define CMD_HEAD2 0x55 // 2.You need to modify this when the length of the protocol header changes. while ((mDataBufLen >= 2) && ((pData[0] != CMD_HEAD1) || (pData[1] != CMD_HEAD2))) Modification of changes in the position of the protocol length or the length calculation method // Here pData[4] represents the fifth data is the length byte, if it changes, please modify it here. dataLen = pData[4]; // The frame length is generally the data length plus the head and tail length. If the length calculation method passed in the // agreement changes, modify this part. frameLen = dataLen + DATA_PACKAGE_MIN_LEN; When the verification changes /** * By default, we turn off checksum verification. If you need to support checksum verification, open the PRO_SUPPORT_CHECK_SUM * macro in the CommDef.h file * When the verification is different, the verification method needs to be modified. * 1.Check the content changes to modify this location * if (getCheckSum(pData, frameLen - 1) == pData[frameLen - 1]) * 2.Check the calculation formula changes to modify the content in the getCheckSum function */ /** * Get checksum code */ BYTE getCheckSum(const BYTE *pData, int len) { int sum = 0; for (int i = 0; i When the reception of a frame of data is completed, the program will call procParse to analyze // Support checksum verification, open PRO_SUPPORT_CHECK_SUM macro in CommDef.h file when needed #ifdef PRO_SUPPORT_CHECK_SUM // Get checksum code if (getCheckSum(pData, frameLen - 1) == pData[frameLen - 1]) { // Parse a frame of data procParse(pData, frameLen); } else { LOGE(\"CheckSum error!!!!!!\\n\"); } #else // Parse a frame of data procParse(pData, frameLen); #endif How to connect communication protocol data with UI controls Continue the previous protocol framework. We enter the parsing part of procParse. The key code here is : ProtocolParser.cpp Open the file and find void procParse(const BYTE *pData, UINT len) /* * Protocol analysis * Input parameters : * pData: Start address of a frame of data * len: Length of frame data */ void procParse(const BYTE *pData, UINT len) { /* * Parse the Cmd value to obtain the data and assign it to the sProtocolData structure */ switch (MAKEWORD(pData[2], pData[3])) { case CMDID_POWER: sProtocolData.power = pData[5]; LOGD(\"power status:%d\",sProtocolData.power); break; } notifyProtocolDataUpdate(sProtocolData); } The above MAKEWORD(pData[2], pData[3]) represents the Cmd value in our protocol example; When the data analysis is completed, the UI update is notified by notifyProtocolDataUpdate. For this part, please refer to the UI update part below Data structure The above protocol is parsed into the sProtocolData structure. sProtocolData is a static variable used to save the data value sent by the MCU (or other device) serial port. This data structure is in the ProtocolData.h file. Here you can add communication variables that need to be used in the entire project. typedef struct { // You can add protocol data variables here BYTE power; } SProtocolData; UI update The UI interface has completed the registerProtocolDataUpdateListener when the tool generates Activity.cpp, which means that the page program in the logic will receive the data when the data is updated. static void onProtocolDataUpdate(const SProtocolData &data) { // Serial data callback interface if (mProtocolData.power != data.power) { mProtocolData.power = data.power; } if (mProtocolData.eRunMode != data.eRunMode) { mProtocolData.eRunMode = data.eRunMode; mbtn_autoPtr->setSelected(mProtocolData.eRunMode == E_RUN_MODE_MANUAL); if (mProtocolData.eRunMode != E_RUN_MODE_MANUAL) { mbtn_external_windPtr->setText(mProtocolData.externalWindSpeedLevel); mbtn_internal_windPtr->setText(mProtocolData.internalWindSpeedLevel); } } ... } In the code, we can see a variable mProtocolData, which is a static variable in the page. It will be initialized during onUI_init(). Example : static SProtocolData mProtocolData; static void onUI_init() { //Tips :Add the display code for UI initialization here, example : mText1->setText(\"123\"); mProtocolData = getProtocolData(); // Initialize the structure of the serial port data. //Start the UI display of the initial page } Serial data sending Open ProtocolSender.cpp When the APP layer needs to send data to the MCU (or other devices), it is enough to directly call sendProtocol. The specific protocol encapsulation is completed by the sendProtocol method. Users can modify this part of the code according to their own protocol requirements. /** * Need to be spliced according to the protocol format, the following is just a template */ bool sendProtocol(const UINT16 cmdID, const BYTE *pData, BYTE len) { BYTE dataBuf[256]; dataBuf[0] = CMD_HEAD1; dataBuf[1] = CMD_HEAD2; // Sync header dataBuf[2] = HIBYTE(cmdID); dataBuf[3] = LOBYTE(cmdID); // Command ID dataBuf[4] = len; UINT frameLen = 5; // Data for (int i = 0; i send(dataBuf, frameLen); } You can operate when a button is pressed on the interface: BYTE mode[] = { 0x01, 0x02, 0x03, 0x04 }; sendProtocol(0x01, mode, 4); powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"serial_example.html":{"url":"serial_example.html","title":"Communication case practice","keywords":"","body":"Communication Case Practice Through the previous chapter Communication Framework Explanation, what may be seen is also in the cloud. Here we first summarize, serial communication mainly has the following 4 points: Receive data Parse data Display data Send data The parse data part is more complicated and needs to be changed according to the specific communication protocol; in this chapter, we will not talk about the theoretical things, and give some practical cases. You can play it a few times. . Case 1 Here we still take the previous communication protocol as an example to implement a simple communication program of our own;For the complete code, see the UartDemo project in Sample Code;The final effect we want to implement is to send instructions through the serial port to control the rotation of the meter pointer on the display. The UI rendering is as follows: We only need to modify 3 places to control the rotation of the instrument pointer; 1) Revisit the protocol format introduced earlier, here we add our own protocol command CMDID_ANGLE corresponding to the value 0x0001 : Protocol header(2bytes) Command(2bytes) length of data(1byte) data(N) checksum(1byte option) 0xFF55 0x0001（See belowCMDID_ANGLE） 1 angle checksum We add 1 variable to the protocol data structure, see ProtocolData.h: /******************** CmdID ***********************/ #define CMDID_POWER 0x0 #define CMDID_ANGLE 0x1 // new command ID /**************************************************/ typedef struct { BYTE power; BYTE angle; // Added variable to save pointer angle value } SProtocolData; 2) Since we are still using the previously defined protocol format, we do not need to make any changes to the protocol parsing part here, just process the corresponding CmdID value in procParse: /** * Parse each frame of data */ static void procParse(const BYTE *pData, UINT len) { // CmdID switch (MAKEWORD(pData[3], pData[2])) { case CMDID_POWER: sProtocolData.power = pData[5]; break; case CMDID_ANGLE: // New part, save angle value sProtocolData.angle = pData[5]; break; } // Notify protocol data update notifyProtocolDataUpdate(sProtocolData); } 3) Let's look at the callback function of the activity receiving protocol data, see logic/mainLogic.cc : static void onProtocolDataUpdate(const SProtocolData &data) { // Serial data callback function // Set the rotation angle of the pointer mPointer1Ptr->setTargetAngle(data.angle); } After completing the above process, we only need to send the corresponding instructions to the screen through the MCU to see the rotation of the indicator pointer; for simplicity, we do not use checksum verification in this program, and the protocol data is as follows : protocol header CmdID length of data angle data 0xFF 0x55 0x00 0x01 0x01 angle We can open the DEBUG_PRO_DATA macro in the CommDef.h file to print the received protocol data: At this point, receive data of the serial port ---> parse data ---> display data, even if it is finished; Finally, let's simulate the serial port send data. Here, in the program we give, a timer is started, and a data transmission is simulated every 2s: static bool onUI_Timer(int id) { // Simulate sending serial data BYTE data = rand() % 200; sendProtocol(CMDID_ANGLE, &data, 1); return true; } The above code is actually an analog setting of the angle value. We can realize spontaneous transmission and self-reception by short-circuiting the TX and RX of the communication serial port on the screen, and we can also see that the indicator pointer rotates; The introduction of our serial port demo program is over. Developers can compile and burn the demo program to the machine to see the effect, and then add some protocols on this basis to familiarize themselves with the entire communication process. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"serial_configuration.html":{"url":"serial_configuration.html","title":"Serial port configuration","keywords":"","body":"How to configure the serial port Selection of serial port number Due to the design compatibility of software and hardware, the serial number of the software may be different from the serial number identification on the hardware. The specific correspondence is as follows : FW-11s Series platform Software serial port number Hardware serial port number ttyS0 UART1 ttyS1 UART2 FW-6 Series platform Software serial port number Hardware serial port number ttyS0 UART0 ttyS1 UART1 ttyS2 UART2 Serial port baud rate configuration Configure the baud rate when creating a new project Project properties to modify the baud rate Right-click the project, select the Properties in the pop-up box, and the following properties box will pop up Serial port open and close Open the source \"jni/Main.cpp\"; we can see that the serial port is opened and closed when the program is initialized and destroyed. void onEasyUIInit(EasyUIContext *pContext) { LOGD(\"onInit\\n\"); // open serial port UARTCONTEXT->openUart(CONFIGMANAGER->getUartName().c_str(), CONFIGMANAGER->getUartBaudRate()); } void onEasyUIDeinit(EasyUIContext *pContext) { LOGD(\"onDestroy\\n\"); // close serial port UARTCONTEXT->closeUart(); } powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"multiuart.html":{"url":"multiuart.html","title":"Multiple serial port configuration","keywords":"","body":"Multiple serial port configuration Conventional projects only support one serial port by default. If you want to use dual serial ports or even multiple serial ports, please download DoubleUartDemo sample. In this example, part of the serial port code is modified in the conventional project to support multiple serial ports. Change The changes are described below. Some codes of uart have been modified, so the serial port configuration in the project properties is invalid. Please refer to the init() function in the jni/uart/UartContext.cpp file to modify the serial port number and baud rate. void UartContext::init() { uart0 = new UartContext(UART_TTYS0); uart0->openUart(\"/dev/ttyS0\", B9600); uart1 = new UartContext(UART_TTYS1); uart1->openUart(\"/dev/ttyS1\", B9600); } Send data to the designated serial port unsigned char buf[2] = {1, 1}; sendProtocolTo(UART_TTYS1, 1, buf, 2); //Send to TTYS1 serial port unsigned char buf[2] = {0}; sendProtocolTo(UART_TTYS0, 1, buf, 2);//Send to TTYS0 serial port The method of receiving serial port data is the same as that of regular projectsIf you need to distinguish which serial port the data comes from, it is recommended to add a field to the SProtocolData structure to identify which serial port the frame comes from. Change uart/ProtocolData.h typedef struct { BYTE power; int uart_from; //From which serial port } SProtocolData; Change uart/ProtocolParser.cpp /** * Analyze each frame of data */ static void procParse(int uart, const BYTE *pData, UINT len) { // CmdID switch (MAKEWORD(pData[3], pData[2])) { case CMDID_POWER: sProtocolData.power = pData[5]; break; } sProtocolData.uart_from = uart; //Identify which serial port the frame comes from // Notify protocol data update notifyProtocolDataUpdate(sProtocolData); } Then in Logic.cc, you can use the uart_from field to determine which serial port the data comes from. static void onProtocolDataUpdate(const SProtocolData &data) { LOGD(\"onProtocol %d\", data.uart_from); char buf[128] = {0}; snprintf(buf, sizeof(buf), \"Receive serial port %d data\", data.uart_from); mTextview1Ptr->setText(buf); } Sample code For the complete code, see the DoubleUartDemo project in Sample Code powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"wifi.html":{"url":"wifi.html","title":"WIFI setting ","keywords":"","body":"Open the wifi setting activity EASYUICONTEXT->openActivity(\"WifiSettingActivity\"); wifi operation function description Get WifiManager object #include \"net/NetManager.h\" WifiManager *pWM = NETMANAGER->getWifiManager(); // You can define a macro to facilitate the following function calls #define WIFIMANAGER NETMANAGER->getWifiManager() Check whether the machine supports wifi WIFIMANAGER->isSupported(); Check if wifi is on WIFIMANAGER->isWifiEnable(); Turn on wifi WIFIMANAGER->enableWifi(true); Scan wifi WIFIMANAGER->startScan(); Connect to wifi WIFIMANAGER->connect(ssid, pw); Disconnect wifi connection WIFIMANAGER->disconnect(); Check if wifi is connected WIFIMANAGER->isConnected(); Get connected wifi information WIFIMANAGER->getConnectionInfo(); Registration and un-registration wifi information monitoring void addWifiListener(IWifiListener *pListener); void removeWifiListener(IWifiListener *pListener); Sample code See the NetDemo project in Sample Code powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"wifi_ap.html":{"url":"wifi_ap.html","title":"Hotspot setting ","keywords":"","body":"Open hotspot setting activity EASYUICONTEXT->openActivity(\"SoftApSettingActivity\"); Hotspot operation interface description Get the SoftApManager object #include \"net/NetManager.h\" SoftApManager *pSAM = NETMANAGER->getSoftApManager(); // You can define a macro to facilitate the following functino calls #define SOFTAPMANAGER NETMANAGER->getSoftApManager() Turn on hotspot SOFTAPMANAGER->setEnable(true); Whether the hotspot is on SOFTAPMANAGER->isEnable(); Get current hotspot state SOFTAPMANAGER->getSoftApState(); // There are the following states E_SOFTAP_DISABLED // Disabled E_SOFTAP_ENABLING // During tunning on E_SOFTAP_ENABLED // Turn on successfully E_SOFTAP_DISABLING // During tunning off E_SOFTAP_ENABLE_ERROR // Turn on failed Modify hotspot name and password SOFTAPMANAGER->setSsidAndPwd(\"zkswe\", \"abcd1234\"); Get hotspot name and password SOFTAPMANAGER->getSsid(); SOFTAPMANAGER->getPwd(); Registration and un-registration hotspot status monitoring void addSoftApStateListener(ISoftApStateListener *pListener); void removeSoftApStateListener(ISoftApStateListener *pListener); powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"audio.html":{"url":"audio.html","title":"Audio playback","keywords":"","body":"Music player Create a ZKMediaPlayer object of type ZKMediaPlayer::E_MEDIA_TYPE_AUDIO static ZKMediaPlayer sPlayer(ZKMediaPlayer::E_MEDIA_TYPE_AUDIO); Register message listener // The message monitoring interface is as follows class PlayerMessageListener : public ZKMediaPlayer::IPlayerMessageListener { public: virtual void onPlayerMessage(ZKMediaPlayer *pMediaPlayer, int msg, void *pMsgData) { switch (msg) { case ZKMediaPlayer::E_MSGTYPE_ERROR_INVALID_FILEPATH: case ZKMediaPlayer::E_MSGTYPE_ERROR_MEDIA_ERROR: // Error message break; case ZKMediaPlayer::E_MSGTYPE_PLAY_STARTED: // Start playback message break; case ZKMediaPlayer::E_MSGTYPE_PLAY_COMPLETED: // Stop playback message break; } } }; static PlayerMessageListener sPlayerMessageListener; // Register message monitoring sPlayer.setPlayerMessageListener(&sPlayerMessageListener); Operation interface description sPlayer.play(\"/mnt/extsd/music/test.mp3\"); // Play the file in the specified path sPlayer.pause(); // Pause playback sPlayer.resume(); // Resume playback sPlayer.seekTo(int msec); // Jump to msec time to play, msec unit: ms sPlayer.stop(); // Stop playback sPlayer.isPlaying(); // Is it playing?, return type is bool sPlayer.getDuration(); // Get the total time of current playing music sPlayer.getCurrentPosition(); // Get the current playing time of the currently playing song sPlayer.setVolume(0.5, 0.5); // Set media volume, volume range: 0.0 ~ 1.0 [!Note] The audio file to be played cannot be too short. Too short may cause impossible to playing. For the complete code, see Sample Code MusicDemo project in the sample powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"thread.html":{"url":"thread.html","title":"Thread","keywords":"","body":"Thread The system supports pthread threads. If you understand the pthread interface, you can also use the posix interface to implement threads.In addition, we also provide a wrapper class for pthread. This category includes the following three parts Thread.h：Thread class Mutex.h：Mutex class Condition.h：Condition class Use of threads Include the header file, inherit the Thread class, implement the virtual bool threadLoop() function and choose to implement the readyToRun function as needed. #include class MyThread: public Thread { public: /** * After the thread is created successfully, this function will be called, and some initialization operations can be done * in this function * return true Continue thread * false Exit thread */ virtual bool readyToRun() { LOGD(\"Thread has been created\"); return true; } /** * Thread loop function * * return true Continue thread loop * false Exit thread */ virtual bool threadLoop() { LOGD(\"Thread loop function\"); //Check if there is a request to exit the thread, if so, return false and exit the thread immediately if (exitPending()) { return false; } //Accumulate the count and display it on the screen loop_count += 1; mTextView2Ptr->setText(loop_count); //To observation, add sleep 500ms here usleep(1000 * 500); //Return true, continue the next thread loop return true; } }; Instantiate thread object static MyThread my_thread; Start thread //Call the run function of the thread class to start the thread //The parameter is the thread name, which can be arbitrarily specified. my_thread.run(\"this is thread name\"); Stop thread The Thread class provides two functions for requesting to exit the thread. The difference between synchronous and asynchronous is used as follows void requestExitAndWait() //Request to exit the thread and wait. The function does not return until the thread completely exits my_thread.requestExitAndWait(); void requestExit() //Request to exit the thread, the function returns immediately after sending the request but at this time, it does not mean //that the thread has also exited my_thread.requestExit(); After calling any of the above two functions, in the threadLoop function, we can use the bool exitPending() member function to determine whether there is a request to exit the thread. virtual bool threadLoop() { LOGD(\"Thread loop function\"); //Check if there is a request to exit the thread, if so, return false and exit the thread immediately if (exitPending()) { return false; } return true; } [!Note] Note that the above function just adds a mark requesting to exit the thread, not forcibly terminating the thread.If you have been performing certain operations in the threadLoop function, and the threadLoop function has never been able to end, then the thread will not stop.The correct way is to check the thread exit request in threadLoop, or check a termination condition, and then return false. [!Warning] Do not call the requestExitAndWait and requestExit functions in the threadLoop function, which may cause deadlock. Determine whether the thread is still running if (my_thread.isRunning()) { mTextView4Ptr->setText(\"Now running\"); } else { mTextView4Ptr->setText(\"Already stop\"); } Thread process After explaining the above steps, combined with the flowchart, you should have a deeper understanding. Sample code See Sample Code ThreadDemo project in the control sample powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"mutex.html":{"url":"mutex.html","title":"Mutex","keywords":"","body":"Mutex/lock When threads are introduced into our program, in some cases, other problems will arise, leading to program bugs. In multi-threaded programming, this situation is very common: A thread assigns a value to a variable, and then B thread reads the value.For the convenience of explanation, we translate this situation into the following code.Define a struct Student global variable, and define two threads, A thread is responsible for assigning values to the student variable;The B thread makes a copy of the student variable, reads out the various members of the variable, and displays it on the log.Question : If two threads are started at the same time, what will be the result of the log of thread B? #include struct Student { char name[24]; int age; int number; }; struct Student student = {0}; class AThread: public Thread { public: virtual bool threadLoop() { snprintf(student.name, sizeof(student.name), \"David\"); student.age = 10; student.number = 20200101; return true; } }; class BThread: public Thread { public: virtual bool threadLoop() { struct Student s = student; LOGD(\"name : %s\", s.name); LOGD(\"age : %d\", s.age); LOGD(\"student id number : %d\", s.number); return true; } }; static AThread athread; static BThread bthread; First of all, the result we want is the output in the log name：David age：10 student id number：20200101 In fact, if the number of tests is large enough, most of the output may be the same as we expect, and the following results may be output : name： age：0 student id number：0 name：xiaoming age：0 student id number：0 name：xiaoming age：10 student id number：0 If there is an \"abnormal\" result in the program, it must be regarded as a bug. Analyze the reasons When there are multiple threads in the program, the thread execution order is flexibly scheduled by the system. It may happen that thread A executes a part of the instructions, then transfers to the B thread to execute some instructions, and then transfers to the A thread to execute the instructions. For the above example, there are three statements in the A thread to complete the complete assignment of the student variable. When only the first statement is executed, only the assignment of the name is completed, and the system switches to B thread, Then in the B thread, reading the student variable at this time, it will appear that the name field is valid, and the age and number are 0. Other abnormal results are the same. How to solve By reason, as long as we ensure that all assignment operations of student in thread A are completed, thread B will read student variables, then there is no problem. How to implement In programming, there is a mutual exclusion lock concept to ensure the integrity of shared data operations. Each object corresponds to a tag that can be called a \"mutual exclusion lock\", which is used to ensure that at any one time, only one thread can access the object. If you are familiar with Linux programming, you can use standard implementation. Here we introduce the use of our encapsulated mutex class. Define a mutex static Mutex mutex1; Where locking is required, define a local Mutex::Autolock class instance to lock. // This class utilizes the life cycle of local variables and the structure and destructor of C++ classes to automatically // implement locking and unlocking operations. Mutex::Autolock _l(mutex1); Combining the above A and B thread examples, the modified code is as follows : #include struct Student { char name[24]; int age; int number; }; struct Student student = {0}; //Define a mutex static Mutex mutext1; class AThread: public Thread { public: virtual bool threadLoop() { //Lock the statement of the function, and automatically unlock after the function ends Mutex::Autolock _lock(mutext1); snprintf(student.name, sizeof(student.name), \"David\"); student.age = 10; student.number = 20200101; return true; } }; class BThread: public Thread { public: virtual bool threadLoop() { //Lock the statement of the function, and automatically unlock after the function ends Mutex::Autolock _lock(mutext1); struct Student s = student; LOGD(\"nanme：%s\", s.name); LOGD(\"age：%d\", s.age); LOGD(\"student id number：%d\", s.number); return true; } }; static AThread athread; static BThread bthread; In the code, we lock the operations related to student in threads A and B.When the A thread is executed, the Mutex::Autolock _lock(mutext1); statement will obtain the mutex1mutex. When the A thread is not unlocked and the B thread is executed, the Mutex::Autolock _lock(mutext1); statement in the B thread, it also wants to obtain the mutext1 mutex. However, this mutex has been obtained by the A thread first. Now if the B thread wants to obtain it, it can only wait until the A thread releases mutext1, then the B thread can normally obtain the mutext1 mutex, and then continue to execute the next Statement. In our project, there is also an example of using mutex, see the source code jni/uart/ProtocolParser.cpp : void registerProtocolDataUpdateListener(OnProtocolDataUpdateFun pListener) { Mutex::Autolock _l(sLock); LOGD(\"registerProtocolDataUpdateListener\\n\"); if (pListener != NULL) { sProtocolDataUpdateListenerList.push_back(pListener); } } If you don’t understand the concept of mutex enough, you can get more information about mutexes from the Internet. powered by Gitbooklast modified: 2020-12-14 10:57:14 "},"screenshot.html":{"url":"screenshot.html","title":"Screenshot","keywords":"","body":"Screenshot After the product is developed, when writing the manual, you may need a screenshot of the running interface. You can refer to the following code screenshot. Ready Download the screenshot.h source file and save it to the project jni directory. Use Required header file#include \"screenshot.h\" Call the interface to take a screenshot static bool onButtonClick_Button1(ZKButton *pButton) { //Capture the current screen, save it as a bmp picture, and save it to the TF card directory //Each time this function is called, the name of the saved picture is incremented //Example - screenshot01.bmp、screenshot02.bmp、screenshot03.bmp Screenshot::AutoSave(); return false; } The default picture is saved to the TF card, so try to plug in the TF card and take a screenshot.If you need to save it to another location, you can modify the source code yourself. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"data.html":{"url":"data.html","title":"data storage","keywords":"","body":"Data storage In some application scenarios, it is necessary to permanently store some information (save data after power off), such as account numbers, passwords, or other configuration information. The characteristics of these data are : the total amount is small, but it needs flexible access. In such cases, there is no need to use a database. We provide a simple data storage interface, which is stored in the form of key-value pairs. Required header files #include \"storage/StoragePreferences.h\" Main function // Storage function static bool putString(const std::string &key, const std::string &val); static bool putInt(const std::string &key, int val); static bool putBool(const std::string &key, bool val); static bool putFloat(const std::string &key, float val); // Delete the specified key static bool remove(const std::string &key); // Clear storage data static bool clear(); // Get function. The corresponding key value cannot be obtained, then the default value of defVal is returned static std::string getString(const std::string &key, const std::string &defVal); static int getInt(const std::string &key, int defVal); static bool getBool(const std::string &key, bool defVal); static float getFloat(const std::string &key, float defVal); [!Warning] This function saves the data in the flash in the form of a file, so do not write frequently to cause damage to the flash. The size of the partition is limited. The size of the partition varies depending on the model of the screen. Try to keep the data size within 512KB. Usage example Save //Save the string, use \"username\" as the alias, the value is the name string const char* name = \"zhang san\"; StoragePreferences::putString(\"username\", name); //Save the boolean variable, alias \"power\", the value is true StoragePreferences::putBool(\"power\", true); //Save a floating point number, aliased to \"temperature\", the value is 30.12 StoragePreferences::putFloat(\"temperature\", 30.12); //Save the integer, use \"age\" as the alias, the value is 20 StoragePreferences::putInt(\"age\", 20); Read //Read the value of the \"username\" key, if there is no value, return an empty string std::string name = StoragePreferences::getString(\"username\", \"\"); //Log print the read string LOGD(\"username %s\\n\", username.c_str()); //Read the Boolean variable, if there is no value, then specify to return false bool power = StoragePreferences::getBool(\"power\", false); //Read floating-point number, if there is no value, specify to return 0 float temperature = StoragePreferences::getFloat(\"temperature\", 0); //Read floating-point number, if there is no value, specify to return 0 int age = StoragePreferences::getInt(\"age\", 18); Delete // Clear a value individually StoragePreferences::remove(\"username\"); StoragePreferences::remove(\"power\"); StoragePreferences::remove(\"temperature\"); StoragePreferences::remove(\"age\"); // Clear all values StoragePreferences::clear(); Modify If you need to modify a value, just save the key value repeatedly, and the old value will be automatically overwritten. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"vireeprom.html":{"url":"vireeprom.html","title":"Emulated EEPROM","keywords":"","body":"Emulate EEPROM function EEPROM (powered erasable programmable read-write memory) is a user-changeable read-only memory (ROM), which can be erased and reprogrammed (rewritten) by a higher voltage than normal. Emulation principle This system is based on Linux, with its own file system and balanced erasing algorithm. Write the saved data to NorFlash (not less than 100,000 erasing times, note that it is not Nandfalsh, NandFlash will be various risks after bad blocks appear). The /data partition is reserved inside FlywizOS for user data. For the convenience of users who are familiar with the operation of the microcontroller, we create a file under the /data partition to emulate an EEPROM space. (The size of the /data partition varies from 1M or several hundred KB, depending on the specific system version) Scenes to be used Save data after power off. Implementation steps First create a header file in the jni directory of the project.Select jni under the project, click the right mouse button, select Header File option in the pop-up context menu, and then name it vireeprom.h, and click Finish. Copy the following code completely into the header file just added. (When the header file was created just now, some content may be automatically added and deleted) These codes realize the emulation function of EEPROM. #ifndef JNI_VIREEPROM_H_ #define JNI_VIREEPROM_H_ #include #include #include /** * The storage size of the emulated EEPROM, in bytes, it is recommended not to be too large */ #define EEPROM_SIZE 1024 /** * Actually saved as a file /data/eeprom.eep */ #define EEPROM_FILE \"/data/eeprom.eep\" class VirEEPROM { public: VirEEPROM() { memset(buff_, 0, sizeof(buff_)); file_ = fopen(EEPROM_FILE, \"rb+\"); if (file_) { fread(buff_, 1, EEPROM_SIZE, file_); fseek(file_, 0, SEEK_END); int f_size = ftell(file_); //Adjust the file to a suitable size if (f_size != sizeof(buff_)) { ftruncate(fileno(file_), sizeof(buff_)); fseek(file_, 0, SEEK_SET); fwrite(buff_, 1, sizeof(buff_), file_); fflush(file_); sync(); } } else { file_ = fopen(EEPROM_FILE, \"wb+\"); //Adjust the file to a suitable size ftruncate(fileno(file_), sizeof(buff_)); } } virtual ~VirEEPROM() { if (file_) { fflush(file_); fclose(file_); sync(); } } /** * Return : less than 0 is failure, greater than 0 is the actual number of bytes written * Parameter: The data pointer that value needs to save, which can be a structure pointer, char*, int*..., size is the * size of the data to be saved * Examples of use: * const char buff[]=\"12345678\"; * VIREEPROM->WriteEEPROM(0,buff,sizeof(buff); */ int Write(int addr, const void* value, int size) { if (file_ == NULL) { return -1; } if ((addr >= EEPROM_SIZE) || ((addr + size) > EEPROM_SIZE)) { //Oversize return -2; } memcpy(buff_ + addr, value, size); if (0 != fseek(file_, addr, SEEK_SET)) { return -3; } int n = fwrite((char*)value, 1, size, file_); fflush(file_); sync(); return n; } /** * Return : less than 0 is a failure, greater than 0 is the number of bytes actually read * Parameter: the data pointer to be read by value, which can be a structure pointer, char*, int*..., size is the size of * the data to be read * Examples of use: * char buff[9]; * VIREEPROM->ReadEEPROM(0,buff,sizeof(buff); */ int Read(int addr,void* value,int size) { if (file_ == NULL) { return -1; } if ((addr >= EEPROM_SIZE) || ((addr + size) > EEPROM_SIZE)) { //Oversize return -2; } memcpy(value, buff_ + addr, size); return size; } /** * Return： * 0 Success * Less than 0 failed */ int Erase() { if (file_ == NULL) { return -1; } if (0 != fseek(file_, 0, SEEK_SET)) { return -2; } memset(buff_, 0, sizeof(buff_)); if (sizeof(buff_) != fwrite(buff_, 1, sizeof(buff_), file_)) { return -3; } fflush(file_); sync(); return 0; } static VirEEPROM* getInstance() { static VirEEPROM singleton; return &singleton; } private: unsigned char buff_[EEPROM_SIZE]; FILE* file_; }; #define VIREEPROM VirEEPROM::getInstance() #endif /* JNI_VIREEPROM_H_ */ So far, the preparation work has been completed, we will write some examples to test whether it is normal.Open the mainLogic.cc source file and quote \"vireeprom.h\" header file at the top of the file. #include \"vireeprom.h\" Test code static void onUI_init(){ //The value array, starting from address 0, is written sequentially char value[4] = {1, 2, 3, 4}; VIREEPROM->Write(0, value, sizeof(value)); //Start reading from address 0, read 4 bytes in sequence, and save the read content in buf char buf[4] = {0}; VIREEPROM->Read(0, buf, sizeof(buf)); //Output log LOGD(\"Data read : %02x, %02x, %02x, %02x\", buf[0], buf[1], buf[2], buf[3]); //Clear all eeprom to 0 VIREEPROM->Erase(); } powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"brightness.html":{"url":"brightness.html","title":"Screen backlight operation","keywords":"","body":"Screen backlight operation Required header files#include \"utils/BrightnessHelper.h\" Dimming Adjust backlight brightness The brightness range is 0 ~ 100 (Note: 0 does not mean turning off the screen) //Adjust the screen brightness to 80 BRIGHTNESSHELPER->setBrightness(80); Get the current brightness valueBRIGHTNESSHELPER->getBrightness(); Switch screen backlight Screen off BRIGHTNESSHELPER->screenOff(); Screen on BRIGHTNESSHELPER->screenOn(); Memory brightness When the system is turned on, the default is to memorize the last adjusted brightness value. If you want to modify it to not remember the brightness or set a fixed brightness value, you can open the properties of the project to modify： powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"system_time.html":{"url":"system_time.html","title":"System time","keywords":"","body":"System time Required header time #include \"utils/TimeHelper.h\" Explanation of each field of tm structure struct tm { int tm_sec; /* second - the value range is [0,59] */ int tm_min; /* minute - the value range is [0,59] */ int tm_hour; /* hour - the value range is [0,23] */ int tm_mday; /* Day of the month - the value range is[1,31] */ int tm_mon; /* Month (starting from January, 0 means January) - the value range is[0,11] */ int tm_year; /* Year, the value starts from 1900 */ ... } Get the current date and time struct tm *t = TimeHelper::getDateTime(); Display time sample code static void updateUI_time() { char timeStr[20]; static bool bflash = false; struct tm *t = TimeHelper::getDateTime(); sprintf(timeStr, \"%02d:%02d:%02d\", t->tm_hour,t->tm_min,t->tm_sec); mTextTimePtr->setText(timeStr); // Pay attention to modify the control name sprintf(timeStr, \"%d / %02d / %02d\", 1900 + t->tm_year, t->tm_mon + 1, t->tm_mday); mTextDatePtr->setText(timeStr); // Pay attention to modify the control name static const char *day[] = { \"Sun.\", \"Mon.\", \"Tue.\", \"Wed.\", \"Thu.\", \"Friu\", \"Sat.\" }; sprintf(timeStr, \"day of the week %s\", day[t->tm_wday]); mTextWeekPtr->setText(timeStr); // Pay attention to modify the control name } Set time sample code // Use tm structure to set time static void setSystemTime() { struct tm t; t.tm_year = 2017 - 1900; t.tm_mon = 9 - 1; t.tm_mday = 13; t.tm_hour = 16; t.tm_min = 0; t.tm_sec = 0; TimeHelper::setDateTime(&t); } // Or set the time with a string date str format: 2017-09-13 16:00:00 TimeHelper::setDateTime(\"2017-09-13 16:00:00\"); The complete source code can be found in the DateDemo project in Sample Code Package powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"tf.html":{"url":"tf.html","title":"TF card","keywords":"","body":"TF card When the TF card is inserted, the system will automatically mount as the /mnt/extsd directory. File path If there is a test.txt file in the root directory of your TF card, then on our machine, the absolute path of this file is /mnt/extsd/test.txt. Notes for writing TF card To write files to the TF card, try to follow the following operation sequence, otherwise it may cause the situation that it cannot be written.Insert card->Power on->Open file->Read and write files->fflush()->Close file->sync()->Unplug card In other words, if there is a need to write to a TF card, try to ensure that the TF card has been inserted before turning on the machine, rather than temporarily inserting the TF card when it is turned on. And after writing, pay attention to synchronization issues. Determine whether to mount the TF card #include \"os/MountMonitor.h\" if (MOUNTMONITOR->isMount()) { //TF card has been mounted } else { //TF card is not mounted } [!Note] The /mnt/extsd directory always exists, regardless of whether the TF card is insertedWithout the TF card inserted, if you read and write the directory, the content will be saved in the memory, but it will disappear if the power is off. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"mount.html":{"url":"mount.html","title":"Plug-in card monitoring","keywords":"","body":"TF card plug-in monitor By registering the monitoring interface, we can know the status of the TF card; here we first need to implement our own monitoring class : #include \"os/MountMonitor.h\" class MyMountListener : public MountMonitor::IMountListener { public: virtual void notify(int what, int status, const char *msg) { switch (status) { case MountMonitor::E_MOUNT_STATUS_MOUNTED: // insert // msg is the mount path LOGD(\"mount path: %s\\n\", msg); mMountTextviewPtr->setText(\"TF inserted\"); break; case MountMonitor::E_MOUNT_STATUS_REMOVE: // remove // msg is the unmount path LOGD(\"remove path: %s\\n\", msg); mMountTextviewPtr->setText(\"TF removed\"); break; } } }; Define the listener : static MyMountListener sMyMountListener; Register to monitor : MOUNTMONITOR->addMountListener(&sMyMountListener); When we no longer need to monitor, we need to un-register the monitor : MOUNTMONITOR->removeMountListener(&sMyMountListener); For specific operations, refer to the MountDemo project in Sample Code powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"reboot.html":{"url":"reboot.html","title":"Reboot the system","keywords":"","body":"Restart the system The following code can be used to actively restart the system machine. Required header files #include #include Code //Synchronize data and save cached data to prevent data loss sync(); reboot(RB_AUTOBOOT); powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"i18n.html":{"url":"i18n.html","title":"Multiple language","keywords":"","body":"Multi-language FlywizOS provides multi-language function to facilitate internationalization. How to add First, create a multi-language file through the new wizard. After creation, a subfolder named i18n will be generated under the project, and the default tr file will be added. The file name of each tr file represents the corresponding language (do not modify the file name at will). Double-click to open the tr file, you can see that the content is in xml format. Each string tag represents a translation. The name attribute is used to give an alias (it is recommended to name it as a combination of English, numbers, and underscores), and then use the alias to represent the string in the code. Note: The alias cannot be repeated in the same configuration file. Hello world! Hello, FlywizOS If you want to wrap in the string, use &#x000A; to escape, as follows: first line&#x000A;second line As shown above, we will alias the string \"hello, world!\" as hello_world, and alias the string hello, FlywizOS as hello_flywizos, if we want to add For more translations, we just need to add the string tag according to the example. Since it is a multi-language, we have to add the same name tag to each language. In this way, when we switch languages, the system will replace the content according to the name attribute. After the configuration file is added, we can use it in the ui file and code. Open the ui file, we can input @hello_world in the text property (we use the @ symbol followed by the alias in the configuration file to indicate that this string needs to be translated). Then, we download and run, you can see that the content of the text has been automatically translated into Hello, world! We can also translate strings in the code. Previously, we used the setText() function to set the string. If we need automatic translation, we need to use the setTextTr() function. E.g : /** * Triggered when the activity is constructed */ static void onUI_init() { // The parameter of setTextTr() is the name value in the language file. Note: The string passed in here does not need to be // preceded by the @ symbol mTextview1Ptr->setTextTr(\"hello_world\"); } Download and run, we can see that the content has been replaced with the corresponding string. We can also get the value corresponding to the current language name, and then do some operations like splicing, etc.: #include \"manager/LanguageManager.h\" static bool onButtonClick_Button1(ZKButton *pButton) { //LOGD(\" ButtonClick Button1 !!!\\n\"); std::string hello = LANGUAGEMANAGER->getValue(\"hello\"); std::string world = LANGUAGEMANAGER->getValue(\"world\"); std::string ret = hello + \" \" + world; LOGD(\"ret: %s\\n\", ret.c_str()); return false; } How to switch language The default language of the system is zh_CN (Simplified Chinese). You can open the system's built-in language switch activity to select a language.Add the following code to open the activity. EASYUICONTEXT->openActivity(\"LanguageSettingActivity\"); Or use the following API to switch languages freely. EASYUICONTEXT->updateLocalesCode(\"zh_CN\"); //Set to Chinese EASYUICONTEXT->updateLocalesCode(\"en_US\"); //Set to English EASYUICONTEXT->updateLocalesCode(\"ko_KR\"); //Set to Korean Font requirements Multiple language requires font support. If the text does not exist in the font, it will be displayed abnormally. Therefore, the font must contain text in multiple languages. The default font of the system is a simplified version. It is recommended to add custom fonts, see Font cutting. Sample For the complete source code, please see the TranslationDemo project in Sample Code powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"adb_debug.html":{"url":"adb_debug.html","title":"ADB debug ","keywords":"","body":"ADB fast download and debug FlywizOS can quickly download programs to the machine via USB cable or WIFI. Specific steps are as follows: First, make sure that the computer and the machine are successfully connected. There are two ways to connect: [!Note] Note: If you buy a version with WIFI, you can only connect via WIFI, and the USB cable cannot be used; The Ethernet version preferentially use the USB cable connection. If the USB connection is unsuccessful, the WIFI connection (network connection) is used. If the connection fails, please contact us. In the same way, if you purchase a version without WIFI, you can only connect via USB cable. USB cable connection is successful, you can see Use the USB cable to connect the computer and the machine. If the computer can recognize the machine as an Android device, the connection is normal. If you can't connect normally and the computer prompts a driver problem, you can try Download Update Driver. Connect via WIFI. (This method requires the machine to support WIFI.) First enter the WIFI setting of the machine, and connect the machine to the same network as the computer, that is, the computer and the machine must be connected to the same WIFI. (If a different network will cause the subsequent download procedure to fail). After the network connection is successful, click the menu button in the upper right corner of the WIFI setting to view the IP address of the machine, then open the FlywisOS IDE development tool, and on the menu bar, select the menu Debug Configuration -> ADB IP Configuration, fill in the machine IP and select OK. The tool will try to connect with the machine. If it prompts that the connection is successful, it means normal. If it fails, you need to check whether the IP is correct? Is the machine connected to WIFI normal? WIFI setting activity Operation process animation Download and debug After completing the previous step, you can download the program directly. In the Project Explorer, select the project name, right-click, and select the Download and Debug menu in the pop-up menu. After selection, it will automatically compile once. After the compilation is successful, download the program to the machine. If there is no error, then you can see that the machine program has been updated. Similarly, after selecting the project, you can also use the shortcut keys Ctrl + Alt + R to download and debug. View log Attention If an Android phone is connected to the computer, it may conflict with the machine and cause the download to fail. When using it, it is recommended to disconnect the Android phone temporarily. **Note: Run the program in this way, and the program cannot be solidified into the machine. If you unplug the TF card or restart after a power failure, the program will automatically resume. If you want the firmware to be stored in the device, you can select make upgrade image and then upgrade. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"logcat.html":{"url":"logcat.html","title":"View print log","keywords":"","body":"View log Add log Required header file #include \"utils/Log.h\" FlywizOS print uniformly calls LOGD or LOGE macro output, and the usage method is the same as that of C language printf; there are examples of calling in the code generated by default (commented out by default, open when needed) : static bool onButtonClick_Button1(ZKButton *pButton) { LOGD(\"onButtonClick_Button1\\n\"); return true; } View print After connecting ADB, you can view the print log of the program through our tool. The specific steps are as follows : On the menu bar, select FlywizOS -> Show Log Perspective, the tool will switch to another interface. In the lower left corner of the new interface, select LogCat, if the connection is normal, in the red box area on the right, you will see the machine's print log. If you want to return to the code editing interface, click the FlywizOS icon in the upper right corner of the tool. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"start_from_sdcard.html":{"url":"start_from_sdcard.html","title":"Start the program from the TF card","keywords":"","body":"Start the program from the TF card When we cannot use ADB to download the program, we can also download the program to the TF card and start the program from the TF card. [!Note] Note: TF card only supports FAT32 format Operating step First we have to configure the output directory of the program. Find this button on the toolbar Click the black drop-down arrow next to it, and select Path Setup in the pop-up menu In the pop-up box, select the drive of the TF card (please ensure that the TF card can be used normally), and click OK. In the above steps, we have configured the output directory, and now click the button in the figure below to start compiling, and it will package and output the compiled results to the configured drive. After the operation is successful, directories and files such as EasyUI.cfg, ui, lib, and font will be generated under the configured drive. Pull out the TF card, insert it into the machine, and power on the machine again. At this time, when the system detects the file in the TF card, it will start the program in the card instead of the program in the system. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"update_logo.html":{"url":"update_logo.html","title":"Upgrade boot LOGO","keywords":"","body":"Update boot LOGO First prepare a boot LOGO picture, the picture must comply with the following conditions. [!Note] The picture name is fixed as boot_logo.jpg. Note that the file extension is jpg; other names will not be recognized.The image size cannot exceed 128KB.The picture resolution must be exactly the same as the screen resolution. Copy boot_logo.jpg to the root directory of the TF card Insert the TF card into the machine, and then the device will automatically pop up an update prompt. Select boot_logo and click upgrade. After the upgrade is complete, the system will shut down and restart. Pull out the TF card at this time. Prevent the system from being upgraded again. Remarks : Upgrade a completely black picture to remove the boot LOGO. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"make_image.html":{"url":"make_image.html","title":"Make upgrade image file","keywords":"","body":"Make update image file In the previous tutorial, we used the Download and Debug menu to run the program, but it cannot write the program into the device. If you unplug the TF card or power off and restart, the program will automatically recover. If you want the writing program to be in the device, we can package the program into an update file. After the device is updated, the program can be written inside the device. Once the power is turned on, the program will be started by default. Specific steps First we need to configure the output directory of the mirror. Find this button on the toolbar Click the black drop-down arrow next to it, and select Path Setup in the pop-up menu In the pop-up box, select the output directory of the image file, and click OK. In the above steps, we have configured the output directory. Now click the button in the figure below to start compiling. It will package the compilation result and generate the update.img file and output it to the configured directory. After the update.img file is successfully generated, copy it to the TF card (Note: Before using, please format the TF card in FAT32 format), and insert the TF card into the machine. At this time, the system detects the files in the TF card and will start the update program. In the activity shown in the figure below, check the update items and click update button. After the update is completed, remove the update card in time to prevent repeated update. [!NOTE] Note: TF card only supports FAT32 format If the screen is damaged or the touch is inaccurate, which makes it impossible to update by clicking the button, then in this case, we can use Auto Update this way update our system. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"autoupgrade.html":{"url":"autoupgrade.html","title":"Auto upgrade","keywords":"","body":"Automatic card upgrade In the case of screen damage or inaccurate touch, if we want to upgrade the system, we can create a file in the root directory of the TF card zkautoupgrade (Note: The file has no suffix) In this way, the machine will automatically check the upgrade item after the card is inserted, and the upgrade will start after 2 seconds by default; if you need to control the time before the upgrade, we can open the zkautoupgrade file and fill in the corresponding number, the unit is seconds; after the upgrade is completed , The system restarts, remember to pull out the TF card to prevent automatic upgrade again. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"sd_boot.html":{"url":"sd_boot.html","title":"Make swipe card","keywords":"","body":"​ Make swipe card [!Warning] Note: The maximum capacity of the TF card supports 16G. If it is too large, the machine cannot recognize the TF card and cannot be upgraded.For the latest software update package, please go to the QQ group: 371608200 group sharing download. Pay attention to find the corresponding version of the software on the back of the machine label, otherwise the upgrade may cause abnormalities! Download Computer Flash Tool Select the TF card drive on the computer Specify the upgraded image file Click to burn After the programming is successful, pull out the TF card, insert the machine, and then power on again to upgrade Recovery card Select the TF card drive on the computer Click to recovery card After formatting, the card will resume normal use powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"remote_update.html":{"url":"remote_update.html","title":"Remote upgrade","keywords":"","body":"Remote update Currently, the system does not have an interface for direct remote upgrade.But we can understand the TF card detection and upgrade mechanism, and then add some of our own code to achieve the purpose of remote upgrade. We first introduce the general upgrade process of inserting a TF card. TF card detection upgrade process When the system is started or the TF card is inserted, if [TF card is normally mounted] (tf.md), the system will detect whether there is an update.img file in the root directory of the TF card (in the system, The root directory of the TF card is mapped to /mnt/extsd).If it exists, further verify whether the file meets the requirements. If it passes the verification, an upgrade prompt interface will pop up, and the user can choose to upgrade.If it does not exist, the detection process ends and there is no action. Implementation steps First we have to download the upgrade image update.img. Under normal circumstances, downloading files through the HTTP protocol is the easiest way, of course, you can also choose other protocols according to the actual situation. After downloading, save the image file to the TF card directory /mnt/extsd/. [!Note] If there is no TF card inserted in the machine, this directory can still be written because it is stored in the memory. Limited by the memory size, if the image file is too large, it may cause abnormal device operation or upgrade failure.If you have inserted a TF card, you can ignore the memory size problem. Call upgrade detection function First download the UpgradeMonitor.h source file and save it to the jni/include/os directory of the project. Then call the interface to detect the upgrade. #include \"os/UpgradeMonitor.h\" //Actively detect whether there is a correct update.img file in the /mnt/extsd directory, //If yes, an upgrade prompt box will pop up //If not, nothing happens UpgradeMonitor::getInstance()->checkUpgradeFile(\"/mnt/extsd\"); After the upgrade prompt interface pops up, the user can choose whether to upgrade.So far, the remote upgrade function has been fully realized. Automatically upgrade after downloading the file If you want to force the update after downloading the upgrade file, you only need to refer to the Autoupgrade document and create a zkautoupgrade file with code. Avoid repeated upgrades In the above steps, we save the image file in the /mnt/extsd/ directory. After a successful upgrade, the machine will automatically restart.At this time, the system will perform the regular upgrade detection process. Due to the existence of the image file, the upgrade prompt interface pops up again, resulting in repeated upgrades. Solution When downloading the image file, save it to a directory other than /mnt/extsd/, for example: /mnt/extsd/temp/， in addition, the parameters of the call detection function are also modified synchronously. UpgradeMonitor::getInstance()->checkUpgradeFile(\"/mnt/extsd/temp\"); Sample Complete sample downloadThe sample simply implements the http client to download files, refer to the http part of the source code. Downloading files is a time-consuming operation, it is recommended to put them in a separate thread, so as not to affect the immediate response of the interface. Key code class DownloadThread : public Thread { protected: virtual bool threadLoop(){ http::HttpClient http; mTextview1Ptr->setText(\"Download the upgrade file\"); //Create a save path for the upgrade file system(\"mkdir /mnt/extsd/temp\"); //Modify here to the real service IP string err = http.Download(\"192.168.1.1/update.img\", 80, \"/mnt/extsd/temp/update.img\"); mTextview1Ptr->setText(err); if (err.empty()) { UpgradeMonitor::getInstance()->checkUpgradeFile(\"/mnt/extsd/temp\"); } mButton1Ptr->setInvalid(false); return false; }; }; Server implementationFor the convenience of testing, the example includes a http.exe, which is a static file service. Put the made upgrade image file update.img and http.exe in the same folder, then double-click on the computer to execute http.exe, as long as the network is normal, you can download the file in the same directory through the website Mirror file.E.g:http://192.168.1.1/update.img(Please pay attention to modify the IP address to the current IP of the computer) After the server is started, run the sample code to test the remote upgrade. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"demo_download.html":{"url":"demo_download.html","title":"Sample code","keywords":"","body":"Sample download [!Note] Please download the sample code of the platform corresponding to the screen first, if it is not, you can download a copy, and then refer to convert compile platform to convert by yourself FW9306 or FW9306s platform 480x272 sample code Other sample code(Modbus、Sqlite、CURL HTTP、Mqtt) FW9311 platform 800x480 sample code 1024x600 sample code Other sample code(Modbus、Sqlite、CURL HTTP、Mqtt) powered by Gitbooklast modified: 2021-01-15 17:33:39 "},"file_read_write.html":{"url":"file_read_write.html","title":"File read and write","keywords":"","body":"File read/write If you are familiar with file reading and writing in standard C language, you can read and write files in standard C language. For some commonly used file read and write operations, we made a simple package based on the C language file read and write interface, which is convenient to use. If necessary, you can follow the steps to integrate the source code into your own project. /** * Write a file. If the file exists, it will be overwritten. If the file does not exist, create a new file and write the content * Successfully returned true */ bool WriteFile(const char* filename, const void* data, int len); /** * Append content at the end of the file, if the file does not exist, create a new file first, and then write the content * Successfully returned true */ bool AppendFile(const char* filename, const void* data, int len); /** * Read file * Success - save the file in the data of string in binary form, read the binary content with string.data() * Failure - Return empty string */ string ReadFile(const char* filename); Porting steps Create a new folder under the jni folder of the project and name it io Download ioutil.h, ioutil.cpp. Two files are saved in the io folder. How to use Include header file#include \"io/ioutil.h\" Write file //Write the string \"0123456789\" into the file 123.txt const char* filename = \"/mnt/extsd/123.txt\"; //Path to save the file const char* str = \"0123456789\"; ioutil::WriteFile(filename, str, strlen(str)); Append file //Append the content to the end of the file, if the specified file does not exist, create a new file. const char* append_str = \"abcdefgh\"; ioutil::AppendFile(filename, append_str, strlen(append_str)); Read file const char* filename = \"/mnt/extsd/123.txt\"; //Read all the contents of the file and save it in content string content = ioutil::ReadFile(filename); //Output each byte read to the log in hexadecimal for (size_t i = 0 ; i [!Warning] The ioutil::ReadFile function reads all the contents of the file into the memory. If the specified file is too large, it will cause insufficient memory, which may cause an exception. Write files continuously, suitable for writing large files const char* filename = \"/mnt/extsd/123.txt\"; const char* append_str = \"abcdefgh\"; ioutil::Writer w; if (w.Open(filename, false)) { for (int i = 0; i Continuous reading, suitable for processing large files const char* filename = \"/mnt/extsd/123.txt\"; ioutil::Reader r; if (r.Open(filename)) { char buf[1024] = {0}; while (true) { int n = r.Read(buf, sizeof(buf)); if (n > 0) { //Have read content, output every byte for (int i = 0; i Test code /** * Triggered when the interface is constructed */ static void onUI_init() { //Write file const char* filename = \"/mnt/extsd/123.txt\"; const char* str = \"0123456789\"; ioutil::WriteFile(filename, str, strlen(str)); string content = ioutil::ReadFile(filename); LOGD(\"Number of bytes read %d, content:%s\", content.size(), content.c_str()); //Append file const char* append_str = \"abcdefgh\"; ioutil::AppendFile(filename, append_str, strlen(append_str)); content = ioutil::ReadFile(filename); LOGD(\"Number of bytes read %d, content:%s\", content.size(), content.c_str()); ioutil::Writer w; if (w.Open(filename, false)) { for (int i = 0; i 0) { //Have read content, output every byte for (int i = 0; i powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"net.html":{"url":"net.html","title":"Socket programming","keywords":"","body":"Socket network programming If you are familiar with Linux socket programming, you can perform network programming according to the standard Linux socket programming interface. Implement operations for some commonly used socket programming, for example, create a TCP client, We have made a simple package based on the standard interface of Linux, which is convenient to use. If necessary, you can follow the steps to integrate the source code into your own project. Porting steps Create a new folder under the project's jni folder and name it net Download net.h, net.cpp Two files are saved in the net folder. How to use TCP Client Required header file#include \"net/net.h\" Example//Use TCP protocol to connect to port 80 of the domain name www.baidu.com, and change the domain name to IP. net::Conn* conn = net::Dial(\"tcp\", \"www.google.com:80\"); //net::Conn* conn = net::Dial(\"tcp\", \"14.215.177.38:80\"); if (conn) { byte buf[2048] = {0}; const char* req = \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"; //send conn->Write((byte*)req, strlen(req)); while (true) { //read，1000ms timeout int n = conn->Read(buf, sizeof(buf) - 1, 1000); if (n > 0) { buf[n] = 0; LOGD(\"read %d bytes： %s\", n, buf); } else if (n == 0) { LOGD(\"Normal disconnection\"); break; } else if (n == net::E_TIMEOUT) { LOGD(\"read timeout\"); } else { LOGD(\"error\"); break; } } //Close the connection conn->Close(); //Release memory delete conn; conn = NULL; UDP Client Required header file #include \"net/net.h\" Example//Use udp protocol to connect IP: 192.168.1.100 port 8080 net::Conn* conn = net::Dial(\"udp\", \"192.168.1.100:8080\"); if (conn) { byte buf[2048] = {0}; const char* req = \"hello\"; conn->Write((byte*)req, strlen(req)); while (true) { //read，1000ms timeout int n = conn->Read(buf, sizeof(buf) - 1, 1000); if (n > 0) { buf[n] = 0; LOGD(\"read %d bytes： %s\", n, buf); } else if (n == 0) { LOGD(\"Normal disconnection\"); break; } else if (n == net::E_TIMEOUT) { LOGD(\"read timeout\"); //Set timeout here to exit break; } else { LOGD(\"error\"); break; } } //Close the connection conn->Close(); //Release memory delete conn; conn = NULL; } powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"http.html":{"url":"http.html","title":"HTTP","keywords":"","body":"HTTP If you need to implement HTTP Get, POST requests, libcurl is a good choice, it is a C language open source library.For ease of use, we have compiled the library.Directly download the CURLDemo project in the third-party porting code sample of Sample Code. [!Note] Be sure to download the version corresponding to the platform, otherwise it will not run. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"transcoding.html":{"url":"transcoding.html","title":"Transcoding","keywords":"","body":"UTF-8 encoding Currently, the system only supports UTF-8 encoding. For example, controls such as text boxes can only display UTF-8 encoded strings normally. If you want to display other codes normally, you need to transcode by yourself. sconv Sconv is an open source library for transcoding. Here, we use it to convert between utf-8 and gbk. Preparation Download sconv source and unzip it to our project jni folder. UTF-8 to GBK Required header file #include #include \"utf8cover/sconv.h\" Add function string utf8_to_gbk(const char* utf8_str) { int size = sconv_utf8_to_unicode(utf8_str, -1, NULL, 0); wchar *unicode = new wchar[size / 2 + 1]; size = sconv_utf8_to_unicode(utf8_str, -1, unicode, size); unicode[size / 2] = 0; size = sconv_unicode_to_gbk(unicode, -1, NULL, 0); char *ansi_str = new char[size + 1]; size = sconv_unicode_to_gbk(unicode, -1, ansi_str, size); ansi_str[size] = 0; string gbk(ansi_str, size); delete[] ansi_str; delete[] unicode; return gbk; } Use the function just now to perform encoding conversion, an example is as follows:const char* utf8_str = \"This is utf8 encoding\"; string gbk = utf8_to_gbk(utf8_str); LOGD(\"After conversion, a total of %d bytes\", gbk.size()); for (size_t i = 0; i GBK to UTF-8 Required header file #include #include \"utf8cover/sconv.h\" Add function string gbk_to_utf8(const char* gbk_str) { int size = sconv_gbk_to_unicode(gbk_str, -1, NULL, 0); wchar *unicode_str = new wchar[size / 2 + 1]; size = sconv_gbk_to_unicode(gbk_str, -1, unicode_str, size); unicode_str[size / 2] = 0; size = sconv_unicode_to_utf8(unicode_str, -1, NULL, 0); char *utf8_str = new char[size + 1]; size = sconv_unicode_to_utf8(unicode_str, -1, utf8_str, size); utf8_str[size] = 0; string utf8(utf8_str, size); delete[] unicode_str; delete[] utf8_str; return utf8; } Use the function just now to perform encoding conversion, an example is as follows://To testing, here is a gbk encoding array whose content is \"This is gbk encoding\" const char gbk_str[] = {0xd5, 0xe2, 0xca, 0xc7, 0x67, 0x62, 0x6b, 0xb1, 0xe0, 0xc2, 0xeb,0}; string utf8 = gbk_to_utf8(gbk_str); LOGD(\"After conversion, a total of %d bytes\", utf8.size()); LOGD(\"Content is：%s\", utf8.c_str()); powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"json.html":{"url":"json.html","title":"JSON","keywords":"","body":"JSON construction and analysis The default project already includes the open source cppjson library, which can be used directly. Steps for usage Required header file #include \"json/json.h\" Construct JSON string Json::Value root; //Add integer value root[\"int\"] = 1; //Add string root[\"str\"] = \"hello\"; //Due to the accuracy printing problem of floating-point numbers, it is not recommended to use, try to convert to integer root[\"float\"] = 3.14f; //add array Json::Value array; array.append(\"123\"); array.append(\"456\"); array.append(\"789\"); root[\"array\"] = array; //json nesting Json::Value sub; sub[\"int\"] = 1; sub[\"str\"] = \"sub str value\"; root[\"subJson\"] = sub; LOGD(\"The generated json string is : \"); LOGD(\"%s\", root.toStyledString().c_str()); ParsingJSON //Parsing json Json::Reader reader; Json::Value root2; //For convenience, Use the constructed json string as input for parsing json std::string test_json_string = root.toStyledString(); if (reader.parse(test_json_string, root2, false)) { LOGD(\"Parsed successfully\"); //When parsing json, you must check the legitimacy of the input more to avoid the program crash caused by illegal input. if (root2.isMember(\"int\")) { LOGD(\"int = %d\", root2[\"int\"].asInt()); } if (root2.isMember(\"str\")) { LOGD(\"str = %s\", root2[\"str\"].asString().c_str()); } if (root2.isMember(\"array\")) { Json::Value obj = root2[\"array\"]; if (obj.isArray()) { for (Json::ArrayIndex i = 0; i powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"cpp_base.html":{"url":"cpp_base.html","title":"C++ basic","keywords":"","body":"c++Basic knowledge This chapter is mainly for people who do not have base of C++, mainly to explain the common C++ grammar and common classes in our system : Class Mention C++, you have to mention the class first. Don't think about it too complicated. Just think of it as a structure in the C language. For example : // C struct Position { int left; int top; int width; int height; }; // c++ class Position { public: int left; int top; int width; int height; }; Define variables : // C struct Position pos; // c++ Position pos; Operating variables : // C is the same as c++ pos.left = 0; The class has more concepts of inheritance, polymorphism, overloading and access permissions than the structure in the C language. For people who are only familiar with the C language, they don’t need to pay too much attention to these details, as long as they master how to use it; In addition, functions can be directly defined in class. The structure in C language is to define function pointers. This is a bit different. After class defines the function, it can be used like operating variables. Here Give an example commonly used in our framework : // Set the text content, where mTextView1Ptr is a pointer variable of type ZKTextView mTextView1Ptr->setText(\"Hello\"); Commonly used class string class The string class actually encapsulates the string and provides a lot of functions. Person who are only familiar with the C language only need to know one function: c_str(), this function will return the characters in the string class string data, here is also an example commonly used in our framework: // Input box callback function static void onEditTextChanged_Edittext1(const std::string &text) { // The return value type of c_str() function : const char * const char *pStr = text.c_str(); // Then you can operate like ordinary strings, such as getting the string length strlen(pStr), etc. } Give another example of obtaining the content of a text control : // std is the namespace, std::string means to use the string class under std, don’t worry too much // When encountering the string class, we can refer to the following definition std::string text = mTextView1Ptr->getText(); // The subsequent operations are the same const char *pStr = text.c_str(); formatted output function \"snprintf\" Function prototype : int snprintf(char* dest_str,size_t size,const char* format,...); Function : The variable parameters (...) are formatted into a string according to format, and then copied to dest_str. (1) If the length of the formatted string is less than size, copy the string to dest_str, and add a string terminator ('\\0') after it; (2) If the length of the formatted string >= size, only (size-1) characters are copied to dest_str, and a string terminator ('\\0') is added after it, and the return value is the desired the length of the written string. Required header files : #include Formatting parameters Specifier%d Decimal signed integer%u Decimal unsigned integer%f Floating point%s String%c Character%p Pointer value%e Exponential floating point%x, %X Unsigned integer in hexadecimal%o Unsigned integer in octal%g Output the value according to the smaller output length in %e or %f type%p Output address%lu Output long integer %llu 64-bit unsigned integer Description (1).You can insert a number between \"%\" and the letter to indicate the maximum field width. For example: %3d means to output a 3-digit integer, which is not enough to be right-justified. %9.2f represents a floating-point number with a field width of 9, where the decimal place is 2 and the integer place is 6, the decimal point occupies one digit, which is not enough for 9 digits to be right-justified. %8s means output a string of 8 characters, which is not enough to right-justify 8 characters. If the length of the string or the number of integers exceeds the specified field width, it will be output according to its actual length. But for floating-point numbers, if the number of integers exceeds the specified width of integers, it will be output as actual integers; If the number of decimal places exceeds the specified width of decimal places, the output will be rounded according to the specified width. In addition, if you want to add some zeros before the output value, you should add a zero before the field width term. For example: %04d means that when outputting a value less than 4 digits, 0 will be added to the front to make the total width 4 digits. If a floating point number is used to represent the output format of characters or integers, the number after the decimal point represents the maximum width, and the number before the decimal point represents the minimum width. For example: %6.9s means to display a string with a length not less than 6 and not greater than 9. If it is greater than 9, the content after the 9th character will be deleted. (2).You can add a lowercase letter l between \"%\" and the letter to indicate that the output is a long number. For example: %ld means output long integer %lf means output double floating point number (3) You can control the output to be left-aligned or right-aligned, that is, add a \"-\" sign between \"%\" and the letter, indicating that the output is left-aligned, otherwise it is right-aligned. For example: %-7d means that the output 7-bit integer is left-justified %-10s means output 10 characters left-justified Special specifier\\n Wrap\\f Clear screen and change page\\r Carriage return\\t Tab character Example Direct output integer char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%d\", 314); LOGD(\"%s\", buf);//Log output buf The log output is 314 Control the number of digits of the integer char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%05d\", 314); //Format as 5 digits, less than 5 digits, add 0 in front LOGD(\"%s\", buf);//Log output buf string The log output is 00314 Output floating point number directly char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%f\", 3.14); LOGD(\"%s\", buf);//Log output buf string The log output is 3.140000 Control output floating point number format char buf[64] = {0}; //Output decimals, a total of 6 characters wide (including the decimal point), 3 decimal places, two integer digits, and 0 if //the integer is less than two digits snprintf(buf, sizeof(buf), \"%06.3f\", 3.14); LOGD(\"%s\", buf);//Log output buf string The log output is 03.140 powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"touchcalibration.html":{"url":"touchcalibration.html","title":"Touch calibration","keywords":"","body":"Touch calibration After the resistive touch screen machine is flashed, the system will perform a touch calibration the first time it is turned on. The calibration interface is as follows: Click the \"cross icon\" to calibrate; we want to calibrate again later, we have the following 3 methods : Modify the project properties through the tool, check the Touch calibration after booting option, so that each time you start up, you will enter the touch calibration interface: Create a file zktouchcalib in the root directory of the TF card (note: the file does not have a extension), after inserting the card, it will enter the touch calibration interface Start the touch calibration activity by codeEASYUICONTEXT->openActivity(\"TouchCalibrationActivity\"); powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"font_setting.html":{"url":"font_setting.html","title":"Font setting","keywords":"","body":"Font setting The default font library packaged in FlywizOS system is Consolas, we can view the project properties: The font option is checked by default, and the compiled upgrade file will be packaged in the fzcircle.ttf font library in the font directory of the corresponding platform in the tool installation directory If we want to use other font libraries, just remove the default options and import a new font library (Note that this font library only supports ttf format) : powered by Gitbooklast modified: 2021-01-04 09:03:59 "},"font_cut_tool.html":{"url":"font_cut_tool.html","title":"Font cutting ","keywords":"","body":"Font cutting In the project, custom fonts may be used, but 10M full fonts are not suitable for use in projects.Moreover, usually we only use a small part of the font, cutting out the unnecessary characters, which can greatly save the space consumption of the font, and also speed up the startup speed of the screen. Use of font cutting tool In the menu bar of the tools, you can find the font cutting tool. First choose the \"Set the font cutting method\". The purpose of this step is to determine which characters in the font are retained. Regular expressionSupport java regular expressions, for example \\d means all numbers Specify textSpecify a text file, Ensure that the file encoding is UTF-8, all text in the file content means the text that needs to be retained. (Recommended method: simple and intuitive) Set the fontSpecify the path of the full font. Set the output pathSpecify the save path of the new font after the font is cut. If the file already exists, it will be overwritten. After setting the above parameters, click Cut If the prompt is completed, the cutting is successful, and the newly generated font file can be seen in the output path. It can be found that the cropped font file is smaller than the complete font. Example Create a new txt file, the content of the file is only \"Hello\" one words, Save the code as UTF-8. After setting the parameters and cutting, the final generated ttf file size is less than 10KB.The cropped font can be verified in Online Font Editor which characters it contains. powered by Gitbooklast modified: 2020-12-11 14:44:41 "},"problems.html":{"url":"problems.html","title":"FAQ","keywords":"","body":"FAQ Time-consuming operations in the UI main thread cause the card to not display the upgrade interface The refresh display of the activity is handled in the main UI thread. If there are some time-consuming operations or an infinite loop of the program in the main UI thread, it will affect the refresh of the UI and cause the card to not display the upgrade interface; onUI_init, onUI_intent, onUI_show, onUI_hide, onUI_quit, onUI_Timer and some callback interfaces related to controls, these functions are all called in the UI main thread, so this situation should First check if there are any time-consuming operations in these functions; In this case, the machine can only be restarted by plugging in the card. After the system is up, it will first check whether it needs to be upgraded, so that the upgrade interface can be displayed normally. Unable to download and debug/download and debug failed First confirm that the computer and the screen are connected correctly. If it is a screen with WIFI, it only supports WIFI connection and cannot use the USB cable connection; similarly, if it is a screen without WIFI, then it can only be connected via a USB cable, if it is connected by USB Normally, the computer will recognize it as a USB device.After confirming the supported connection mode, go to the development tool menu bar, select Debug Configuration -> ADB Configuration, set the corresponding connection mode, and save.Try to download again.How to download and debug via ADB The program suddenly restarts by itself or gets stuck First, when an unexpected situation occurs in the program, you must check the log (How to view the log), try to reproduce the problem repeatedly, and determine the problem code based on the log.If the program crashes and restarts, a similar log will generally appear on the log. These logs will be output when the program is started and initialized, so you can use this to determine whether the program has restarted. Most of the causes of program crashes can be attributed to incorrect usage of pointers. E.g Null pointer Array out of bounds Did not pay attention to the life cycle of the pointer, but the memory is still in use after the release etc.Since the project uses C and C++ language programming, it is inevitable that we need to deal with raw pointers in terms of pointer memory, which requires us to be extra careful. There is another kind of crash, which may be caused by not paying attention to the error of Divisor cannot be 0. If the program is stuck, from the log, there is no restart phenomenon, then we can check from thread deadlock, whether the code loops indefinitely, there is a long time-consuming operation, causing the stuck the illusion of death analyze these situations. powered by Gitbooklast modified: 2021-01-04 09:14:23 "},"install_adb_driver.html":{"url":"install_adb_driver.html","title":"install ADB driver","keywords":"","body":"How to use the Android ADB driver installer for Windows XP/Vista/7/8/10 Download the [driver installation program] (http://dl.adbdriver.com/upload/adbdriver.zip) first. Connect the Android device to the computer via USB. In the ADB driver installer, click the Install button to continue. If the system prompts that Windows cannot verify the publisher of this driver software, please select \"Always install this driver software\" in the \"Window Security\" dialog box. The universal android usb driver will be automatically installed on your computer. Finally, ADB Driver Installer will show that the installation was successful Windows XP users are recommended to restart after installing the driver. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"convert_platform.html":{"url":"convert_platform.html","title":"Convert platform","keywords":"","body":"Convert compile platform In order to facilitate the use of the same project source code on different hardware platforms, the function of Convert Compie Platform is provided. Steps : Select the project name, right-click, and select Convert Compile Platform in the pop-up context menu to quickly switch platforms. For the conversion function, the following points need to be noted: The conversion function is essentially to reconfigure the compilation environment such as the compilation tool chain, and there will be no changes to the source code. The hardware of different platforms is different, so the hardware-related settings such as serial port and GPIO need to be modified manually. Due to differences in toolchain versions, compilation failures may occur after conversion. This also requires manual modification of Makefile or source code to solve this problem. powered by Gitbooklast modified: 2020-12-08 18:24:17 "}}