{"./":{"url":"./","title":"About us","keywords":"","body":"About us 目標 開発をより簡単かつ効率的に作成し、一般ユーザーにも便利なカスタム開発プログラムを提供しています。 価値 プロフェッショナル：専門知識に専門の製品の製造 革新：顧客への安定した価値の流れを提供するための継続的なイノベーション 責任：技術を使用して生活を変えなさい ディスプレイモジュール情報 Linuxディスプレイソリューションを作成する理由 技術の発展とともに、人間 - コンピュータの相互作用システムがアップグレードされました。現在、いくつかの伝統的な分野では、人間 - コンピュータ相互作用の発展は比較的遅いです。伝統的な分野では、シングルチップマイクロコンピュータ、シングルチップマイクロコンピュータ+ FPGAをベースにした多くのディスプレイ・ソリューションがあり、多くの顧客の対話型のカラースクリーンディスプレイ開発の困難な問題を解決しました。 しかし、ユーザーのニーズと対話型コンテンツが増加するにつれて、既存のハードウェアの制限にはもはやほとんどの顧客の要求を満たすことができないため、この製品を作りました。伝統的な分野の便利な人間 - コンピュータの相互作用の経験にプログラム+モノのインターネットのアクセス機能を強化して、物事のインターネットの開発を支援します。 製品の利点 既存のシングルチップのシリアルポートディスプレイまたは単一のチップ+ FPGAディスプレイソリューションと比較 高い顧客対応も、低製品学習コストと優れた表示効果と携帯電話やタブレットコンピュータのような最新のインタラクティブな体験を提供しています。 層の数を制限する従来のディスプレイ方式の問題を解決するためのソフトウェアを介して、複数の層の仮想化技術を実装します。 png形式のデコード機能をサポートするため、画像のレイヤーオーバーレイ効果がより良いです。 システムレベルでWiFi、イーサネット、2Gと4Gアクセス機能をサポートして、お客様に、より便利なネットワークアクセスを提供すると同時にDeep Zhiyun、WeChat IoT、WeChat Payで、Alipayおよび他のプラットフォームに便利で簡単にアクセスすることができ、共有産業のためのクイックIoT端末ソリューションを提供することができます。 ユーザーに情報を表示するために、より便利なビデオデコード機能を提供します。 Androidと既存のLinuxソリューションの比較 テストのための信頼性の高いハードウェア基盤を提供し、ハードウェア開発のテストと検証のサイクルを節約します。 IoT+ディスプレイのためのシステム開発作業を提供して、IoTとディスプレイのシステムを再 - 開発とデバッグする時間を節約します。 低コストと高効率動作機能を提供：現在のシステムは、1GシングルコアCPU、64MB DDR2、16MBのフラッシュで実行され、ハードウェアのコストの50％以上を節約します。 顧客がカスタマイズされた開発を迅速に完了することができるように構成+ユーザーロジックのソースコードが含まれている開発ツールを提供しています。開発サイクルは、従来の方法よりも少なくとも60％短縮されます。 カスタマイズされたシステムは、3秒で高速起動して、24時間*365日、安全に動作することができます。 アプリケーションのシナリオ Smart home： Smart Appliances Shared industry Elevator indicator Advertising machine Charging pile Evaluation machine powered by Gitbooklast modified: 2020-12-07 11:41:20 "},"system_introdoction.html":{"url":"system_introdoction.html","title":"FlywizOS システムの概要","keywords":"","body":"FlywizOSシステムフレームワークの概要 このシステムは、Linuxシステムの開発に基づいており、独自の開発したシステムのフレームワークとGUIインタラクティブシステムが追加されました。 私たちは、これをFlywizOSシステムと呼ばれます。 システムターゲットシナリオ 現在のものインターネット業界は急速に発展しており、液晶ディスプレイの価格が下落することにより、ユーザーのディスプレイの需要が増加しています。 現在の発展を考慮して、我々は、現在の段階で、より適切なディスプレイソリューションを提案した。 家電製品やアクセス制御、高いシステム信頼性の要件と高いコストパフォーマンスの要件などの機能がある小規模なアプリケーションのシナリオではAndroidを置き換えます。 既存のモノクロディスプレイまたはMCUベースのカラーディスプレイソリューションを置き換えて、安価な方法でインタラクティブな体験を向上させます。 モノのインターネットと共有シナリオの到来により、ディスプレイウィンドウの相互作用のための需要が増加した。コスト効率的で信頼性の高いシステムを提供しています。 システム構成 カーネル オープンソースのLinux3.4カーネルのバージョンに基づい IoT産業に合わせてカスタマイズし、最適化されて システム 自律GUIフレームワーク ネットワークAPI그 マルチメディアサービス IoTプラットフォームへのアクセス 決済プラットフォームへのアクセス機能 リモートアップデートシステムの機能 リモートでメッセージをプッシュする機能 開発支援 WYSIWYG構成GUI開発ツールを提供 完全なコードオープン 継続的に更新されるドキュメントとサンプルサポート 継続的に更新されるコントロールパッケージとシステムのアップグレードサービス powered by Gitbooklast modified: 2020-12-08 10:39:03 "},"docs_brief.html":{"url":"docs_brief.html","title":"開始する","keywords":"","body":"開始する 以下は、入門のためのガイドです。 Tools編 FlywizOSのLCDボードを使用する前に、ユーザーは、まず開発ツールをインストールする必要があります。 Toolを実行し、開発環境に慣れる。新しいプロジェクトを作ってみて、各ウィンドウの役割について確認します。 新たに作られたプロジェクトのUIには、何もありません。簡単にTextコントロールをドラッグ＆ドロップで作成し、コンパイルダウンロードして、その結果を確認することができます。 Note：もし所有しているボードがWIFIバージョンであれば、まず、ADB IPを設定する必要が正常にプログラムのダウンロードが可能です。（プロジェクトの実行方法 私たちは、多くのサンプルコードを提供しています。所有しているプラットフォームに合ったサンプルコードパッケージをダウンロードした後、解凍してツールにImportと多くのプロジェクトを確認することができ、他の章でこれについて詳しく紹介します。 ルール編 Toolに慣れた後、LCD基板の開発規則について説明します。 プロジェクトのフォルダ構造を理解すると、プロジェクトが何を含んでいるか、どこにUIファイル、コード、リソースがあり、保存されていることがわかります。 次に、どのような内容がツールによって自動的に生成されるか、UIファイルに対応するソースコードが何なのか、コントロールの名前付け規則などを紹介します。これらを理解した後、コントロールを操作するために任意のコードを変更する必要があるか知ることができます。 コントロール編 開発画面で、ナビゲーションバー、様々なコントロールと各コントロールの使用について紹介します。 Uart編 まず、ボードで使用されたUARTを利用した通信モデルを紹介します。 その後、指定されたサンプルに沿ってみて、これを基にプロトコルと機能を追加します、 最後に、通信フレームワークを、実際の実装してください。 Update編 二つのアップグレード方法があります。 イメージファイルの作成 —— update.img : この方法は、プログラムをボードに保存することで、電源がオフになった後もプログラムは保持されます。Note：一般的なダウンロードおよびデバッグとの違いに注意してください。この方法は、最も一般的に使用される方法でもあります。 スワイプカードを作成する —— システム全体をフォーマットします。システムが新しいバージョンに更新されると、正式に該当する更新ファイルの提供されます。ユーザーは、このファイルと専用ツールを利用して、TFカードをFlash専用カードにしてボードを更新することができます。また、システムの電源が入らない場合でも、やはり、この方法を使用して回復することができます。 Debug編 現在のプログラムは、ログのみデバッグすることができます。 Module編 Core Module Instructions 参照してください。 Hardware編 Hardware Instructions 参照してください。 FAQ編 common problems and solutions 参照してください。 powered by Gitbooklast modified: 2020-12-14 10:50:04 "},"download.html":{"url":"download.html","title":"開発環境のインストール","keywords":"","body":"開発環境のインストール FlywizOS IDEとSDKをインストールする Windows FlywizOS IDE powered by Gitbooklast modified: 2021-01-15 17:35:24 "},"flywizOS_ide_snapshot.html":{"url":"flywizOS_ide_snapshot.html","title":"初めて使用","keywords":"","body":"FlywizOS IDE初めて使用 FlywizOS IDEが正常にインストールされると、開発者は、デスクトップの壁紙で！ZKSW-Editor快捷方式のショートカットをダブルクリックして、IDEを実行します。 Workspace選択 IDEを実行すると、下のポップアップ画面を見ることができます。 Workspaceは、開発に関連した設定と履歴が保存されている空間です。この空間は、複数のプロジェクトを同時に管理するコンテナのように理解することができ、IDEを同時に複数実行する必要がありません。 Welcome 画面 もし最初のIDEを実行して、workspaceを選択すると、下の図のWelcome画面を見ることができます。 この画面は2つの機能を提供しています : New Project , Import Project New Projectどのように新しいプロジェクトを作成かどうかを段階的に実行します。 Import Project この機能により、既存のに作られたプロジェクトを現在のWorkspaceにインポートして、以前の開発を継続することができます。 プロジェクトのインポート Welcome画面を再オープンをしたい場合はメニューでHelp - > Welcomeを選択します。 ​ powered by Gitbooklast modified: 2020-12-03 10:18:21 "},"flywizOS_ide_layout_introduce.html":{"url":"flywizOS_ide_layout_introduce.html","title":"ワークスペースの概要","keywords":"","body":" FlywizOS IDEのワークスペース 新しいプロジェクトが作成されると、下の画面を見ることができます。 エディタは、約6つの領域に分けられ、関連する機能は次のとおりです。 ①Area-Project Explorer この領域は、ツリーの形でプロジェクトのフォルダとファイルを表示します。開発者は自由に拡張/縮小が可能であり、ダブルクリックで、目的のファイルを開いて変更することができます。 ②Area-Edit box この領域は、コードを変更したり、UI画面をプレビューすることができます。開発のメイン領域です。 ③Area-Control Box この領域は、すべてのコントロールが含まれています。ここで必要なコントロールをクリックして、②areaにドラッグしてコントロールを作成することができます。 ④ Area-Properties この領域は、area②のコントロールをクリックすると、そのコントロールのプロパティを表示します。すべてのプロパティは、テーブルの形式で表示され、ここで必要に応じてプロパティを変更することができます。 ⑤Area-Outline この領域は、ツリーの形でUIファイル内のすべてのコントロールを表示します。やはり自由に拡張/縮小が可能であり、コントロール間の階層関係を把握することができます。そして、ノードをドラッグしてすぐに、階層構造を変更することができ、各コントロールを非表示にしたり、見ることができます。この機能は、複雑な階層構造を使用して簡単です。 ⑥ Area-Console コードをコンパイルすると、この領域にコンパイルするための結果が表示されます。もしコンパイルが失敗した場合は、そのエラーをダブルクリックすると、すぐにそのコードに移動することができます。 powered by Gitbooklast modified: 2020-12-03 10:14:37 "},"new_flywizOS_project.html":{"url":"new_flywizOS_project.html","title":"新しいプロジェクト","keywords":"","body":"新しいFlywizOSプロジェクトを作成する 新しいFlywizOSプロジェクトを作成することは非常に簡単です。具体的な手順は次のとおりです : IDEの上部のメニューバーからFile->New->FlywziOS Application Projectを選択します。 先の選択が完了したら、 FlywizOS New Wizardがポップアップされます。新しいプロジェクトを作るのに必要なパラメータを入力します。 Project nameプロジェクトの名前です。数字と文字の組み合わせで作成することができます。 Locationプロジェクトが保存されるパスです。 Platform所有しているボードに合ったプラットフォームを選択してください。 F9311 F9306 上記のパラメータを満たした後、すぐにFinishをクリックすると、プロジェクトが作成されます。しかし、今では、より多くの設定のためにNextを選択します。 Nextをクリックした後、以下のようなパラメータを見ることができます。 プロジェクトの各属性の意味と機能 Screen saver timeout FlywizOSシステムはスクリーンセーバー機能を提供します。もし、特定の時間内にタッチ操作がないか、コードを介してスクリーンセーバーの時間をリセットしない場合、システムは自動的にスクリーンセーバーに入ります。 時間が -1場合スクリーンセーバー機能を使用しないということを意味します。 Serial port通信シリアルポートであり、一般的に変更する必要がありません。 Baud rate通信用シリアルポートのBaud rateです。 Resolutionスクリーンのwidthとheightです。単位はピクセルです。 Screen rotation画面の表示方向を設定することができます。 FontFlywizOSはcustom fontをサポートします。もし基本的なフォントが満足していない場合は、Defaultを解除して使用するフォントを選択することができます。 Input methodもし中国語入力が必要な場合選択してください。そして Edit Textコントロールの中国語入力を解決します。 Don't worry about satisfying this, as the above attributes can be changed again later. (How to change project properties) 入力されたすべてのプロパティを確認し、Finishをクリックすると、プロジェクトの作成が終了します。作成プロセスには、いくつかの時間がかかりますので、しばらくお待ちください。 プロジェクトが作成されると、まず、FlywizOSプロジェクトコード構造を理解する必要があります。 powered by Gitbooklast modified: 2020-12-04 15:43:37 "},"import_project.html":{"url":"import_project.html","title":"プロジェクトのインポート","keywords":"","body":"Import FlywizOS project 現在のワークスペースにダウンロードしたサンプルプロジェクトをインポートすることができます。 その過程は、以下のとおりです。 上部のメニューからFile - >Importを選択します。 ポップアップウィンドウでGeneral - >Existing Project to Workspaceを選択した後Nextを押します。 ポップアップウィンドウでBrowseボタンを押して、インポートするプロジェクトがあるフォルダを選択し、OKをクリックすると、フォルダ内のプロジェクトがポップアップに表示されます。 もしプロジェクトが破損していなかった場合、ポップアップウィンドウには、それぞれのプロジェクトが一覧表示され、インポートするプロジェクトを選択した後、 Finishをクリックすると、 Project Explorerに選択したプロジェクトが追加されます。 以下は例の映像です。 powered by Gitbooklast modified: 2020-12-03 15:10:34 "},"new_flywizOS_ui_file.html":{"url":"new_flywizOS_ui_file.html","title":"新しいUIファイル","keywords":"","body":"新しいFlywizOS UIファイルの作成 新しいUIファイルを生成することは、新しいFlywizOSプロジェクトの作成と似ています。 Project ExplorerでUIファイルを生成しようとするプロジェクトのuiフォルダを右クリックし、ポップアップされるメニューからNew - >FlywizOS UI fileを選択します。 上記の手順を実行すると、New FlywizOS UI File Wizardが下に見えるようにポップアップされます。 ここでは、入力する3つのプロパティがあります。 File nameUIファイルのファイル名を指定する必要があります。ファイル名は、文字と数字で指定され、拡張子はftu（FlywizOS UIファイル）です。 Resolution 解像度をピクセル単位で調整してUIインターフェイスのwidthとheightを制御することができます。 UI Type 現在のウィンドウタイプには、Normal、Status Bar、Navigation Bar、Screensaverがあります。一般的に、Normalが選択され、他の3つのタイプには、システムアプリケーションの概要を参照してください。 プロパティの設定が終わった後、Finishを選択すると、作成プロセスが終了され、project explorerのプロジェクトuiフォルダから、新しく作成されたファイルを見ることができます。 powered by Gitbooklast modified: 2020-12-04 15:52:35 "},"how_to_compile_flywizOS.html":{"url":"how_to_compile_flywizOS.html","title":"プロジェクトのコンパイル","keywords":"","body":"FlywizOS プロジェクトのコンパイル FlywizOSプロジェクトをコンパイルすることは非常に簡単であり、3つの方法でコンパイルすることができます。 1. Project Explorerでコンパイル Project Explorerでコンパイルしようとするプロジェクトを探して選択し、右クリックして、ポップアップされるメニューからCompile Projectを選択すると、自動的にプロジェクトがコンパイルされます。以下は関連動画です。 2. Toolbarでコンパイル IDEの上端部のツールバーにコンパイルショートカットがあります。1と同様にProject Explorerでコンパイルしようとするプロジェクトを探して選択し、そのボタンを押すと、コンパイルが行われます。 プロジェクトを選択した後、緑の三角形のボタンをクリックすると、コンパイルが行われます。 3. ショートカットでコンパイル 最も簡単な方法でコーディング中Ctrl + Alt + Zを押すと、すぐにコンパイルが行われます。 プロジェクトのクリーンアップ プロジェクトをコンパイルした後、一般的に、オブジェクトファイルと一時ファイルが残ります。たとえば、コンパイル時間が短縮のためにlibsとobjフォルダが残ってはっています。 開発者は、これらを手動で削除することもあり、メニューを介して自動的に削除することもできます。 手動削除まず、削除するフォルダを選択して右クリックして、ポップアップされるメニューからDeleteを選択して削除する。 自動削除もし毎回手動で削除する場合は、他の重要なファイルを削除するなどのミスが発生する可能性があります。そのため、自動クリーンアップにこのような状況を防ぐことができます。 同様に、まず、プロジェクトの名前を選択し、右クリックをして、ポップアップされるメニューからClear Projectを選択します。その後、自動的にlibsとobjフォルダが削除されます。（この場合、フォルダ内のファイルは、削除され、フォルダ自体は削除されません。） Note: もしコンパイル中に奇妙な問題が発生したり、プログラムのソースがコンパイルされていない場合、まずClear Projectを実行して、再コンパイルを実行してください。特に、他の人のプロジェクトをインポートしてコンパイルする場合、多くの場合、これらの現象が発生することがあります。 Recompile もしコードを再コンパイルしたい場合は、まずプロジェクトをクリーンアップしてコンパイルをしてください。 powered by Gitbooklast modified: 2020-12-03 14:04:18 "},"run_project.html":{"url":"run_project.html","title":"プロジェクトの実行","keywords":"","body":"プロジェクトの実行方法 プロジェクトが[コンパイル]（how_to_compile_flywizOS.md）を成功した後、実際のボードで実行されるようにすることができます。モデルに応じて、次のようないくつかの動作モードがあります。 WIFIを使用してデバイスを迅速に接続 この方法は、WIFIがあるモデルのみをサポート、現在サポートされているモデルは、次のとおりです。 sw480272043B_CW 4.3인치 sw480272043B_CWM 4.3인치 sw80480043B_CW 4.3인치 sw48854050B_CW 5인치 sw80480070A_CW 7인치 sw80480070A_CWM 7인치 sw80480070AI_CW 7인치 sw80480070AI_CWM 7인치 sw10600070A_CW 7인치 製品モデルの説明 デバイスがWIFIをサポートしていることを確認した後、以下の手順に従って設定を完了してください。 まず、装置のWIFI設定アクティビティに進入して、デバイスをコンピュータと同じWIFIのネットワークに接続します。つまり、コンピュータと機器が同じWIFIに接続されている必要があります。(他のネットワークにある場合は、ダウンロードが失敗することがあります) ワイヤレスネットワーク接続に成功すると、WIFI設定アクティビティの右上隅にあるメニューをクリックして、デバイスのIPアドレスを確認します。 以来、コンピュータのIDEに戻り上部のメニューからFlywizOS - >ADB Configurationを選択し、ポップアップボックスでADB connection methodでNetを選択します。デバイスのIPアドレスを入力して、アプリケーションを保存します。 接続設定が完了したら、ダウンロードおよびデバッグメニュー項目を選択すると、プロジェクトのコードを接続しているデバイスと、一時的に同期して実行することができます。 USB接続デバイスとして、高速動作 WIFI機能がないモデルの場合、ほぼすべてのUSBケーブル接続をサポートします。注：WIFI機能がある場合は、USBケーブルの接続が有効ではありません。 USBケーブルを介し機器をコンピュータに接続します。コンピュータが機器をAndroid端末に認識することができれば、接続は正常です。正常に接続できない場合は、コンピュータにドライバの問題が表示されます。ドライバのダウンロードをお試しください。 コンピュータがデバイスを正しく認識すると、コンピュータのIDEに戻り上部のメニューからFlywizOS - >ADB Configurationを選択し、ポップアップボックスでADB connection methodUSBを選択した後、保存します。 接続設定が完了したら、ダウンロードおよびデバッグメニュー項目を選択すると、プロジェクトのコードを接続しているデバイスと、一時的に同期して実行することができます。 TFカードからのブート 他の理由USBとWIFIの両方を正常に使用することができない、または使用している場合のTFカードを使用してTFカードでプログラムを起動することができます。詳細については、TFカードからプログラムを起動するを参照してください。 powered by Gitbooklast modified: 2020-12-07 15:23:24 "},"project_structure.html":{"url":"project_structure.html","title":"プロジェクト構造の概要","keywords":"","body":"FlywizOSプロジェクトのコードの構造の概要 コードの記述を開始する前に、まずFlywizOSプロジェクトの基本的な構造を理解する必要のコードを追加する必要がある位置を知ることができます。 基本FlywizOSプロジェクトの場合、ディレクトリ構造は次のとおりです。 jni、resources、uiの3つのフォルダに分けられます。各フォルダの役割は、以下に説明されています。 ui폴더 uiフォルダ展開します。 main.ftuファイルは、デフォルトで含まれていることを知ることができます。ftuはFlywizOSプロジェクトUIファイルのサフィックスです。各ftuファイルは、アクティビティに対応します。一般的に、アプリケーションは、複数のアクティビティが含まれていますので、uiフォルダに複数ftuファイルを作成します。 新しいftuファイルを追加するには、新しいFlyThings UIファイルの作成方法を参照してください。説明の便宜のために以降ftuファイルをUIファイルとします。. 더블 클릭하여 UI 파일을 열고 편집하여 즉시 효과를 미리 볼 수 있습니다. UI 파일 편집의 특정 단계는 컨트롤 소개를 참조하십시오. 편집 후 \"compile\"을 시작할 수 있습니다. (컴파일 방법) [!Note] 注：ここに記載されたコンパイルは、ソースコードのコンパイル日だけでなくuiファイルの前処理とテンプレートコードの生成のような一連の作業でもあるが、これらのタスクは、すべて自動化されているので、手動で作業する必要がありません。 コンパイル - この作業のすべての特定のタスクには、コンパイルプロセスとUIファイルとソースコードとの間の相関関係を参照してください。これを読んだ後は、理解しやすくすぐに開始できようになります resources folder このフォルダの内容は、比較的簡単で、主に図、フォント、入力方法の設定ファイルなどを含むプロジェクトのさまざまなリソースファイルを保存するために使用されます。他のリソースファイルがある場合は、このフォルダに追加することもできます。フォルダは、システムに完全にコピーされます。ただし、機器自体の保存スペースの制限で、このディレクトリに大容量のファイルを保存していないことが望ましく、大容量のリソースファイルは、TFカードに保存することをお勧めします。 コードのresourcesディレクトリにあるファイルの絶対パスを取得することができます。 例：次のコードは、resources/test.txtの絶対パスを取得することができます。 #include \"manager/ConfigManager.h\" std::string resPath = CONFIGMANAGER->getResFilePathEx(\"test.txt\"); jni folder このフォルダは、主にコードファイルを保存するために使用されます。jniフォルダを展開します。 上に見えるように、ここでは、activity、include、logic、uart、Main.cpp、Makefileの6つの部分が含まれています。各部分の機能は次のとおりです。 activity subfolder UIファイルの基本クラスのコードを保存します。各UIファイルがコンパイルされた後、同じプレフィックス名を持つActivityクラスとLogic.ccファイルが生成されます。 例：uiフォルダにmain.ftuがある場合、コンパイル後mainActivity.h、mainActivity.cppとmainLogic.ccが生成され、mainActivityクラスがactivityフォルダに保存されます。mainLogic.ccファイルはlogicフォルダに保存されます。 [!Warning] 특별한 상황을 제외하고 activity 폴더 아래의 코드는 수정하지 않는 것이 좋습니다. logic subfolder 特定の論理コードを保存します。上記の説明と同様に、すべてのUIファイルは、コンパイル後、プレフィックスの名前があるLogic.ccファイルを生成します。注：カスタムコードは、主にこれらのLogic.ccファイルに追加されます。 include subfolder システム関連のヘッダファイルと、すべてのコントロールに関連のヘッダファイルは、主にここに保存されます。 uart subfolder 名前が示すように、このフォルダには、シリアルポートの読み取りと書き込み、プロトコル分析などを含むシリアルポートの動作に関連するコードが格納されます。 Main.cpp 起動および開始アクティビティを選択する関数など、全体FlywizOSアプリケーションの初期化コードが含まれ、一般的にファイルを変更する必要がありません。 Makefile/Android.mk、Application.mk 特定のソースコードのコンパイルプロセスを含むコンパイル構成ファイルに、一般的に変更する必要がありません。 コンパイル後libsディレクトリとobjディレクトリがプロジェクトの下に作成されます。このディレクトリは、コンパイルされたターゲットストレージディレクトリと、コンパイルされた一時ファイルのディレクトリであり、両方の直接整理したり、削除することができます。 powered by Gitbooklast modified: 2020-12-07 10:51:38 "},"ftu_and_source_relationships.html":{"url":"ftu_and_source_relationships.html","title":"UIファイルと生成されたコードの説明","keywords":"","body":"FlywizOSのコンパイルプロセスとUIファイルとソースコードの相関関係 UIファイルのコントロールがポインタ変数と接続されている方法 FlywizOSは簡単な管理のためにUIとcodeを分離しました。 下では、UIファイルは、プロジェクトのUIフォルダのすべてのftuファイルです。 開発中のコードの重複を減らすために、FlywizOS IDEは、コンパイルプロセスを改善しました。実際のソースコードをコンパイルする前に、IDEは、まずUIファイルから生成された同じプレフィックス名を持つLogic.ccファイルを生成します。（例えば、main.ftuはmainLogic.ccファイルが生成されます）。ここで、 Logic.ccファイルの生成は、まさに上書きからではなく、徐々に修正されることに注意する必要があります。 コンパイル時、IDEは、各Uiファイルを巡回してUIファイルに含まれているコントロールを読んで、ソースコード上にコントロールするためのポインタ変数を定義し、開発者は、このポインタを利用して、対応するコントロールを制御することができます。このポインタ変数は、UIファイルと同じ接頭辞の名前を持つActivity.cppファイルに定義されます。main.ftuを例に、以下の通りです。 上の図に示すように、すべてのポインタは、static global変数です。そして、それらはすべて同じ命名規則によって生成されました。この命名規則は、コントロールのID名によるポインタ変数の命名規則を参照してください。 そして、上記の図では#include\" logic/mainLogic.cc\"にも注意すべきポイントです。mainLogic.ccはmainActivity.cppに含まれます。開発者は、mainLogic.ccで必要なコーディングをし、すべてのコントロールのポインタ変数を使用することができます。 もしこのポインタたちの初期化に興味がある場合mainActivityのonCreate関数を探してください。 UIファイルとLogic.ccファイルの関係 UIファイルのコントロールがどのようにポインタ変数と接続されるかについて調べてみました。今mainLogic.ccファイルにどのようなものが自動的に生成されるかを知ってみましょう。 もしUIファイルにはコントロールも追加していなかった場合、 mainLogic.ccファイルは以下の通りです。 /** * Register timer * Fill the array to register the timer * Note: id cannot be repeated */ static S_ACTIVITY_TIMEER REGISTER_ACTIVITY_TIMER_TAB[] = { //{0, 6000}, //Timer id=0, period 6 second //{1, 1000}, }; /** * Triggered when the interface is constructed */ static void onUI_init(){ //Add the UI initialization display code here, for example : //mText1Ptr->setText(\"123\"); } /** * Triggered when switching to this interface */ static void onUI_intent(const Intent *intentPtr) { if (intentPtr != NULL) { //TODO } } /* * Triggered when the interface is displayed */ static void onUI_show() { } /* * Triggered when the interface is hidden */ static void onUI_hide() { } /* * Triggered when the interface completely exits */ static void onUI_quit() { } /** * Serial data callback interface */ static void onProtocolDataUpdate(const SProtocolData &data) { } /** * Timer trigger function * It is not recommended to write time-consuming operations in this function, otherwise it will affect UI refresh * Parameter : id * The id of the currently triggered timer is the same as the id at registration * Return : true * Keep running the current timer * false * Stop running the current timer */ static bool onUI_Timer(int id){ switch (id) { default: break; } return true; } /** * Triggered when there is a new touch event * Parameter : ev * new touch event * Return : true * Indicates that the touch event is intercepted here, and the system will no longer pass this touch event to the control * false * Touch events will continue to be passed to the control */ static bool onmainActivityTouchEvent(const MotionEvent &ev) { switch (ev.mActionStatus) { case MotionEvent::E_ACTION_DOWN://Touch press // LOGD(\"event time = %ld axis x = %d, y = %d\", ev.mEventTime, ev.mX, ev.mY); break; case MotionEvent::E_ACTION_MOVE://Touch move break; case MotionEvent::E_ACTION_UP: //Touch up break; default: break; } return false; } 以下は、各関数について説明します。 REGISTER_ACTIVITY_TIMER_TAB[ ] arrayタイマーの登録に使用されます。この構造体の配列は以下の通りです。 typedef struct { int id; // Timer ID, cannot be repeated int time; // Timer interval, unit millisecond }S_ACTIVITY_TIMEER; この配列は、void registerTimer(int id、int time)関数を介してシステムに登録された後、mainActivity.cppのrigesterActivityTimer()関数で参照されます。 void onUI_init()アクティビティの初期化に使用されます。もしUIアクティビティの起動時に初期化が必要なコンテンツがある場合は、この関数にコードを追加することができます。 この関数は、mainActivity.cppのonCreate()関数で呼び出されます。 void onUI_quit()アクティビティの終了に使用されます。もしUIアクティビティの終了時にどのような作業が必要な場合は、この関数にコードを追加することができます。 この関数は、mainActivity.cppの破壊者で呼び出されます。 void onProtocolDataUpdate(const SProtocolData &data)シリアルポートのデータの受信に使用されます。シリアルデータフレームが解析された後、この関数が呼び出されます。 この関数は、mainActivity.cppのonCreate()でvoid registerProtocolDataUpdateListener(OnProtocolDataUpdateFun pListener)を使用して登録され、mainActivity.cppの破壊者で登録解除されます。詳細は、シリアルフレームワークを参照してください。 bool onUI_Timer(int id)タイマーコールバック関数です。登録されたタイマーのタイマー周期が到達したとき、システムによって呼び出されます。 タイマーが複数登録されたならば、idパラメータで、各タイマを区別することができます。このidは REGISTER_ACTIVITY_TIMER_TAB[] arrayに登録されたidと同じです。Return true このタイマーを維持 Return false このタイマーを停止falseを返して、タイマーを停止した場合はどのように再起動しますか？タイマーを任意に開始および停止する方法を参照してください。 bool onmainActivityTouchEvent(const MotionEvent &ev)タッチイベントのコールバック関数です。すべてのタッチのメッセージを受信できます。 mainActivity.cppのregisterGlobalTouchListenerを介して登録され、登録が完了した後になってようやくタッチイベントが受信されます。Returning true タッチイベントがもう他のコントロールに渡されません。 Returning false タッチイベントが継続的に他のコントロールに渡されます。タッチイベントの処理の理解を参照してください。 以上は、基本的なUIのファイルがコンパイルされるときに自動的にLogic.ccファイルに生成されます。UIファイルにコントロールを追加し、コンパイルをする場合は、IDEは、該当するLogic.ccに異なるコントロールと関連付けられている関数を自動的に生成します。예를 들어, main.ftu UI 파일에 2 개의 단추 컨트롤을 추가하고 각 ID를Button1와Button2로 만들어 컴파일하면 아래의 두 가지 기능이 mainLogic.cc 파일 작성됩니다. static bool onButtonClick_Button1(ZKButton *pButton) { //LOGD(\" ButtonClick Button1 !!!\\n\"); return false; } static bool onButtonClick_Button2(ZKButton *pButton) { //LOGD(\" ButtonClick Button2 !!!\\n\"); return false; } 関数の名前に注意してください。関数の名前は、コントロールのIDが含まれており、コントロールのIDは、C言語のネーミング標準に準拠する必要があります。もし継続的にコントロールを追加する場合は、追加されたコントロールに関連する関数は、コンパイル後にmainLogic.ccに生成されます。 一般的に開発している間に、UIファイルでコントロールの追加/削除/修正が非常に頻繁に起こるが、このような状況ではIDEは、以下のように動作します。 コントロールを追加する場合 - IDE는 컴파일시 컨트롤의 ID에 따라 관련 함수를 작성하는데, 만약 같은 함수가 이미 존재하는 경우는 그 과정을 건너 뛰고 Logic.cc 파일은 변경되지 없습니다. コントロールを削除する場合 - UIファイルに存在するコントロールを削除しても関連する関数は削除されません。もし関連する関数も削除であれば、意図していないコードの損失が発生することができ、FlywizOS IDEは削除しないことを決定しました。 コントロールを変更する場合 - 生成されたコントロール関連の関数は、唯一のコントロールのIDとのみ関連があります。もしUiファイルでコントロールのID以外のプロパティを変更する場合、これに関連する関数には影響を与えません。 もしコントロールのIDを変更した後、コンパイルをするなら、新たにコントロールを追加するのと同じプロセスが進行して、既存の関連する関数は維持されます。 この章では、唯一のボタンコントロールに関連する例としてUIファイルのコントロールとLogic.ccに生成された関連する関数の関係についてのみ説明しました。FlywizOSはまた、他のコントロール（ex。Slide Bar、List、Slide Windowsなど）にも関連する関数を提供しています。詳細、他のコントロールに関連する関数について知りたい場合は、コントロールによって自動的に生成された関数の関係の説明を参照してください。 最後に、下の図は、ftuファイルとコードの間の相関関係を示す概略図である。 powered by Gitbooklast modified: 2020-12-03 11:36:26 "},"named_rule.html":{"url":"named_rule.html","title":"コントロールの名前付け規則","keywords":"","body":"Naming ルール UIファイルに追加したほとんどのコントロールは、コンパイル後の関連ポインタ変数とマクロIDが自動的に生成されます。 コントロールIDとポインタ変数の名前のためのNamingルール ポインタ変数の名前は、それぞれ固定された小文字prepixm+IDの値+Ptrの三つのパートで構成されます。 IDで Textview1を持つコントロールを例に説明します。 コンパイル後に生成されるポインタ変数の名前は、mTextview1Ptrです。 ポインタ変数のclassは、コントロールによって決定されます。各コントロールに対応するポインタclassは以下の通りです。（プロジェクトのjni/ includeフォルダで、各classのヘッダファイルを見つけることができます。） Control name Class name ZKQRCode ZKEditText ZKButton ZKTextView ZKSeekBar ZKPointer ZKCircleBar ZKDigitalClock ZKVideoView ZKCameraView ZKWindow ZKListView ZKSlideWindow ZKDiagram コントロールIDとmacro definitionのnamingルール このmacro definitiondは、UIファイルでコントロールのマッピング関係を示します。 Macro definitionは、固定された大文字ID、大文字UIファイル名、コントロールID propertyの値の3つの部分で構成されます。 IDをTextview1と持つコントロールの例をみましょう。 コンパイル後、生成されたmacro statementは #define ID_MAIN_TextView150001です。 [!Warning] Macro definitionの値を変更しないでください。非正常動作の原因になることがあります。 コントロールによって生成される関連関数 特定のコントロールは、関連付けられている関数を自動的に生成します。以下は、これらのコントロールによって自動的に生成された関数について説明します。 [!Note] 関数でXXXXは、コントロールのID値です。 Button コントロール static bool onButtonClick_XXXX(ZKButton *pButton) { return false; } ボタンがクリックされると呼び出される関数です。 パラメータZKButton* pButtonはクリックされたボタンのポインタであり、ポインタのメンバ変数を使用して、一連のoperationを行うことができます。このポインタは、グローバル変数mXXXXPtrが指すオブジェクトと同じオブジェクトのポインタです。 Edit Text コントロール static void onEditTextChanged_XXXX(const std::string &text) { } Input boxが変更されたとき、システムによって自動的に呼び出される関数です。 パラメータstd::string＆textは、現在Input boxのcontentsです。 Seek Bar コントロール static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress) { } Seek Barのプログレス値が変更されると、システムによって自動的に呼び出される関数です。 パラメータZKSeekBar* pSeekBarはSeek Barのポインタ変数であり、ポインタのメンバ変数を使用して、一連のoperationを行うことができます。 パラメータint progressは、現在Seek Barのプログラス値です。 Slide window コントロール static void onSlideItemClick_XXXX(ZKSlideWindow *pSlideWindow, int index) { } Slide windowコントロールのアイコンがクリックされたとき、システムによって自動的に呼び出される関数です。 パラメータZKSlideWindow* pSlideWindowはSlide windowコントロールのポインタ変数であり、ポインタのメンバ変数を使用して、一連のoperationを行うことができます。 パラメータint indexは、現在クリックされたアイコンのindex値です。たとえば、Slide windowに合計10個のアイコンを追加した場合index値の範囲は[0、9]です。 List コントロール リストコントロールは、最も複雑なコントロールで三つの関連関数を生成します。しかし、多くの関数がありますが、次の手順に従えば簡単に理解することができます。 まず、もしシステムがリストコントロールを描画たい場合、どのように多くのアイテムがあるか知る必要があります。以下はそれに関連する関数です。 static int getListItemCount_XXXX(const ZKListView *pListView) { return 0; } パラメータconst ZKListView* pListViewはListコントロールのポインタであり、グローバル変数mXXXXPtrと同じオブジェクトを指します。 戻り値は整数であり、リストにあるアイテムの数を示し、必要に応じて決定されます。 システムがリストのアイテム数を知っているたが、これだけでリストを描画には不足して、各アイテムにどのようなコンテンツをピョヒすべきかも知っている。だから下の関数があります。表示するアイテムの数だけ下の関数が呼び出され、表示する内容を設定することになります。 static void obtainListItemData_XXXX(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { //pListItem->setText(index) } パラメータZKListView* pListViewはListコントロールのポインタであり、グローバル変数mXXXXPtrと同じオブジェクトを指します。 パラメータZKListView:: ZKListItem* pListItemは、リストアイテムのポインタであり、UIファイルのItemに対応します。 パラメータint indexは全体のリストからpListItemのindex値です。例: getListItemCount_XXXX関数の戻り値が10という意味ではリストに10個のアイテムがあり、index値の範囲が[0、9]ということです。pListItemとindexを接続して、全体のリストから任意のアイテムを設定する必要があるか知ることができます。 この関数ではindexに基づいて、各アイテムに表示されるコンテンツが設定されることがあります。 ボタンコントロールと同様に、リストコントロールもクリックイベントのための関数を持っており、index値に基づいて、現在どのようなアイテムがクリックされたかを判断します。 static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); } リストコントロールがクリックされると、システムは、クリックされた位置に対応するアイテムのindex値を計算して、自動的にこの関数を呼び出します。 パラメータZKListView* pListViewはListコントロールのポインタであり、グローバル変数mXXXXPtrと同じオブジェクトを指します。 パラメータint indexは全体のリストコントロールで現在クリックされたアイテムのindex値です。 パラメータint idは、現在クリックされたコントロールのIDです。このIDは、propertiesのIDと異なるので注意してください。 これに対するmacro definitionは、対応するActivity.hファイルにあります。mainActivity.hを例に示します。このIDは、list itemに複数のsubitemがある場合は、現在クリックされたsubitemがどんなものかを区別するために使用することができます。例： 下の図に示すように、list itemにスイッチイメージが配置された2つのsubitemが追加されており、それぞれのproperty IDはSubItem1とSubItem2です。SubItem1がクリックされたとき、パラメータidと ID_MAIN_SubItem1そしてID_MAIN_SubItem2の関係で判断されるものでいくつかのスイッチがクリックされたかを決定することができます。 static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); switch(id) { case ID_MAIN_SubItem1: //LOGD(\"Clicked the first subitem of item %d in the list\", index); break; case ID_MAIN_SubItem2: //LOGD(\"Clicked the second subitem of item %d in the list\", index); break; } } 最後に、図を用いて、それらの間のルールを要約してみましょう。 他のコントロールもこれと同じです。 powered by Gitbooklast modified: 2020-12-04 15:18:20 "},"editor_tip.html":{"url":"editor_tip.html","title":"共通スキルと開発ツール","keywords":"","body":"開発ツールのための共通の設定に 関連する関数に移動 UIファイルにあまりにも多くのコントロールを追加したとき、Logic.ccファイルも多くの関連する関数が生成され、これは特定のコントロールに関連する関数を探したいときは、多くの時間を消費するしかありません。 しかし、幸いなことにFlywizOS IDEは急速にコントロールに関連するコードを探しに行くことができる機能をサポートします。 UIファイルのエディタ画面でコントロールを選択し、右クリックでポップアップされるメニューの中Goto relative codeをクリックすると、該当するLogic.ccファイルの関連する関数に直接移動します。 Note : この機能は、コントロールが自動的に生成された関数を持っている場合にのみ有効です。 フォントの変更 上部メニューからWindow - >Preferences選択します。 ポップアップメニューから次の図のようにフォントを変更可能です。 コードの自動補完 コーディング時にユーザーが先頭を入力して、「Ctrl + Space」キーを押すと、コード補完機能が実行されます。 下の図のようにUAを入力した後、「Ctrl + Space」キーを押すと、複数の入力のオプションがポップアップされ、キーボードのアップ/ダウンキーを利用して、必要なオプションを選択して、Enterキーを押すと、コードが自動的に完成します。 再 - インデックス もしコードの自動補完機能が失敗したり、エディタでコードエラーが見えますが、何の問題もなくコンパイルがされている場合、再 - インデックス機能を使用してください。 再 - インデックスをする方法は以下の通りです。 powered by Gitbooklast modified: 2020-12-03 09:58:01 "},"ctrl_common.html":{"url":"ctrl_common.html","title":"共通属性","keywords":"","body":"共通属性 それぞれのコントロールを導入する前に、コントロールの基本的な共通属性と設定値を説明します。 コントロールID IDは、コントロールの一意の識別子です。各ftuファイル内で重複したIDを許可していません。他のftuファイル間、同じIDを許可します。 IDを設定した後、コンパイルするとftuファイルに対応するactivityのヘッダファイルが生成され、対応するヘッダーファイル内のコントロールのIDが定義されます。 コントロールからIDの取得 /** * The interface is defined in the control base class \"ZKBase\" * Header file location: include/control/ZKBase.h * * Note: The following interfaces, unless otherwise specified, mean that all controls defined in the ZKBase class directly or * indirectly inherit the ZKBase class, so all controls can call the public interface in the ZKBase class */ int getID() const; /* Operation example: Click the button control to print the ID value of the control */ static bool onButtonClick_Button1(ZKButton *pButton) { int id = pButton->getID(); LOGD(\"onButtonClick_Button1 id %d\\n\", id); return false; } コントロールの位置 ftuファイルから任意のコントロールを選択すると、プロパティウィンドウのLocationを介してコントロールが表示される位置を決定することができます。 左上隅の座標は、上位のコントロールの左上隅を基準にします。 コントロールの座標は、コードからも設定するか、現在設定された座標を得て来ることができます。 /* Interface description */ // Set location void setPosition(const LayoutPosition &position); // Get location const LayoutPosition& getPosition(); /* Operation esample */ // Click the button control to set the button position static bool onButtonClick_Button1(ZKButton *pButton) { // left：0，top：0，width：100，height：200 LayoutPosition pos(0, 0, 100, 200); pButton->setPosition(pos); return false; } // Click the button control to get the button position static bool onButtonClick_Button2(ZKButton *pButton) { // The mLeft, mTop, mWidth, and mHeight variables of pos correspond to the coordinate values respectively. LayoutPosition pos = pButton->getPosition(); return false; } 背景色 比較的簡単です。色を変更して、効果を確認してください。 ここでは、背景色を設定するコードです。 /* When color is -1, the background is set to transparent; other color values are 0xRGB, and the color value does not support alpha */ void setBackgroundColor(int color); /* Operation example : Click the button control and set the background color to red */ static bool onButtonClick_Button1(ZKButton *pButton) { pButton->setBackgroundColor(0xFF0000); return false; } 背景画像 画像を選択すると、ツールから直接確認が可能です。 ここでのコードを使用して、背景画像を設定する方法を説明します。 /** * The pPicPath parameter can have the following two ways : * 1. The absolute path, such as : \"/mnt/extsd/pic/bg.png\" * 2. Relative resource directory path, you only need to put the picture in the resources directory of the project, after * compiling, you can use it. If there is a bg.png picture in the resource directory, just set \"bg.png\". */ void setBackgroundPic(const char *pPicPath); /* Operation example */ mButton1Ptr->setBackgroundPic(\"/mnt/extsd/pic/bg.png\"); // Set the absolute path mButton1Ptr->setBackgroundPic(\"bg.png\"); // Set the bg.png picture in the resource directory 表示/非表示 コントロールの既定の状態を表示または非表示に設定することができます。 Outlineウィンドウで、コントロールをダブルクリックすることで、このプロパティを変更することができます。 さらにコードからも表示/非表示のプロパティの変更が可能です。 void setVisible(BOOL isVisible); BOOL isVisible() const; /* Operation example */ mButton1Ptr->setVisible(TRUE); // Show the button control mButton1Ptr->setVisible(FALSE); // Hide the button control /** * Window controls can also use the following interface, the same function * Header file location : include/window/ZKWindow.h */ void showWnd(); // Show window void hideWnd(); // Hide window bool isWndShow() const; // Whether the window is displayed /* Operation example */ mWindow1Ptr->showWnd(); mWindow1Ptr->hideWnd(); コントロールステート テキスト、ボタン、リストビューコントロールは、5つのステート（Normal/ Pressed/ Selected/ Pressed and Selected/ Invalid state）を持っており、ここでは、各ステートについて説明します。 Pressedステートは別にコードで設定する必要がなく、タッチを介して自動的に変更されます。 以下はSelectedとInvalidステートの動作例です。 // Set selected state void setSelected(BOOL isSelected); BOOL isSelected() const; /* Operation sample */ mButton1Ptr->setSelected(TRUE); mButton1Ptr->setSelected(FALSE); /** * Invalid state function description: when the control is set to the invalid state, the touch control has no effect, that is, * it does not respond to the press and lift event */ // Set invalid state void setInvalid(BOOL isInvalid); BOOL isInvalid() const; /* Operation example */ mButton1Ptr->setInvalid(TRUE); mButton1Ptr->setInvalid(FALSE); 例の説明 以下の簡単な例を、共通の属性に関連する関数について説明します。 1. コントロールの作成 まず、新しいFlywizOSプロジェクトを作成し、プロジェクトエクスプローラでuiフォルダのmain.ftuファイルをダブルクリックして開きます。そして右側のコントロールボックスのボタンコントロールとテキストコントロールをmain.ftuにドラッグしてコントロールを作成します。 2. プロジェクトのコンパイル （詳細は、\"FlywizOSプロジェクトのコンパイル」参照してください） 3. コントロールのプロパティ関数の呼び出し コンパイルが終わった後、プロジェクトのjni/ logic/ mainLogic.ccを開くと、ファイルの下端部にonButtonClick_Button1関数が生成されたことを確認することができます。 この関数getID()関数を呼び出して、Button1ボタンコントロールのID値を取得し、setText()関数を呼び出してTextView1テキストコントロールに表示します。 （コントロールIDとコントロールのポインタ変数の関係について、より詳しく知りたい場合は、こちらをクリックしてください。） 4. ダウンロードとデバッグ Project explorerで、プロジェクト名を選択し、右クリックし、ポップアップメニューからDownload and Debugを選択すると、プログラムがボードにダウンロードされ、実行されます。プログラムの実行後、ボタン（Button1コントロールのボタン）テキストコントロールにボタンのIDである20001が表示されることを確認します。 Note : 共通属性の設定関数についての詳細を知りたい場合は、/jni/include/control/ZKBase.hファイルを参照してください powered by Gitbooklast modified: 2020-12-02 16:26:49 "},"textview.html":{"url":"textview.html","title":"Text","keywords":"","body":"Text Viewコントロール Note テキストの共通プロパティを変更する方法がわからない場合は、\"共通のプロパティ\"を参照してください。 テキスト/ラベルを表示する必要があります。どうすればよい？ テキストを表示する必要がある場合、既存のText viewに迅速に実装できます。具体的な手順は次のとおりです。 ダブルクリックしてmain.ftuファイルを開きます。 右コントロールボックスでText Viewコントロールを検索します。 Text Viewコントロールでマウスの左ボタンをクリックして、目的の場所にドラッグして、左ボタンを離すと自動的に生成されたText Viewコントロールを見ることができます。 コードを使用して、テキストコンテンツを動的に更新する方法 シリアルポートLCDを使用する場合Text Viewのコンテンツは、多くの場合、動的に更新されます。次に、コードでText Viewコントロールに対応するポインタを介してText Viewコントロールの内容を動的に更新することができます。具体的な手順は次のとおりです。 まず、コード内のテキストコントロールに対応するポインタ変数を知る必要があります(UIファイルのコントロールIDに対応するコントロールのポインタ変数の命名規則がわからない場合は、こちらをクリックして)、ここでIDがTextview1のText Viewがあります。このコントロールを例に挙げてみると、そのポインター変数はmTextview1Ptrです。 Textview1コントロールのテキストの内容を\"Hello World\"で変更するには、テキストコントロールのメンバ関数void setText(const char* text)を呼び出して実行することができます。そのLogic.ccファイルで、具体的なコードは次のとおりです。mTextview1Ptr->setText(\"Hello World\"); 実際の使用例 : 次のコードの機能は次のとおりです：IDがButton1のボタンを押すと、IDがTextview1あるText Viewのコンテンツが「Hello World」に設定されます。static bool onButtonClick_Button1(ZKButton *pButton) { mTextview1Ptr->setText(\"Hello World\"); return false; } 文字列の設定のほか、Text Viewコントロールは、数字と文字設定もサポートします。 /* function definition header file: include/control/ZKTextView.h */ void setText(int text); // set number void setText(char text); // set character /* Operation example */ mTextview1Ptr->setText(123); // Textview1 control will display the string \"123\" mTextview1Ptr->setText('c'); // The Textview1 control will display the'c' character テキストの色を変更する方法 デフォルトのテキストは白で、下記の二つの方法でテキストの色を変更することができます。 プロパティウィンドウで直接コントロールの色を変更します。 Project explorerでUIファイルを選択し、ダブルクリックして開きます。 プレビューインターフェースで変更コントロールを見つけ、マウスの左ボタンでクリックすると、エディタの右側で、コントロールのプロパティウィンドウを表示することができます。この時、必要に応じて属性の値を入力することができます。Excelと同様に修正する必要がある属性を検索し、クリックして変更します。 Text Viewコントロールでは、色に関する3つの属性項目があることを見ることができます。 Foreground Colors このプロパティは、コントロールの各状態でのテキストの色値を個別に設定することができます。 Background color コントロールの全体矩形領域の背景色を設定します（コントロールの状態に応じて変更されません）。 Background colors 背景色属性の拡張、コントロールの各状態の背景色を個別に設定することができます。 具体的な例： プレビュー： 上の図は、[プロパティ]ウィンドウの色の部分のスクリーンショットで意味は、背景色が黒、テキストの色が白に設定されています。コントロールが選択された状態に設定されると、テキストの色が赤に変更されます。 コードを使用した色を変更する 属性テーブルで色を設定することは、直感的で便利ですが、柔軟性が不足してコードでコントロールのポインタとそのメンバ関数を使用して色を動的に変更することができます。 IDTextview1のText Viewコントロールを例にとると、次のような方法で色を変更することができます。(UIファイルのコントロールIDに対応するコントロールのポインタ変数の命名規則がわからない場合は、こちらをクリックして) void setInvalid(BOOL isInvalid) //Set the control Textview1 to the invalid state; if the `color when invalid` property in the propert table is not empty, //set it to the specified color, otherwise there is no change. mTextview1Ptr->setInvalid(true); void setSelected(BOOL isSelected) //Set the control Textview1 to the selected state; if the `color when selected` property in the property table is not //empty, set it to the specified color, otherwise there is no change. mTextview1Ptr->setSelected(true); void setPressed(BOOL isPressed) //Set the control Textview1 to the pressed state; if the `color when pressed` property in the property sheet is not empty, //set it to the specified color, otherwise there is no change. mTextview1Ptr->setPressed(true); void setTextColor(int color) //The parameter color represents RGB color in hexadecimal. //Set the control Textview1 to red. mTextview1Ptr->setTextColor(0xFF0000); 素数を表示する方法 Text Viewコントロールは、文字列を設定するためのインタフェースを提供します。 /** * @brief Set string text */ void setText(const char *text); 数字を表示するには、まず「snprintf」関数を使用して数値を文字列にフォーマットして、Text Viewコントロールに設定することができます。 例 : float n = 3.1415; char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%.3f\", n); //Fixed display 3 decimal places, extra decimal places will be ignored, if not enough, //0 will be added mTextView1Ptr->setText(buf); snprintfは、C言語の標準関数で、インターネット上の関連情報を検索したり、ここで簡単な紹介と使用例で確認することができます。 アニメーションの実装 Text Viewコントロールは、背景画像を追加することができますので、単純に画像を表示するためにも使用することができます。さらに一歩進んで、コードでText Viewコントロールの背景画像を動的に切り替えて切り替え時間間隔を十分に短くすれば、アニメーション効果を得ることができます。 画像データを準備滑らかなフレームアニメーションには必ず複数の画像リソースが必要です。ここでは、合計60個を用意しました。 各画像は、フレームを表し、シリアル番号に基づいて名前が均一に指定されて、主に連続的に使用する容易にしたものであることがわかります。 Note: システムは、イメージをロードする際に、より多くのリソースを消費するので、アクティビティを円滑に実行するには、写真が大きすぎないようにしてください。たとえば、例の1つの画像の大きさは、約5KBです。 このイメージを、プロジェクトのresourcesディレクトリにコピーします。resourcesディレクトリの下にサブフォルダを作成し、さまざまなイメージリソースを簡単に構成し、分類することができます。 Text Viewコントロールの作成UIファイル内の任意のText Viewコントロールを作成します。そしてText Viewコントロールの背景画像を画像のいずれかに設定します。ここの最初の画像を背景画像に設定しました。この手順は、Text Viewコントロールのwidthとheightをイメージのwidthとheightに合わせて調整することです。設定しないように選択することもできます。以下は全体の属性です。 プロジェクトをコンパイル、タイマー登録Text Viewコントロールを追加した後、プロジェクトを再コンパイルして生成されたLogic.ccファイルにタイマーを登録して時間間隔を50msに設定します。タイマーを使用して50ms毎に画像を切り替えます。プロジェクトのコンパイル方法タイマーの登録方法 Text Viewコントロールの背景を動的に切り替えるそのLogic.ccファイルに次の関数を追加して、背景画像を切り替えて、タイマートリガ関数bool onUI_Timer(int id)で呼び出されます。 static void updateAnimation(){ static int animationIndex = 0; char path[50] = {0}; snprintf(path, sizeof(path), \"animation/loading_%d.png\", animationIndex); mTextviewAnimationPtr->setBackgroundPic(path); animationIndex = ++animationIndex % 60; } 上記の機能には、注意しなければなら2点があります。 テキストコントロールの背景画像の切り替えはsetBackgroundPic(char* path)関数で実装されます。 setBackgroundPic(char* path)関数のパラメータは、図の相対パスです。パスは、プロジェクトのresourcesフォルダへの相対です。 例：下の図のように、プロジェクトのresources/animation/フォルダに画像が配置され、このloading_0.pngの相対パスは、animation/loading_0.pngです。 setBackgroundPic(char* path)関数は、絶対パスを許可することもできます。例：画像example.pngをTFカードのルートディレクトリに入れる場合、その絶対パスは/mnt/extsd/example.pngです。ここで/mnt/extsd/はTFカードのルートです。 別のパスのイメージリソースは、ソフトウェアに自動的にパッケージングされませんすべての画像リソースは、プロジェクトのresoourcesフォルダまたはサブフォルダに配置してください。 ダウンロードと実行して、結果を確認してみましょう。 画像の文字セットを使用 asciiコードの定義によると、character charとinteger intの間には相関関係があります。たとえば、文字'0'のasciiコードは「48」です。画像の文字セットはasciiコードを画像にマッピングする機能です。この機能を設定した後の文字列を表示するときに、システムは、文字列の各文字を指定されたイメージにマッピングして、最終的に画面に画像の文字列を表示します。 設定方法 Text ViewコントロールでPicture Character Setを見つけて右のmoreオプションをクリックすると、画像の文字セットの選択ボックスが表示されます。 右上のImportボタンを選択して画像を文字セットに追加します。画像を追加した後、asciiコードまたは文字を画像のマッピング文字で変更することができます。次にSaveをクリックします。 画像の文字セットが正常に追加されたことを確認するために、テキストを変更すると、プレビューでその効果を確認することができます。注：画像の文字セットを設定すると、システムは、各文字を文字セットに指定されたイメージにマッピングしようとします。文字が画像に設定されていない場合、この文字は、画面に表示されません。 使い方 上の画像の文字セットの設定]ボックスで、私たちは、文字0-9とコロンをそれぞれイメージにマッピングしました。 次に、コードでsetText(char* str)関数を使用して文字列を設定します。TextTime Text Viewコントロールで画像の文字セットを設定したので、文字は、その画像に変換されます。 static void updateTime() { char timeStr[20]; struct tm *t = TimeHelper::getDateTime() sprintf(timeStr, \"%02d:%02\", t->tm_hour, t->tm_min); mTextTimePtr->setText(timeStr); } 単一の文字だけを表示する必要がある場合、asciiコードまたは文字を文字列に変換せずに直接設定することができます。例 : mTextTimePtr->setText((char)48); //Set the ascii code directly, it needs to be //converted to char mTextTimePtr->setText('0'); //Set character directly Sample code 詳細については、Sample codeのTextViewDemoプロジェクトを参照してください。プレビュー : powered by Gitbooklast modified: 2020-12-08 11:13:16 "},"button.html":{"url":"button.html","title":"Button","keywords":"","body":"Button ボタンを追加し、プロパティの変更 プロジェクトウィンドウでボタンを追加しようとするアクティビティのUIをダブルクリックします。 右側のコントロールボックスでButtonコントロールを選択します。 Buttonコントロールを左クリックした後、目的の場所をクリックするか、ドラッグアンドドロップすると、コントロールが作成されます。 作成されたボタンを左クリックすると、プロパティウィンドウで、ボタンに関連するプロパティを確認し、変更することができます。 ボタンの色を変更 「テキストと色の変更」を参照してください。 ボタンにアニメーション効果を追加 \"ボタンの状態に応じた画像を追加\"を参照してください。 ボタンの状態に応じた画像を追加 デフォルトボタンコントロールの色は単色であるが、ユーザーが希望する画像などを追加することができ、以下はその方法です。 まず、UIファイルにボタンを追加します。 追加されたボタンを左クリックして、プロパティウィンドウを開きます。 イメージと関連した属性は下記の通りです。 Picture settings この属性は、ボタンのそれぞれの状態に応じた画像を設定することができて、ボタンの状態が変わると自動的にそのイメージに変更されます。 Picture location 基本的にはボタンに設定された画像は、ボタンの中央を基準に拡大/縮小され、ボタンと同じサイズに変更されるが、この属性は、画像をボタンの特定の場所に特定のサイズに位置させることができます。 Background picture ボタンの背景画像を設定します。画像は自動的にボタンのサイズだけ拡大/縮小されて表示されます。 例： 結果の画像 : 上記のスクリーンショットは、プロパティウィンドウのパラメータの値を示し、それの意味は次のとおりです。 ボタンは、基本的に「off_normal.png」を表示し、選択されたとき、「on_normal.png」に変更されます。 left、top、width、heightは画像の表示位置（ピクセル単位）を決定します。長方形の左上隅が開始点（0、0）であり、右/下方向に値が増加し、（131、63）が終了点です。もし画像の実際のwidthとheightが[プロパティ]ウィンドウのパラメータの値と異なる場合、画像は、その属性の値に基づいて拡大/縮小されます。 ボタンコントロールとの間の階層関係 一般的に、ボタンコントロールは4段階の過程を経て表示されます。 ボタンのテキスト ボタンの画像 ボタンの背景画像 ボタンの背景色 ボタンに画像を追加 \"ボタンの状態に応じた画像を追加\"参考 ボタンが押されたとき、どこで、どのようにコードを追加しますか？ 実際の開発ではボタンは非常に頻繁に使用されるコントロールの一つです。通常のボタンのクリックイベントが発生した後のUI画面の内容が更新されるなどの処理が行われます。このため、ボタンがクリックされたときの応答を処理する過程が必要であり、下はこれに対するプロセスです。 まず、IDがButton1のボタンを作成します。 プロジェクトエクスプローラで、現在のプロジェクトを選択し、右クリックして表示されるポップアップメニューの中Compile Projectを選択します。 この機能は、UIファイルに基づいて自動的にテンプレートコードを生成します。（コード生成の詳細な理解） UIファイルmain.ftuを例にとると、前のプロセスが終了した後、jni/ logic/ mainLogic.ccファイルが現在のプロジェクトフォルダに以下のように生成されます。 Note : main.ftuで自動生成されたmainLogic.cc、両方のファイルのprefixesは同じです。（コード生成の詳細な理解） mainLogic.ccをダブルクリックして開いたら、ファイルに以下のコードがあることを確認することができます。 static bool onButtonClick_Button1(ZKButton *pButton) { //LOGD(\" ButtonClick Button1 !!!\\n\"); return false; } スクリーンで生成されたボタンをクリックすると、自動的に上記の関数が呼び出されます。したがって、この関数にコードを追加することで、ユーザーは自分だけのプロセスを追加することができます。 関数の名前は、特定のルールに基づいて生成されることを確認することができ、上記の例のように生成された関数の名前はonButtonClick_XXXX(ZKButton* pButton)でXXXXは、コントロールのIDで置き換えられます。 コントロールと関数の関係についての理解 システムボタン ユーザーが定めたIDに加えて、ボタンコントロールは、2つのシステムボタンIDを持っているが、sys_backとsys_homeがまさにそれです。名前からおおよそその機能を知ることができるようバックとホーム機能のためのIDです。 sys_backボタンをクリックすると、直前アクティビティに戻り、sys_homeをクリックすると、「mainActivity」に直接戻り、特別な追加実装せずにIDの値だけ、システム名に設定することで機能がサポートされます。 アクティビティ間の相互作用についての理解 Long keyイベント処理 もしlong keyイヴェットを処理する必要がある場合は、直接、イベントリスナーを追加する必要があります。以下はその過程です。 ボタンコントロールのプロパティ]ウィンドウでLong Click TimeoutとLong Click event trigger interval timeを次の図のように設定します。（単位：ミリ秒） プロパティの設定後、コンパイルをして、そのファイルのLogic.ccファイルを開いて、ファイルの先頭にZKBase:: ILongClickListenerクラスを継承するclass LongClickListenerと virtual void onLongClick(ZKBase* pBase)関数を実装します。 namespace { // Add an anonymous scope to prevent multiple source files from defining the same class name and conflict at runtime //Realize the long press monitoring interface class LongClickListener : public ZKBase::ILongClickListener { virtual void onLongClick(ZKBase *pBase) { LOGD(\"Trigger long press event\"); static int count = 0; char buf[128] = {0}; snprintf(buf, sizeof(buf), \"Long press event trigger times %d\", ++count); //Each time a long press event is triggered, modify the text of the button mLongButtonPtr->setText(buf); } }; } class LongClickListenerのオブジェクト生成 static LongClickListener longButtonClickListener; static void onUI_init()関数でlong clickモニタリングインターフェイスを登録する関数を追加 static void onUI_init(){ //Register the button long press monitoring interface mLongButtonPtr->setLongClickListener(&longButtonClickListener); } static void onUI_quit()関数にlong clickモニタリングインターフェイスを登録解除する関数を追加 static void onUI_quit() { //Un-register the button long press monitoring interface mLongButtonPtr->setLongClickListener(NULL); } コードの追加後、コンパイル、ダウンロードしてボードでテストしてください。もしボタンのテキストが変更された場合、 onLongClick関数が正常に動作したことを意味します。 実装の詳細は、サンプルコードを参照してください。 ボタンタッチイベントの処理 もしボタンコントロールにpressまたはliftイベントへの応答が必要な場合は、タッチモニターのインターフェイスを登録して行うことができます。以下はサンプルコードです。 ユーザーだけのタッチモニターインターフェイスの実装 namespace { // Add an anonymous scope to prevent multiple source files from defining the same class name and conflict at runtime // Implement touch monitoring interface class TouchListener : public ZKBase::ITouchListener { public: virtual void onTouchEvent(ZKBase *pBase, const MotionEvent &ev) { switch (ev.mActionStatus) { case MotionEvent::E_ACTION_DOWN: mTouchButtonPtr->setText(\"Press\"); break; case MotionEvent::E_ACTION_UP: mTouchButtonPtr->setText(\"Lift\"); break; default: break; } } }; } リスナーオブジェクトの作成 static TouchListener sTouchListener; static void onUI_init()関数にタッチモニタリングインターフェイス登録コードを追加 static void onUI_init() { //Register the button touch monitoring interface mTouchButtonPtr->setTouchListener(&sTouchListener); } static void onUI_quit()関数にタッチモニタリングインターフェイスの登録を解除するコードを追加 static void onUI_quit() { //Un-register the button touch monitoring interface mTouchButtonPtr->setTouchListener(NULL); } コードの追加後、コンパイル、ダウンロードしてボードでテストしてください。 実装の詳細は、サンプルコードを参照してください サンプルコード サンプルコードのButtonDemoプロジェクトを参照してください プレビュー画面 : powered by Gitbooklast modified: 2020-12-02 15:17:59 "},"checkbox.html":{"url":"checkbox.html","title":"Checkbox","keywords":"","body":"チェックボックス チェックボックスコントロールの基本は、ボタンコントロールです。もしスイッチボタンやチェックボタンのようにクリックするボタンの状態が変化し、クリックを解除しても、これを維持する必要がある場合は、チェックボックスコントロールを利用して、より簡単に実装可能です。 使い方 プロジェクトウィンドウで、チェックボックスを追加しようとするアクティビティのUIをダブルクリックします。 右のコントロールボックスでCheckboxコントロールを選択します。 Checkboxコントロールをマウスの左クリックした後、ドラッグして、ボタンを作成する場所に置くと、自動的にコントロールが作成されます。 作成されたボタンをマウスの左クリックすると、プロパティウィンドウで、ボタンに関連するプロパティを確認し、変更することができます。 ボタンコントロールと同様に、画像の大きさは、基本的に、チェックボックスコントロールのサイズに沿っていき、必要に応じて位置とサイズを属性で調整可能です。 プロパティの設定後、コンパイルすると、対応するLogic.ccファイルに関連する関数が生成されます。そして、当該コントロールをクリック時に、システムで関連する関数を自動的に呼び出します。 その関数のパラメータの中でbool isCheckedは、コントロールの選択状態を表します。 static void onCheckedChanged_Checkbox1(ZKCheckBox* pCheckBox, bool isChecked) { if (isChecked) { //Check box is selected LOGD(\"checked\"); } else { //Checkbox is unselected LOGD(\"unchecked\"); } } 実際のボードにダウンロードした後、テストしてみてください。 예제 코드 Sample codeのCheckBoxDemoプロジェクトを参照してください。 サンプルコードの実行結果のプレビュー : powered by Gitbooklast modified: 2020-12-02 15:17:38 "},"radiogroup.html":{"url":"radiogroup.html","title":"RadioGroup","keywords":"","body":"RadioGroup 複数のオプションから単一選択の場合RadioGroupコントロールを直接使用することができます。 いずれかのオプションをクリックすると、オプションが自動的に選択された状態になり、同じグループの他のオプションは、選択されていない状態になります。これらのオプションの状態を切り替える時に、図の色もプロパティ]ウィンドウの設定に応じて自動的に切り替わります。 How to use ダブルクリックしてUIファイルを開きます。 右側のコントロールボックスでRadioGroupコントロールを検索します。 RadioGroupコントロールでマウスの左ボタンをクリックした状態で目的の場所にドラッグした後、左のボタンを離すと自動的に矩形領域が生成されるのを見ることができ、その領域はRadioButtonコントロールを保持することができるコンテナを表します。 同じドラッグアンドドロップ操作を使用して矩形領域に複数のRadioButtonコントロールを追加することができます。 追加されたRadioButtonコントロールをマウスの左ボタンでクリックすると、右側の関連プロパティを表示することができます。必要に応じて、各コントロールの各状態図の色を設定することができます。ここで選択した場合Picture and Background Colors属性に注意してください。 画像を設定した後、画像のサイズが異常に表示されている場合、Picture Location属性で画像の位置とサイズを調整することができます。Default State属性でCheckedまたはUncheckedを設定することもできます。 プロパティを設定した後、コンパイルすると、関連する関数が該当するLogic.ccに生成されます。 RadioButtonのいずれかをクリックすると、システムで関連する関数を呼び出します。ここでint checkedIDパラメータは、選択されたRadioButtonの「ID」を表します。 このIDの値に基づいて、現在クリックされたRadioButtonを確認することができます。 この「ID」は、マクロ定義の整数値です。UIファイルがコンパイルされた後、各コントロールは、マクロIDを自動的に生成します(マクロの詳細については、命名規則を確認してください)。各オプションのマクロIDは、Activity.hヘッダファイルで見つけることができます。例 : その後、次の相関関数でクリック項目を判断することができます。 static void onCheckedChanged_RadioGroup1(ZKRadioGroup* pRadioGroup, int checkedID) { LOGD(\"Checked ID = %d\", checkedID); switch (checkedID) { case ID_MAIN_RadioButton1: LOGD(\"First RadioButton\"); break; case ID_MAIN_RadioButton2: LOGD(\"Second RadioButton\"); break; case ID_MAIN_RadioButton3: LOGD(\"Third RadioButton\"); break; default: break; } } ダウンロードおよびデバッグ、効果を確認します。 Sample code Sample CodeのRadioGroupDemoプロジェクトを参照してください。 例のプレビュー : powered by Gitbooklast modified: 2020-12-07 11:32:55 "},"seekbar.html":{"url":"seekbar.html","title":"Seek Bar","keywords":"","body":"Seek Barコントロール Seek Barコントロールの使い方 多くの場合、Seek Barを使用します。たとえば、次のとおりです。 Volume調整 いくつかの簡単な図を使用してこの効果を迅速に得ることができます。 まず、4つの画像を準備します。 Background picture Valid picture Thumb - normal picture Thumb - pressed picture IDEでSeek Barコントロールを作成します。 コントロールを作成する方法がわからない場合、Buttonコントロールの作成を参照してください。 基本Seek Barスタイルは透明で正常に動作するには、十分な画像リソースを追加する必要があります。 プロパティウィンドウで、Valid Picture、Thumb-Normal Picture、Thumb-Pressed Picture、Background Picture画像を設定します。 前のステップが完了すると、基本的にはSeek Bar生成が完了します。IDEでSeek Barのスライド効果をプレビューするにはMax Value属性とDefault Progress属性を変更します。プレビューで、スライダー、カーソルの位置の変更を見ることができます。 コードでSeek Barのプログラスを制御する方法は何ですか？Seek Barの現在のプログレス値を確認する方法は何ですか？ Seek Barを使用してVolume Barを実装する場合、現在のVolume Barのプログレス値を把握し、Volume Barが変更されると同時に、ボリュームも調整する必要があります。 したがって、これらの問題を解決するために、以下の3つの関数があります。 static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress) プログラス値の変更を監視関数 UIファイルにSeek Barコントロールを作成した後、コンパイルすると、この関数はそのXXXXLogic.ccファイルに自動的に追加されます。 タッチスクリーンでSeek Barを押すか、またはプログラスの現在の値が変更されると、システムはこの関数を自動的に呼び出します。 static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress) { //LOGD(\"XXXXThe progress value of the seek bar changes to %d !\\n\", progress); } void setProgress(int progress) Seek Barの現在のプログレス値を設定するために使用されます。例 : //Set the seek bar progress to 28 mSeekbarPtr->setProgress(28) int getProgress() 現在Seek Barのプログレス値を取得するために使用されます。例 : int progress = mSeekbarPtr->getProgress(); LOGD(\"The current progress value of the seek bar %s\", progress); 例 詳細については、Sample CodeのSeekBarDemoプロジェクトを参照してください。例のプレビュー : powered by Gitbooklast modified: 2020-12-07 15:54:14 "},"pointer.html":{"url":"pointer.html","title":"Pointer","keywords":"","body":"Pointer control 特徴 メーターや時計の回転と同様の効果を得るために、このコントロールで簡単に実装することができます。このコントロールは、グラフィックス回転を処理するように特別に設計されました。 アイデア メーターを実装するには、静的な背景画像と背景画像の上に回転するポインタ画像の二つの部分に分けることができます。 したがって、背景画像とポインタ画像を選択した後、ポインタの回転の中心座標のみ決定します。 使い方 まず、Pointerコントロールを作れば、次の属性を確認することができます。 まだコントロールの作成方法がわからない場合は、ボタンコントロールの作成方法を参照してください。 属性マップでPointer PictureとBackground Pictureを追加したことを見ることができます。 追加のプロセスは、アニメーションに表示されます。 上記の最後のプレビュー画像で判断すると、問題が検出されておらず、背景画像とポインタの位置が正常に見えます。しかし、プログラムが実際に実行された後は、240°で開始するため、間違っている。迅速かつ簡単な調整のためにStarting Angle属性は、他の角度（デフォルトは0）に設定することができ、ここで120に調整します。ポインタが120°回転した後で、ポインタの回転の結果が予想と異なっていることがわかります。 その理由は、ポインタが回転する円形の中心座標が正しくないからです。 ポインタの回転中心の座標を決定する2つのプロパティは、 Rotation pointと Fixed pointです。 Rotation point座標は、コントロールの全体の矩形領域を参照します。コントロールの矩形領域の左上隅には、[0,0]（ピクセル単位）です。これらのメーターの場合は、必要回転点の座標は、明らかにダイヤルの中央にあります。これで、図の特定の座標は、以下のように（250、250）です。 Fixed point座標は、ポインタの図を参照して、図の左上隅には、[0,0]で単位はピクセルです。これらのポインタ図の場合は、必要ポインタの固定点の座標は（30、210）です。 座標をプロパティ]ウィンドウに入力すると、ポインタが正しい位置に回転することを見ることができます。 Starting angleは負の値をサポートします。上記の例では、Starting angleを-120に変更すると、ポインタがダイヤル0の位置を指します。 ポインタFixed Pointのヒント 上記の例では、ポインタのFixed Point座標は、ポインタ画像に位置し、実際にこの座標は、カーソルの効果を得るために、図の範囲を超えることがあります。下の図のように赤いボックスの白は、実際にポインタ画像に比較的小さい右属性では、図の実際のサイズをはるかに超えるポインタ固定点の座標を設定し、回転座標を調整して円形のカーソルの効果を取得します。 操作関数 これらのタイプのコントロールのための最も一般的な方法は、コードを介してポインタの回転角度を調整することです。 //Adjust the pointer to 90 degrees mPointer1Ptr->setTargetAngle(90.0); Sample code Sample CodeのPointerDemoプロジェクトを参照してください。 powered by Gitbooklast modified: 2020-12-07 10:13:49 "},"listview.html":{"url":"listview.html","title":"List","keywords":"","body":"List control 機能 リストコントロールは、ページ上のすべての情報を表示することができない場合、どの情報が一定の属性に分類される必要があるときに頻繁に使用されます。 例 WiFiリスト、deviceリスト、table情報など 使い方 UIファイルを開き、List Viewコントロールを作成します。そして、2つのList Subitemコントロールを追加します。以下は動画の例です。 作成されたリストを選択すると、以下のように属性を確認することができます。 それぞれの属性を変更してみボードにダウンロードして、どのように変化するか確認することができます。 今Outlineを見てみましょう。 まず、 List1でリストの行と列を示す Itemノードが、基本的に含まれ、追加した ListSubノード2つ含まれていることを確認することができます。 ここで、各アイテムのノードをクリックすると、プロパティウィンドウで、関連する属性とその属性に影響を与える範囲をエディタ領域のプレビューで確認することができます。 Note : 各List Viewコントロールは、最大32個のList itemを持つことができます。 ItemとList SubitemコントロールはButtonコントロールと同様の性質を持っています。 開発者は、好みのスタイルに合わせて、そのプロパティを変更することができます。以下は例を用いて修正した結果です: UIファイルのリストの全体的な属性を調整して表示されるかを確認した後、コンパイルしてください(FlywizOS プロジェクトのコンパイル). その後、自動的に生成された相関関数に必要な機能を追加します。 コンパイルが終了するとしているLogic.ccファイルに各リストコントロールに関連付けられ、3つの関数が生成されます。 int getListItemCount_ListView1()： 描かれるリストコントロールのアイテム数例：100個のアイテムを表示する場合は、100が返されます。 void obtainListItemData_List1： リストの各アイテムに表示されるコンテンツを設定例 : For specific examples, see follow-up documents上記二つの関数はリストのコンテンツを共同で制御します。 onListItemClick_List1： リストコントロールのクリックイベント関数リスト上のアイテムをクリックすると、システムは、この関数を呼び出します。そしてパラメータを使用して、現在クリックされたリストアイテムのインデックスを渡します。 List drawingプロセス リストを描画したいときは、システムは、まずリストに合計いくつかのアイテムがあることを知る必要があり、そのために提供されたint getListItemCount_ListView1()関数を使用して総アイテム数を取得します。この関数は、動的に取得されます。したがって、プログラムが動作するのは、必要により、他の値を返すことで、リストのアイテム数を動的に調整することができます。 その後、システムはint getListItemCount_ListView1()で返された数だけvoid obtainListItemData_ListView1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index)関数を呼び出し、呼び出し時のパラメータとして渡されるポインタを利用して、各アイテムのコンテンツを設定することができます。 Example 1. リストアイテムに表示するコンテンツを設定static void obtainListItemData_ListView1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { //The pListItem pointer represents a list item, which can only be used in this function char buf[32] = {0}; //The parameter index indicates which item of the list is currently drawn, starting from 0. //Here, we format the index value into a string snprintf(buf, sizeof(buf), \"Item %d\", index); //Display the string as text in the list item area pListItem->setText(buf); //If you have configured the list item \"Picture when selected\" in the ui file, //Then, by setting the selected state of the list item through the following line of code, you can control the list item to //display the corresponding state picture pListItem->setSelected(true); } Example 2. リストサブアイテムに表示するコンテンツを設定もしリストサブアイテムを使用する場合は、以下の方法のようにリストアイテムコントロールポインタからサブアイテムのコントロールポインタを取得して調整することができます。 static void obtainListItemData_ListView1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { char buf[32] = {0}; //The parameter index indicates which item of the list is currently drawn, starting from 0. //Here, we format the index value into a string snprintf(buf, sizeof(buf), \"The first child of item %d\", index); //We can get the pointer of the list item through the findSubItemByID() function and the ID of the list item //Same as the pListItem pointer, the list item pointer that is found can only be used in this function ZKListView::ZKListSubItem* subitem1 = pListItem->findSubItemByID(ID_MAIN_SubItem1); if (subitem1 != NULL) { //Set the text of list item 1 subitem1->setText(buf); } snprintf(buf, sizeof(buf), \"The second child of item %d\", index); ZKListView::ZKListSubItem* subitem2 = pListItem->findSubItemByID(ID_MAIN_SubItem2); if (subitem2 != NULL) { //Set the text of list item 2 subitem2->setText(buf); } } リストの修正 FlywizOSシステムでリストは、一連の規則的なデータのマッピングです。もしデータを追加したり、特定のアイテムを修正するようにリストを修正する場合は、まずデータを修正して、リストを更新します。 その後、システムは自動的にobtainListItemData_ListView1関数を呼び出し、この関数で、最終的に修正されたデータに基づいてリストを表示します。 これらのプロセスは、次の例に反映されています。 サンプルコード サンプルコードのListViewDemoプロジェクトを参照してください。 例の説明 List View ントロールを作成 異なる属性を持つ2つのList Viewコントロールを作成します。 Cycle List control : Cycle属性をonします。 プロジェクトのコンパイル この手順は、Logic.ccファイルに自動的にList Viewコントロールに関連する関数を作成します。\"FlywizOS プロジェクトのコンパイル\"を参照してください。 List1 リスト作成に必要なデータ構造体の設定 リストの各アイテムのためのモデルとして構造体を定義します。 typedef struct { //The text displayed in the list item const char* mainText; //The text to be displayed in list sub item 1 const char* subText; //Turn on/off logo bool bOn; } S_TEST_DATA; 仮想のリストデータのための構造体の配列を定義します。 static S_TEST_DATA sDataTestTab[] = { { \"Test1\", \"testsub1\", false }, { \"Test2\", \"testsub2\", false }, { \"Test3\", \"testsub3\", false }, { \"Test4\", \"testsub4\", true }, { \"Test5\", \"testsub5\", false }, { \"Test6\", \"testsub6\", true }, { \"Test7\", \"testsub7\", false }, { \"Test8\", \"testsub8\", false }, { \"Test9\", \"testsub9\", false }, { \"Test10\", \"testsub10\", false }, { \"Test11\", \"testsub11\", false } }; 自動的に生成されたリスト関連の関数にコードを追加します。 static int getListItemCount_List1(const ZKListView *pListView) { //Use the length of the array as the length of the list return sizeof(sDataTestTab) / sizeof(S_TEST_DATA); } static void obtainListItemData_List1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { //Get the pointer of the list sub item 1 and name it psubText ZKListView::ZKListSubItem* psubText = pListItem->findSubItemByID(ID_MAIN_ListSub1); //Get the pointer of the list sub item 2 and name it psubButton ZKListView::ZKListSubItem* psubButton = pListItem->findSubItemByID(ID_MAIN_ListSub2); pListItem->setText(sDataTestTab[index].mainText); //Take index as the subscript, get the corresponding structure from the array, get the text that needs to be displayed //from the structure, and finally set it to the corresponding list item psubText->setText(sDataTestTab[index].subText); //In the UI file, we set the selected image property for the list sub item 2 //Here, according to the `bOn` value of the structure, the selected state of the list item is set, so that if the member //`bOn` is true, it is set to be selected, and the system will automatically display the selected picture previously set psubButton->setSelected(sDataTestTab[index].bOn); } static void onListItemClick_List1(ZKListView *pListView, int index, int id) { //When you click the index item in the list, modify the bOn variable to reverse bOn. In this way, every time you click on //the list, the picture will switch once //Note that the operation of picture switching is completed in the obtainListItemData_List1 function, and now we only //modify the value of this variable. sDataTestTab[index].bOn = !sDataTestTab[index].bOn; //The last sentence of code modified the structure data, and now we want to refresh the list immediately, and call //refreshListView to force a refresh //After the refresh is triggered, the system will call the two functions getListItemCount_List1 and //obtainListItemData_List1 again, so that the modified data corresponds to the list display. mList1Ptr->refreshListView(); } コードの追加が完了したら、ダウンロードして実行した後、結果を確認します。 powered by Gitbooklast modified: 2020-12-03 17:11:10 "},"diagram.html":{"url":"diagram.html","title":"Diagram","keywords":"","body":"ダイヤグラム このコントロールを使用して、簡単に、曲線または直線ダイヤグラムを描くことができます。 使い方 まず、UIファイルにダイヤグラムが位置する領域を決めた後 Diagramコントロールを作成し、 Waveformコントロールを追加すると、おおよそのダイヤグラムを確認することができます。具体的な作成手順は次のとおりです。 必要に応じてWaveformコントロールを追加して、波形を追加することができます。Note : プレビューでは、DiagramコントロールのWaveformコントロールを選択することができないため、Waveformコントロールのプロパティを確認または変更するには、outlineでwaveformコントロールを選択するしかありません。 DiagramとWaveformコントロールそれぞれのプロパティを確認するとDiagramコントロールのプロパティには、波形のx、y座標の範囲と描かれる領域を決定するということがわかります。そしてWaveformコントロールのプロパティには、各波形の線のスタイルを決定します。 WaveformコントロールのプロパティのStepとErase Spaceは以下の通りです。 Step 新しい波形データが一つ追加されたとき、波形が動く距離（単位：ピクセル）を表します。この値は、x-axis zoom属性の影響を受けます。 Erase Space波形が更新されたとき空部分の幅を表します。 上記の2つのプロパティは、すべてのvoid addData(int index、float data)関数を用いて、新しい波形データを追加する場合にのみ有効です。 座標とスケール 波形全体のスケールは自動的に決定されるので、プロパティウィンドウ、x軸、y軸の範囲と表示領域のサイズだけを決定します。 Note : WaveformコントロールのX scaleとY scaleプロパティは、値の倍率に応じて波形がスクリーンに描かれる。基本は1.0であり、スケールされないことを意味します。波形の座標はx-axis min value、x-axis max value、y-axis min value、and y-axis max valueによって決定されます。例えば、基本的なx-axisの範囲が[0、100]であり、y-axisの範囲が[0, 100]の場合、波形が描かれる領域の座標は以下の通りです。 一般的に、x-axis minの値はx-axis maxの値よりも小さい。しかし、逆に値を入れる場合、波形は同じデータを持つ波形がx軸に反転します。もしvoid setData(int index、const MPPOINT* pPoints、int count)関数を使用してデータを追加する場合は、更新されている方向も逆方向になります。また、同様のことがy軸に発生した場合、上下に反転します。 運営コード UIファイルは、唯一の波形の形だけ速く変更することができ、実際の波形は、コードを介してデータを追加する必要があります。 プロジェクトのjni/ include/ control/ ZKDiagram.hで、そのためのサポート関数を参照することができます。 Note : 他のコントロールとは異なり、WaveformコントロールもIDを持っていますが、このIDで、独立したポインタ変数が作成されません。ただDiagramだけの独立したポインタ変数が作成されジービーだ。したがって、波形を調整するためには、Diagramコントロールのポインタを利用した次のindex値を利用して波形を調整する必要があります。indexは0から始まります。 void setPenWidth(int index, int width)波形の太さを設定します。プロパティウィンドウPen Widthに対応します。 void setPenColor(int index, ARGB color)波形の色を設定します。プロパティウィンドウPen Colorに対応します。 void setXScale(int index, double xScale)Y-axisのスケールを設定します。プロパティウィンドウX-axis Xcaleに対応します。 void setYScale(int index, double yScale)Y-axisのスケールを設定します。プロパティウィンドウY-axis Scaleに対応します。 void setData(int index, const MPPOINT *pPoints, int count) typedef struct _MPPOINT { float x; float y; }MPPOINT; MMPOINT構造体は、波形データのxとyの値が含まれています。 この関数は、index番目Waveformコントロールにcountのデータを持つpPoints配列にそれほどという意味です。Note：count値はpPointsの実際のサイズよりも大きくすることができません。 この関数を用いて波形を描く場合 : まず、sPoints配列に波形データを満たし、一度に波形を更新します。 したがって、もし波形を左または右に移動効果を得たい場合は、配列全体の値を調整する必要があります。 通常、これらの場合、タイマーを使用して実装し、この関数の呼び出し時に、波形全体が更新されます。 void addData(int index, float data) 波形に1つのデータを追加します。dataはyの値であり、xの値は、Stepによって自動的に決定されます。 void setData(int index、const MPPOINT* pPoints、int count)と void addData(int index、float data)の波形更新方式を比べると、データのサイズが大きい場合には、2番目の方法は、より効率的に波形を更新することができます。 setData(index, NULL, 0)波形データをすべて0にクリアします。 波形の移動方法を追加 前述したようvoid setData(int index、const MPPOINT* pPoints、int count)を使用して波形を描く場合、一般的に、配列の値を直接設定する必要があります。 static void movePoints(MPPOINT* p,int size){ for(int i =0;i タイマーを追加して、波形データを定期的に更新 一般的に、定期的に波形を更新するための簡単な方法として、タイマーを追加します。 サンプルコード プレビュー 具体的な内容は、サンプルコードのDiagramDemoプロジェクト参照してください。 powered by Gitbooklast modified: 2020-12-02 16:57:38 "},"circlebar.html":{"url":"circlebar.html","title":"Circle Bar","keywords":"","body":"円形プログレスバー 特定のアプリケーションの場合は、「一直線のプログレスバー\"より\"円形のプログレスバー」がより適していることがあります。 使い方 まず、UIファイルをオープンした後、circular progress barコントロールを作成します。そしてvalid picture属性に画像を追加すると、基本的なラウンドプログレスバー完成されます。 원형 프로그래스 바의 모든 속성은 아래와 같습니다. 円形プログレスバーは、現在のプログラスが扇形領域で表示され、この領域は、valid pictureの一定領域のみ表示することで実装されます。 たとえば、もし属性が上の画像のように設定された場合、最大値は100であり、初期の開始角度は0であり、プログラスの方向は時計回りです。その後、プログラスを25に設定すると、唯一の0から90°の扇形領域に対応するvalid pictureのみ表示されます。そして、もしプログラスが100であれば、全体valid pictureが表示されます。 Note: プログラス値に応じた表示領域の変更は、valid pictureのみ適用され、background pictureは適用されません。 運用コード 円形プログレスバーで提供される関数は非常に単純です。 //Set current progress void setProgress(int progress); //Get current progress int getProgress()； //Set maximum progress void setMax(int max); //Get maximum progress int getMax()； サンプルコード 例では、上部スライドバーを調整すると、次の2つの円形のプログレスバーが変更されます。 Sample codeのCircleBarDemoプロジェクト参照してください。 powered by Gitbooklast modified: 2020-12-02 15:26:39 "},"qrcode.html":{"url":"qrcode.html","title":"QR Code","keywords":"","body":"QR code QR codeを追加する方法 QR codeを表示する必要がある場合は、既存の「QR code」コントロールを使用して迅速に実装できます。具体的な手順は次のとおりです。 ダブルクリックしてUIファイルを開きます。 右側のコントロールボックスでQR codeコントロールを検索します。 QR codeコントロールをマウスの左ボタンで押したまま、目的の場所にドラッグした後、左のボタンを離すと、QR codeコントロールが作成されます。 作成したQR codeコントロールを選択した後、右側の[プロパティ]ウィンドウで、QR codeの内容を変更して、QR code画像が同時に変更されることがわかります。 QR codeを動的に更新 IDEを使用してQR codeコンテンツを設定することに加え、コードを介してQR codeコンテンツを動的に設定することもできます。 bool loadQRCode(const char *pStr); Sample code 詳細は、Sample CodeのQrCodeDemoプロジェクトを参照してください。 powered by Gitbooklast modified: 2020-12-07 11:11:55 "},"video.html":{"url":"video.html","title":"Video View","keywords":"","body":"Video view FlywizOSは動画のプレイのためのコントロールも提供しています。 [!Note] 動画プレイ機能は、すべてのバージョンの機器でサポートされていません！この機能を正常に使用するには、マルチメディア機能があるバージョンをご購入下さい。 コントロールのLoopプロパティの操作方法 まず、Video Viewコントロールを作成します。既定の背景色は黒です。 Video viewのプロパティ]ウィンドウを確認します。 そのうちの一つの属性にLoopがあります。 そのプロパティをYesを選択すると、UIアクティビティに入るたびに、自動的にTFカードのディレクトリ構成ファイルを読み取り、ファイルに指定されたドンヨウンサンルル繰り返しプレイします。アクティビティを終了すると、自動的にプレイを停止します。この属性は、広告装置のように、短い動画の自動プレイなど、ユーザーの介入なしに動画のみプレイする必要があるデバイスに非常に適しています。 Noを選択すると、動画のレンダリング領域のみ生成され、他のタスクは実行されません。その後、直接操作して動画をプレイする必要があります。 動画構成ファイルの作成 前述したようLoopがYesの場合の動画構成ファイルを自動的に読み取ります。(ファイルは直接作成します。) この構成ファイルは、TFカードのルートディレクトリにする必要があり、ファイル名は、XXXX_video_list.txtです。XXXXは、UIファイル名を表します。例：main.ftuにVideo Viewコントロールを追加すると、その構成ファイルの名前は、main_video_list.txtです。構成ファイルは、行単位で、各ラインは、動画ファイルの絶対パスです。動画ファイルがTFカードのルートディレクトリにある場合、/mnt/extsd/を入力して、動画ファイルの名前を追加します。 Note：ファイル名のエンコードの問題に起因する動画ファイルの読み取りの失敗を防止するには、動画ファイルの名前を英語で指定します。 プログラムが実行された後、構成ファイルのドンヨウンサンルル自動的に繰り返しプレイすることができます。 指定された動画ファイルのプレイ Video Viewコントロールを作成します。 LoopをNoに設定します。 プレイを制御するためのコードを追加します。 Play //Play the test.mp4 file, starting from time 0 mVideoView1Ptr->play(\"/mnt/extsd/test.mp4\", 0); Pause //Pause playback mVideoView1Ptr->pause(); Resume //Resume playback mVideoView1Ptr->resume(); Stop mVideoView1Ptr->stop(); 特定の時間に移動した後プレイ //Jump to the 10 second position mVideoView1Ptr->seekTo(10 * 1000); プレイ音量の設定、範囲0〜1.0 //Set the volume to 0.5 mVideoView1Ptr->setVolume(0.5); プレイしていることを確認 bool state = mVideoView1Ptr->isPlaying(); if （state) { LOGD(\"Now Playing\"); } 動画の総プレイ時間（ms）を取得します。 int n = mVideoView1Ptr->getDuration(); 動画の現在のプレイ位置をms単位で取得します。 int n = mVideoView1Ptr->getCurrentPosition(); 動画は非同期的にプレイされ、自動的に生成された関連機能が動画プレイの状態をお知らせします。 static void onVideoViewPlayerMessageListener_VideoView1(ZKVideoView *pVideoView, int msg) { switch (msg) { case ZKVideoView::E_MSGTYPE_VIDEO_PLAY_STARTED: LOGD(\"Start playback\"); break; case ZKVideoView::E_MSGTYPE_VIDEO_PLAY_COMPLETED: LOGD(\"End playback\"); break; case ZKVideoView::E_MSGTYPE_VIDEO_PLAY_ERROR: LOGD(\"Error\"); break; } } 完全なビデオプレーヤーの実装 動画プレイのためのより高い要件がある場合プレイ/一時停止、および現在のプレイ時間などを操作することができる必要があります。 すべての動画プレーヤーのサンプル（続き）を参照してください。 Sample code 詳細については、Sample CodeのVideDemoプロジェクトを参照してください。 powered by Gitbooklast modified: 2020-12-08 15:54:53 "},"edittext.html":{"url":"edittext.html","title":"Edit Text","keywords":"","body":"Edit Text もし数字キーボードが必要か、ユーザーがテキストを入力できるようにするには、どうでしょうか Edit Text box追加する もし数字やテキストの入力が必要な場合は、Edit Textコントロールを利用して迅速に実装することができます。その過程は、以下のとおりです。 プロジェクトウィンドウでボタンを追加しようとするアクティビティのUIをダブルクリックします。 右側のコントロールボックスでEdit Textコントロールを選択します。 Edit Textコントロールをマウスの左クリックした後、目的の場所をクリックするか、ドラッグアンドドロップすると、コントロールが作成されます。 作成されたボタンを左クリックすると、プロパティウィンドウで、ボタンに関連するプロパティを確認し、変更することができます。 プログラムをボードにダウンロードして実行した後Edit Textコントロールをタッチすると、内蔵された仮想の数字キーボードまたは仮想テキストキーボードが自動的にポップアップされ、これにより、数字やテキストを入力することができます。 内蔵された仮想テキスト入力キーボード 内蔵された仮想数値入力キーボード 基本Edit Textは白であり、プロパティウィンドウを使用して、ユーザーが好みのスタイルに変更が可能です。Edit Textに関連する属性は次のとおりです。 Passwordもし「Yes」を選択すると、キーボード入力時に表示されるテキストがPassword Charで表示され、「No」の場合、入力したテキストが表示されます。 Password CharPasswordが「Yes」である場合は、キーボード入力時に表示されるテキストを設定します。基本的には「*」が表示されます。 Input Type入力形式は、2つの方法があります。 Text - 英語または数字を入力することができます。 Number - 数字のみを入力できます。 Hint Text何の入力がない場合は自動的に表示されるテキストを設定します。 Hint Text ColorHint Textの色を設定します。 仮想キーボードから入力されたコンテンツのインポート Edit Textコントロールを正常に完了した後、コンパイルすると、それに関連する関数が自動的に生成されます。プロジェクトディレクトリでjni/ logic/**** Logic.ccファイルを開くと、その関数を見つけることができます。 static void onEditTextChanged_XXXX(const std::string &text) { //LOGD(\"The current input is %s \\n\", text.c_str()); } 仮想キーボードでテキストを入力すると、システムは自動的にその関数を呼び出して、 textパラメータを使用して、現在入力されたコンテンツが配信されます。 std:: stringは、C ++のstringであり、ユーザーは次の例のようにstringポインターを取得することができます。 const char* str = text.c_str(); 入力されたコンテンツを数値に変換 Edit Textに関連する関数では、文字のみの獲得が可能です。だから数字を入力しても、文字取得されるので、これを数字で変える必要があります。 atoi関数は、文字を数字に置き換えることができます。たとえば、文字「213」は、整数213に変更することができます。 もし数字に変更することができない文字が入力されると、変換が失敗することがあります。 예 :atoi(\"213abc\"); return 213atoi(\"abc\"); return 0 static void onEditTextChanged_EditText1(const std::string &text) { int number = atoi(text.c_str()); LOGD(\"String to number = %d\", number); } atofは文字を浮動小数点数の切り替え関数です。たとえば、「3.14」は、浮動小数点数3.14に切り替わります。 もし浮動小数点数に変更することができない文字が入力されると、変換が失敗することがあります。 例 :atoi(\"3.14abc\"); return 3.14atoi(\"abc\"); return 0 static void onEditTextChanged_EditText1(const std::string &text) { // The atof function can convert a string to a corresponding floating point number, for example, \"3.14\" can be converted to an // integer 3.14 // If the parameters are not standardized, the conversion will fail, and the number 0 will be returned uniformly double f = atof(text.c_str()); LOGD(\"Convert string to floating point = %f\", f); } カスタムのIME デフォルトの入力方法に加えて、ユーザーが希望する形態の入力機を作ることができます。Sample Code PackageのImeDemoプロジェクトで、その例を見つけることができます。(現在は文字と数字のみです。) 通常のIMEとカスタムのIMEの違いは以下の通りです。 通常のIMEは、Activityを継承し実装されるが、カスタムのIMEはIMEBaseAppの継承が必要です。 さらに登録方法に違いがあります。通常のIMEは、REGISTER_ACTIVITY（**** Activity）;を使用して登録されますが、カスタムのIMEはREGISTER_SYSAPP(APP_TYPE_SYS_IME、**** Activity);を使用して登録されます。(**は、UIファイル名) ImeDemoプロジェクトを修正して、ユーザー独自のカスタムのIMEを作成することができます。 まず、UserIme.ftuファイルをプロジェクトのuiディレクトリにコピーします。 UserImeActivity.hとUserImeActivity.cppをユーザーのプロジェクトのactivityディレクトリにコピーします。 UserImeLogic.ccファイルをプロジェクトのlogicディレクトリにコピーします。 以後UserImeLogic.ccファイルをユーザーにニーズに合わせて変更します。 powered by Gitbooklast modified: 2020-12-03 10:06:47 "},"window.html":{"url":"window.html","title":"Window","keywords":"","body":"Window 機能説明 Windowは、実際にコンテナであり、すべてのコントロールを含むか、または新しいWindowを再含めることができ、次のようなシナリオで使用することができます。 コントロールの組み合わせの表示と非表示に タブページを完成するときに、複数のWindowを介して他のWindowの間を切り替えることができます。 ポップアップダイアログボックス 使い方 Windowコントロールを作成します。基本Windowは透明です。背景画像を追加したり、必要に応じて背景色を変更することができ、Windowに他のコントロールを追加することもできます。 上記のプロパティ]ウィンドウには、説明しなければなら2つのプロパティがあります。 Modalモーダルである場合、このWindowコントロールが表示されるWindow外側をクリックすると、ウィンドウが自動的に非表示になります。モーダルでない場合、ウィンドウコントロールの表示/非表示を独自に制御する必要があります。 Timeout auto hideモーダルWindowの場合Windowは表示開始から計算を開始し、指定された時間が経過すると、自動的に非表示になります。単位は秒であり、値が-1の場合、自動的に隠されていないことを意味します。非モーダル場合は、この属性は効果がありません。 コードの操作 Windowコントロールの場合、一般的に、次の関数が含まれます。 //Show window void showWnd(); //Hide window void hideWnd(); //Determine whether the window is displayed bool isWndShow(); 動的に背景の設定 画面全体にWindowを展開して、このWindowの背景を設定すると、画面の背景を変更するに効果を得ることができます。 関連する関数 /** * @brief Set background picture * @param pPicPath Picture path */ void setBackgroundPic(const char *pPicPath); /** * @brief Set background color * @param color When -1, the background is set to transparent; other color values are 0xRGB, * and the color value does not support alpha */ void setBackgroundColor(int color); 使用例 //Set the image of the path /mnt/extsd/bg.png as the background image of this window control mWindow1Ptr->setBackgroundPic(\"/mnt/extsd/bg.png\"); //Set the background color of the window with ID window1 to red mWindow1Ptr->setBackgroundColor(0xff0000); //Set the background color of the window with ID window1 to green mWindow1Ptr->setBackgroundColor(0x00ff00); //Set the background color of the window with ID window1 to blue mWindow1Ptr->setBackgroundColor(0x0000ff); 多くのコントロールには、背景色と背景画像を設定するインターフェイスがあり、方法は同じです。 Sample code 詳細については、Sample CodeのWindowDemoプロジェクトを参照してください。 powered by Gitbooklast modified: 2020-12-08 16:13:32 "},"slidewindow.html":{"url":"slidewindow.html","title":"Slide Window","keywords":"","body":"Slide Windowコントロール Slide Windowコントロールは、携帯電話のメインインタフェースで左右にスライドするインターフェイスの効果と似ています。スライディングメインウィンドウ複数のアイコンで構成されます。 使い方 まず、UIファイルにSlide Windowコントロールを作成し、Slide Window iconコントロールをいくつか追加します。 Slide Window iconコントロールを追加すると、アイコンが順番に自動的にソートされます。もし1つのページに追加が完了した後も追加すると、ページが自動的に進みます。追加されたすべてのアイコンのコントロールは、Outlineで見つけることができます。 Slide Window Iconの位置を調整するには、Outlineでノードを選択し、ドラッグして手動で調整することができます。下のアニメーションの左下にあるOutlineの動作に注意してください。 OutlineでSlide Window Iconコントロールを選択すると、画像を追加して、テキストを個別に変更することができます。Slide Windowを選択して、行と列の数を調整し、フォントサイズ、アイコンのサイズを均一に調整することもできます。 コードの操作 Slide Windowコントロールを追加すると、コンパイル後に自動的に相関関数が生成され、詳細な機能の説明は、スライドウィンドウ相関関数を参照してください。 一般的な状況では、タッチしてスライドして上下にスクロールするだけです。しかし、ページめくり機能も提供します。 次のページに切り替え// Switch to the next page with animation mSlideWindow1Ptr->turnToNextPage(true); // Switch to the next page without animation mSlideWindow1Ptr->turnToNextPage(false); 前のページに切り替え// Switch to the previous page with animation mSlideWindow1Ptr->turnToPrevPage(true); // Switch to the previous page without animation mSlideWindow1Ptr->turnToPrevPage(false); Slide Windowがコードを介して任意のページに切り替えていることを監視することもできます。 namespace { // Add an anonymous scope to prevent multiple source files from defining the same class name and conflict at // runtime // Implement your own listening interface class MySlidePageChangeListener : public ZKSlideWindow::ISlidePageChangeListener { public: virtual void onSlidePageChange(ZKSlideWindow *pSlideWindow, int page) { LOGD(\"Now switch to page %d\", page); } }; } // Define the listening object static MySlidePageChangeListener sMySlidePageChangeListener; static void onUI_init() { mSlidewindow1Ptr->setSlidePageChangeListener(&sMySlidePageChangeListener); } 現在のページの読み込み int i = mSlideWindow1Ptr->getCurrentPage(); LOGD(\"Current page %d\", i); Sample code 詳細については、Sample CodeのSlideWindowDemoプロジェクトを参照してください。 powered by Gitbooklast modified: 2020-12-07 17:13:44 "},"painter.html":{"url":"painter.html","title":"Painter","keywords":"","body":"Painter Painterコントロールは、単純な幾何学的な描画インタフェースを提供します。 使い方 Painterコントロールを作成します。基本Painterコントロールは透明です。必要に応じて背景画像を追加したり、背景色を変更することができます。 コードの操作 Painterコントロールの変数へのポインタを介して関数を呼び出して、グラフィックスを描画することができます。このコントロールのほとんどの関数は、コードに実装する必要があります。例は次のとおりです。 static void onUI_init() { /** * Draw a rounded rectangle border */ mPainter1Ptr->setLineWidth(4); mPainter1Ptr->setSourceColor(0x7092be); mPainter1Ptr->drawRect(10, 10, 430, 230, 5, 5); /** * Draw an arc */ mPainter1Ptr->setLineWidth(3); mPainter1Ptr->setSourceColor(0xadc70c); mPainter1Ptr->drawArc(80, 80, 40, 40, -20, -120); /** * fill an arc */ mPainter1Ptr->setLineWidth(3); mPainter1Ptr->setSourceColor(0x008ecc); mPainter1Ptr->fillArc(80, 80, 40, 40, -20, 120); /** * Draw triangle */ mPainter1Ptr->setLineWidth(4); mPainter1Ptr->setSourceColor(0xff804f); mPainter1Ptr->drawTriangle(200, 40, 160, 90, 240, 90);//空心三角形 mPainter1Ptr->fillTriangle(300, 40, 260, 90, 340, 90); //实心三角形 /** * Draw straight line */ MPPOINT points1[] = { {50 , 150}, {150, 150}, {70 , 200}, {100, 120}, {130, 200}, {50 , 150} }; /** Connect to a line according to the provided coordinates of multiple points */ mPainter1Ptr->setLineWidth(2); mPainter1Ptr->setSourceColor(0x88cffa); mPainter1Ptr->drawLines(points1, TABLESIZE(points1)); /** * Draw a curve */ MPPOINT points2[] = { {250, 150}, {350, 150}, {270, 200}, {300, 120}, {330, 200}, {250, 150} }; mPainter1Ptr->setLineWidth(3); mPainter1Ptr->setSourceColor(0xe28ddf); /** Connect as a curve according to the provided multiple point coordinates */ mPainter1Ptr->drawCurve(points2, TABLESIZE(points2)); } Sample code Painterコントロールの使用方法を示しています。 詳細は、Sample CodeのPainterDemoを参照してください。 powered by Gitbooklast modified: 2020-12-04 16:41:57 "},"camera.html":{"url":"camera.html","title":"Camera","keywords":"","body":"カメラ FlywizOSは、カメラコントロール機能を提供します。 [!Note] すべてのバージョンのボードからカメラ機能をサポートしていません。もしこの機能が必要な場合は、USBカメラ機能をサポートしているボードを購入する必要があります。 使い方 まず、カメラコントロールを作成します。デフォルトの背景は黒です。 カメラコントロールのプロパティ]ウィンドウを確認します。 Auto Preview属性をOnに設定します。 接続されているカメラのタイプに応じて、CVBS Signal属性を選択します。 カメラウルボードに接続し、プログラムをダウンロードすると、カメラから入力される映像を見ることができます。 プレビュー開始/停止 ソースコードを使用してプレビューの開始/停止を制御することができます。 プレビュー開始mCameraView1Ptr->startPreview(); プレビュー停止mCameraView1Ptr->stopPreview(); プレビュー画面キャプチャ カメラコールバックインターフェイスの実装 class PictureCallback : public ZKCamera::IPictureCallback { public: virtual void onPictureTakenStarted() { mTextView1Ptr->setText(\"Start taking a photo\"); } virtual void onPictureTakenEnd() { mTextView1Ptr->setText(\"End of photo\"); } virtual void onPictureTakenError() { mTextView1Ptr->setText(\"Photo error\"); } virtual const char* onPictureSavePath() { //Photo save path return \"/mnt/extsd/camera.jpg\"; } }; カメラコールバックインターフェース宣言 //Defined as a global static variable static PictureCallback picture_callback; カメラコントロールのインターフェースの登録と登録解除 static void onUI_init(){ mCameraView1Ptr->setPictureCallback(&picture_callback); } static void onUI_quit() { //Remember to empty the registration interface when the interface exits mCameraView1Ptr->setPictureCallback(NULL); } ボタンを追加して、ボタンが押される時の画面キャプチャstatic bool onButtonClick_Button3(ZKButton *pButton) { //Request a photo mCameraView1Ptr->takePicture(); return false; } サンプルコード この例では、カメラのプレビュー、キャプチャ機能などが実装されています。 Sample codeのCameraDemoプロジェクト参照してください。 powered by Gitbooklast modified: 2020-12-02 15:17:50 "},"digital_clock.html":{"url":"digital_clock.html","title":"Digital Clock","keywords":"","body":"디지탈 시계 디지탈 시계는 시간을 표시하는 전용 컨트롤로, 많은 시나리오에서 사용자는 시간을 표시해야하며 시스템 시간에 따라 자동으로 표시됩니다. 사용법 프로젝트 창에서 버튼을 추가하고자 하는 액티비티의 UI 파일을 더블 클릭합니다. 우측의 컨트롤 박스에서 Digital Clock 컨트롤을 선택합니다. Digital Clock컨트롤을 마우스 왼쪽 클릭 후 드래그하여 버튼을 만들 위치에 놓으면, 자동으로 컨트롤이 만들어집니다. 만들어진 디지털 시계를 마우스 왼쪽 클릭하면 속성 창에서 해당 버튼과 관련된 속성들을 확인하고, 변경할 수 있습니다. Format 이 속성은 시간을 표시하는 형식을 정한다. 24시간 또는 12시간 시스템, 그리고 초에 대한 표시 유무를 선택할 수 있습니다. Blinking 이 속성은 :이 항상 표시되는지, 점멸되는지를 설정합니다. Color 디지털 시계의 글자 색을 설정합니다. Font size 디지털 시계의 글자 크기를 설정합니다. Picture Character Set숫자나 글자를 지정된 이미지로 표시할 수 있도록 설정합니다. (Text 컨트롤의 이미지 캐릭터 설정 참고하십시오) 저장, 다운로드 후 효과를 확인합니다. 만약 시간을 수정하기 원한다면 시스템 시간을 참고하십시오. サンプルコード Sample codeのDigitalClockDemoプロジェクト参照してください。 powered by Gitbooklast modified: 2020-12-02 17:02:14 "},"relation_function.html":{"url":"relation_function.html","title":"関連する関数の概要","keywords":"","body":"コントロールによって自動的に生成された相関関数の説明 一部のコントロールは、関連する関数を自動的に生成します。これらのコントロールによって生成された関連の関数の具体的な説明は次のとおりです。 [!Note] 関数でXXXXはコントロールIDを表すため、実際のプロセスから直接交換してください Button control static bool onButtonClick_XXXX(ZKButton *pButton) { return false; } ボタンをクリックすると、関数が呼び出されます。 パラメータZKButton* pButtonはクリックしてボタンのポインタです。ポインタのメンバ関数を使用してコントロールの一連の作業を行うことができます。このポインタは、グローバル変数mXXXXPtrが指すオブジェクトと同じオブジェクトです。 Edit Text control static void onEditTextChanged_XXXX(const std::string &text) { } Input boxのテキストが変更されると、システムは自動的にこの関数を呼び出します。 パラメータstd::string＆text現在Input boxの完全な文字列です。 Seek Bar control static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress) { } Seek Barの現在のプログレス値が変更されると、システムは自動的にこの関数を呼び出します。 パラメータZKSeekBar* pSeekBarはSeek Barコントロールのポインタであり、ポインタのメンバ関数を使用して、コントロールの一連の作業を行うことができます。 パラメータint progressは、現在Seek Barのプログラス値です。 Slide Window control static void onSlideItemClick_XXXX(ZKSlideWindow *pSlideWindow, int index) { } Slide Windowコントロールのアイコンをクリックすると、システムが自動的にこの関数を呼び出します。 パラメータZKSlideWindow* pSlideWindowはSlide Windowコントロールのポインタであり、ポインタのメンバ関数を使用してコントロールの一連の作業を行うことができます。 パラメータint indexは、現在クリックされたアイコンのIndex値です。たとえば、合計10個のアイコンがSlide Windowに追加された場合Index値の範囲は[0、9]です。 List control Listコントロールは、最も複雑なコントロールであり、3つの関連する関数を作成します。多くの機能がありますが、以下の手順に従って、理解することは非常に簡単です。 まず、システムがListコントロールを描画するにはどのように多くの項目があることを知っている。したがって、次のような関連の関数があります。 static int getListItemCount_XXXX(const ZKListView *pListView) { return 0; } パラメータconst ZKListView* pListViewは、グローバル変数mXXXXPtrと同じオブジェクトを指しているListコントロールのポインタです。 戻り値は定数で、List内の項目数を意味し、必要に応じて定義することができます。 시システムが描画するアイテムの数を知っても十分ではなく、各項目ごとに表示される内容も知っている。このため、以下の関数が提供され、提供された関数が複数回呼び出され、各項目が処理されるまで、各項目の表示内容を設定します。 void obtainListItemData_XXXX(ZKListView *pListView, ZKListView::ZKListItem *pListItem, int index) { //pListItem->setText(index) } パラメータZKListView* pListViewは、グローバル変数mXXXXPtrと同じオブジェクトを指しているListコントロールのポインタです。 パラメータZKListView::ZKListItem* pListItemはList Itemのポインタであり、UIファイルのItemに対応します。 パラメータint indexは全体ListでpListItemのIndex値であり、特定の範囲があります。 例：getListItemCount_XXXX関数の戻り値は10であり、これは、Listに10個のItemがあることを意味します。その後、indexの範囲は、pListItemとindexを組み合わせて、[0、9]です。今設定したList Itemが全体Listでどこにあるか知ることができます。 この機能では、indexに基づいて、各Listの表示内容を個別に設定することができます。例：関数でコメントアウトされたステートメントは、次のことを意味します。各List Itemは、そのIndex値をテキストとして表示します。 Buttonコントロールと同様にListコントロールにもクリックイベントがありますがIndex値を基準に、現在クリックされたList Itemを判断します。 static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); } Listコントロールをクリックすると、タッチ座標を使用してList Itemのインデックス番号を計算した後に自動的にこの関数を呼び出します。 パラメータZKListView* pListViewは、グローバル変数mXXXXPtrと同じオブジェクトを指しているListコントロールのポインタです。 パラメータint indexは全体Listコントロールで現在クリックされたList ItemのIndex値です。 パラメータint idは、現在クリックされたコントロールのIDです。このIDは、[プロパティ]ウィンドウIDとは異なります。これに対するマクロは、Activity.hファイルに定義されています。例えば、mainActivity.hでこのidはList Itemに複数subItemがあるとき、現在クリックされたsubItemを区別するために使用することができます。例：下の図のようにList Itemに2つのsubItemを追加して、スイッチボタンで画像を追加しました。属性IDは、それぞれSubItem1とSubItem2です。SubItem1をクリックすると、idと ID_MAIN_SubItem1、ID_MAIN_SubItem2の関係を判断して、どのスイッチをクリックしたかを確認することができます。 サンプルコード : static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); switch(id) { case ID_MAIN_SubItem1: //LOGD(\"Clicked the first subitem of item %d in the list\", index); break; case ID_MAIN_SubItem2: //LOGD(\"Clicked the second subitem of item %d in the list\", index); break; } } powered by Gitbooklast modified: 2020-12-07 14:42:40 "},"first_app.html":{"url":"first_app.html","title":"開始アクティビティ","keywords":"","body":" 新しいプロジェクトを作成すると、jniフォルダにテンプレートコードが含まれているMain.cppファイルが生成されます。 上記の赤四角のコードでどのアクティビティが開始アクティビティのか知ることができ、このことから mainActivityが開始アクティビティであることを知ることができます。また、jni/ activity/ mainActivity.cppファイルでは、どのようなUIファイルがアクティビティのUIファイルであることを確認できます。 powered by Gitbooklast modified: 2020-12-03 10:11:39 "},"open_close_app.html":{"url":"open_close_app.html","title":"アプリケーション液テレビで実行/終了","keywords":"","body":" 先に我々はすでに開始アクティビティについて学びました。開始アクティビティの実行後2番目、3番目のステップの他のアクティビティを実行することができます。次に、他のアクティビティを実行して終了する方法について学ぶようにします。 Application activity 実行 たとえば今sub.ftuに対応するアクティビティを実行する必要があります。先に開始アクティビティの分析に応じて、UIリソースに対応するアクティビティオブジェクトがsubActivityであることを知ることができます。これらはIDEによって自動的にコードです。私たちは、ここであまりにも多くの細部に注意を払う必要がなく、簡単にイエてはと、次のコードでアクティビティを開始することができます。 EASYUICONTEXT->openActivity(\"subActivity\"); もしボタンクリックスルーsub.ftuアクティビティに入るには、ボタンのクリックイベント関数では、上記の関数を呼び出します。 static bool onButtonClick_Button1(ZKButton *pButton) { // Jump to the sub.ftu activity EASYUICONTEXT->openActivity(\"subActivity\"); return false; } 通常の状況下では、上記の呼び出しコードで十分です。しかし、支払いページのようにアクティビティの間どのような情報を渡す必要がある場合は、openActivityに渡される2番目のパラメータを使用して情報を伝達する必要があります。 Intent *pIntent = new Intent(); pIntent->putExtra(\"cmd\", \"open\"); pIntent->putExtra(\"value\", \"ok\"); EASYUICONTEXT->openActivity(\"subActivity\", pIntent); subLogic.ccのonUI_intentコールバックで受信することができます。 static void onUI_intent(const Intent *intentPtr) { if (intentPtr) { // Key value analysis std::string cmd = intentPtr->getExtra(\"cmd\"); // \"open\" std::string value = intentPtr->getExtra(\"value\"); // \"ok\" ...... } } Note： 1. 新しいインテントは、手動で削除する必要がありませんフレームワーク内で自動的に削除されます。 2. putExtraはstringのkey-value pairメソッドのみを提供します。intまたは他のタイプの値を渡す必要がある場合、文字列型に変換し、onIntentから受信した後、変換を実行する必要があります。 Application activity 終了 上記のopenActivity関数を使用してsubActivityを実行したところ、元のアクティビティに戻りたい場合はどうでしょうか？ 次のコードを使用して、以前のアクティビティに戻ることができます。 EASYUICONTEXT->goBack(); ボタンによってgoBack()がトリガされる場合には、IDEを使用して、ボタンのID値をsys_backに設定すると、直接goBack（）機能を使用することができます。 もし、より階層的なアクティビティに開始アクティビティに戻ろう場合は、次のコードで実装可能です。 EASYUICONTEXT->goHome(); 開始アクティビティに戻ります。 また、ボタンでトリガされる場合は、IDEを使用して、ボタンのID値をsys_homeに設定すると、直接goHome（）機能を使用することができます。 最後に、EasyUIContextのcloseActivity関数を使用してアクティビティを終了することもできます。たとえばsubActivityを終了したい場合は、以下のようにすることができます。 EASYUICONTEXT->closeActivity(\"subActivity\"); この関数を使用するには、呼び出し元が終了するアクティビティの名前を知っている。 Note : この関数は、開始アクティビティを終了することができません。開始アクティビティは常に存在します。 powered by Gitbooklast modified: 2020-12-04 16:13:53 "},"activity_life_cycle.html":{"url":"activity_life_cycle.html","title":"アクティビティのライフサイクル","keywords":"","body":"アクティビティの活動周期 アクティビティ活動周期を紹介する前に、アクティビティ間の階層関係について説明します。 FlywizOSのアプリケーションは、一番最初にmainActivityという開始アクティビティが実行され、openActivity関数を使用して subActivity、thirdActivityを実行することができます。 上の図は、アクティビティ間の関係を示しており、図のようにアクティビティが保存されているスタックがあり、スタックにmainActivityから後で実行されたアクティビティは、既存のアクティビティの上にたまるの形で構成されます。 アクティビティの実行過程 openActivity関数を呼び出した後の過程を見てみましょう。どちらの場合があります。 アクティビティスタックに実行するアクティビティがない場合 subLogic.ccのonUI_init関数を見てみましょう。アクティビティスタックにアクティビティがない場合に、この関数が使用されます。この関数が呼び出されたのは、すべてのコントロールのポインタも初期化が完了したことを意味します。この関数では遅く、次のようにいくつかのタスクを実行することができます。 static void onUI_init() { //Tips :Add the display code of UI initialization here, such as:mTextView1Ptr->setText(\"123\"); LOGD(\"sub onUI_init\\n\"); mTextView1Ptr->setText(\"123\"); } もし初期化時に、ユーザーが特定のデータを渡すしたい場合はonUI_intent関数でそのデータを渡すことができます。 static void onUI_intent(const Intent *intentPtr) { LOGD(\"sub onUI_intent\\n\"); // Judge not empty if (intentPtr) { // Key value analysis std::string cmd = intentPtr->getExtra(\"cmd\"); // \"open\" std::string value = intentPtr->getExtra(\"value\"); // \"ok\" ...... } } onUI_show関数 - アクティビティの表示完了コールバック関数 アクティビティスタックに実行するアクティビティが存在する場合 この場合、該当するアクティビティがアクティビティスタックの最上位に移動され、onUI_init関数は呼び出されません。 実行されるアクティビティが表示される場合直前の最上位のアクティビティは隠されます。 以下はmainActivityでsubActivityが実行されるときのプロセスを示しています。 この過程で重要な場違いな部分はmainActivity hide------>subActivity displayです。 アクティビティ終了過程 アクティビティを終了するには、3つの方法があります。 goBack() - 最上位アクティビティをすぐに終了します。 アクティビティが終了すると、onUI_quit関数が呼び出され、もし解除が必要なリソースがある場合は、この関数から解放することを推奨します。 最上位アクティビティが終了した後、次のアクティビティのonUI_show関数が呼び出され、アクティビティが表示されます。 goHome() - すぐにmainActivityに移動され、mainActivity以外のすべてのアクティビティが終了します。 closeActivity(\"xxx\") - 特定のアクティビティを終了します。（mainActivityを除く）は、アクティビティが最上位アクティビティがなければ、サブアクティビティのonUI_showは呼び出されません。 powered by Gitbooklast modified: 2020-12-02 15:18:44 "},"internal_app.html":{"url":"internal_app.html","title":"システム内蔵アクティビティ","keywords":"","body":" 開発者が直接作成されたアクティビティに加えて、システムで提供されているいくつかの組み込みアクティビティがあります。たとえばTFカードを利用してシステムを更新時に自動的に実行されている内蔵アクティビティがあります。 加えて、設定アクティビティがあり、以下の方法で実行します。 EASYUICONTEXT->openActivity(\"ZKSettingActivity\"); 私たちは、ボタンなどを利用して設定アクティビティを実行することができます。（他のいくつかの内蔵アクティビティもこの方法で実行が可能です。）: static bool onButtonClick_Button1(ZKButton *pButton) { EASYUICONTEXT->openActivity(\"ZKSettingActivity\"); return false; } それぞれのアイテムが選択されると、それぞれ内蔵された他のアクティビティが実行されます。まず、 Networkを選択します。 EASYUICONTEXT->openActivity(\"NetSettingActivity\"); WIFI 設定: EASYUICONTEXT->openActivity(\"WifiSettingActivity\"); If your board supports WIFI, the WIFI will be displayed in the activity when you activate the WIFI on button on the upper right. Hotspot 設定: EASYUICONTEXT->openActivity(\"SoftApSettingActivity\"); Language 設定: EASYUICONTEXT->openActivity(\"LanguageSettingActivity\"); Touch calibration 設定: EASYUICONTEXT->openActivity(\"TouchCalibrationActivity\"); Developer options 設定: EASYUICONTEXT->openActivity(\"DeveloperSettingActivity\"); 現在は、唯一のADBデバッグの設定が可能です。 powered by Gitbooklast modified: 2020-12-03 15:30:47 "},"system_app.html":{"url":"system_app.html","title":"システムアプリケーション","keywords":"","body":"システムアクティビティ IDEを使用して新しいUIファイルを作成するときに、デフォルトUIタイプはNormalであり、一般的な状況では、十分です。 いくつかのシーンでのUIアクティビティの上に浮いている表示領域が必要な場合Normal UIファイルはタスクを実行することができません。他のいくつかの種類のUIファイルを使用します。 UI Typeオプションには、3つの特殊なタイプのオプションがあります。この3つの特殊なタイプには、次に該当する特別なファイル名があります。 statusbar.ftu navibar.ftu screensaver.ftu OKをクリックすると、IDEが自動的にコードを生成します。この3つのタイプのアクティビティの作業は、一般的なアクティビティの作業と同じです。 Status bar 説明：このStatus barはAndroidとiOSの携帯電話のステータスバーと同じ概念でUIの上に浮かぶ、通常の表示領域です。一般的に、いくつかの共通の情報を表示したり、復帰ボタンまたはホームボタンなどを配置するために使用されます。 システムは、Status barを操作するために使用できる2つのインタフェースを提供します。 Show status bar： EASYUICONTEXT->showStatusBar(); Hide status bar： EASYUICONTEXT->hideStatusBar(); 完全なコードは、Sample CodeのStatusBarDemoプロジェクトを参照してください。 Navigation bar 説明：このNavigation barは、Android携帯電話のNavigation barと同じ概念を持っており、一般的にページの下部にあるUIの上に浮かぶ一般的なタスクまたは表示領域です。一般的に、いくつかの操作キーを表示するために使用されます。Navigation barは、実際にStatus barと変わりません。 Show navigation bar： EASYUICONTEXT->showNaviBar(); Hide navigation bar： EASYUICONTEXT->hideNaviBar(); Screensaver 説明：Screensaverアプリケーションは、ユーザーが一定時間の間、システムと相互作用していない場合、システムが自動的にページを開きます。 プロジェクトを右クリックし、プロパティを選択します。ポップアップのプロパティボックスで、スクリーンセーバータイムアウトを秒単位で設定することができます。-1は、スクリーンセーバーがないことを意味します。 コードを使用して、いくつかの設定をすることもできます。jni/include/entry/EasyUIContext.hを参照してください。 必要なヘッダファイル #include \"entry/EasyUIContext.h\" Screensaver timeout時間設定 //Set the screensaver timeout time to 5 seconds EASYUICONTEXT->setScreensaverTimeOut(5); Screensaver許可するかどうかの設定 EASYUICONTEXT->setScreensaverEnable(false); //Turn off screensaver detection EASYUICONTEXT->setScreensaverEnable(true); //Turn on screensaver detection Application scenario: If the upgrade interface cannot enter the screensaver mode, you can turn off the screensaver detection in the upgrade application EASYUICONTEXT->setScreensaverEnable(false). Screensaver実行 EASYUICONTEXT->screensaverOn(); Screensaver終了 EASYUICONTEXT->screensaverOff(); 現在Screensaverが動作していることを確認 EASYUICONTEXT->isScreensaverOn(); 詳細については、Sample CodeのScreensaverDemoプロジェクトを参照してください。 powered by Gitbooklast modified: 2020-12-08 09:57:45 "},"timer.html":{"url":"timer.html","title":"タイマー","keywords":"","body":"タイマー いくつかの場合には、定期的に、特定のタスクを実行する必要があります。例えば、定期的にハートビートパケットを送信、定期的にデータを照会してUIを更新したり、いくつかのポーリングタスクを実行します。これらの要件がある場合は、タイマーが良い選択です。 タイマーの使い方 タイマー使いやすさのために構造体を満たす形でタイマーを追加します。 Logic.ccファイルには、基本的に次のような構造体の配列があります。 /** * Register timer * Just add to this array */ static S_ACTIVITY_TIMEER REGISTER_ACTIVITY_TIMER_TAB[] = { //{0, 6000}, //Timer id=0, Period 6second //{1, 1000}, }; 타이머를 추가하려면 이 구조체 배열에 값을 추가하기 만 하면됩니다. 이 구조체의 정의는 다음과 같습니다. typedef struct { int id; // Timer ID, can not redefine int time; // Timer period unit/ms }S_ACTIVITY_TIMEER; タイマーロジックコードを追加 配列にタイマーを登録した後、タイマーがトリガされると、システムは、 Logic.ccファイルの void onUI_Timer(int id)関数を呼び出します。このタイマーのすべての作業のコードは次のとおりです。この関数に必要なコードを追加します。 /** * Timer trigger function * It is not recommended to write time-consuming operations in this function, otherwise it will affect UI refresh * @param id * The id of the currently triggered timer is the same as the id at registration * @return true * Keep running the current timer * false * Stop running the current timer */ static bool onUI_Timer(int id){ switch (id) { default: break; } return true; } この関数は、基本的に Logic.ccファイルに生成されます。 構造体の配列で定義された idの値と関数のパラメータ idは同じで、 idの値に応じて、必要な操作をすることができます。 [!Note] 注：各アクティビティのタイマーは独立しており、他のアクティビティのタイマーのIDは同じことができます。アクティビティが破壊されない限り、登録されたタイマー(アクティビティのライフサイクル参照)は、常に実行されます。登録後に手動で停止する必要はありませんアクティビティが終了すると、自動的に停止します。 例 次に、具体的な例を挙げタイマーの使用を説明します。 整数の変数があり、毎秒1ずつ増加し、その結果を画面に表示する関数を実装する必要があるとしましょう。 具体的な実装プロセスは、次のとおりです。 まず、UIファイルにText Viewコントロールを追加して、蓄積された結果を表示します。 タイマーを登録してmainLogic.ccのタイマー配列に構造を追加します。タイマーのIDは1であり、時間間隔は1秒です。時間の単位はmsです。 mainLogic.ccで静的定数変数を定義して、0に初期化します。 void onUI_Timer(int id)関数で増加コードを追加して、Text Viewコントロールに表示します。 コンパイル後、ダウンロードして実行します。 Sample code 詳細については、Sample CodeのTimerDemoプロジェクトを参照してください。 powered by Gitbooklast modified: 2020-12-08 15:11:00 "},"how_to_register_timer.html":{"url":"how_to_register_timer.html","title":"タイマー手動操作","keywords":"","body":"任意のタイマー開始と停止 タイマーを追加する方法でREGISTER_ACTIVITY_TIMER_TABを利用する方法があるが、この方法は、タイマーを任意に開始/停止するのに十分ではない、ここでタイマーを追加する別の方法を説明します。 There are three functions that control the timer provided in the Activity class, and the following is an example of using each function. /** * Register timer */ void registerUserTimer(int id, int time); /** * Un-register timer */ void unregisterUserTimer(int id); /** * Reset timer */ void resetUserTimer(int id, int time); logic.ccファイルにタイマーが設定されていることを確認するための変数を宣言します。 /** * Whether the timer is registered */ static bool isRegistered = false; #define TIMER_HANDLE 2 そして、2つのボタンを作成します。このボタンは、タイマーを起動して停止する機能を実行します。 static bool onButtonClick_ButtonTimerOn(ZKButton *pButton) { //Register the timer if not registered if (!isRegistered) { mActivityPtr->registerUserTimer(TIMER_HANDLE, 500); isRegistered = true; } return false; } static bool onButtonClick_ButtonTimerOff(ZKButton *pButton) { //If the timer is already registered, cancel the registration if (isRegistered) { mActivityPtr->unregisterUserTimer(TIMER_HANDLE); isRegistered = false; } return false; } [!Warning] Do not call the above three functions from the registerUserTimer,unregisterUserTimer, and resetUserTimer from theonUI_Timer function. It may cause a deadlock. 예제 코드 サンプルコードTimerDemoプロジェクトを参照してください。 以下はTimer Demoのプレビューです。 powered by Gitbooklast modified: 2020-12-03 14:09:32 "},"linux_serial_programming.html":{"url":"linux_serial_programming.html","title":"Linux serial programming","keywords":"","body":"Linux serial programming [!Note] この章の目的は、開発者にFlywizOSプロジェクトのシリアルポートパーツのコードを理解させることです。 また、私たちは、開発者の簡単な理解のために、実際のコードでは、プロセスを説明するものであり、このプロセスが完了したら、開発者は、自ら必要に応じて、シリアルポートを変更することができるでしょう。 FlywizOSはLinux systemに基づいています。したがって、我々はstandard Linux programming operationにシリアルポートを使用することができます。 基本的なプロセス 私たちは、Linux serial port programmingを5つのコースに分けました : open serial port, configure serial port, read serial port, write serial port, close serial port. Open serial port #include int fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY); openはシステム関数で、nodeのオープンを担当します。 위 코드의 의미는 : 上記のコードの意味は：シリアルポート/dev/ttyS0をreadable/ writable属性で開くしようとします。 もし成功すれば負でない値を返し、その値は、シリアルポートのdescriptorを表します。もし失敗した場合負の値を返し、その値はerror codeです。 /dev/ttyS0はシリアルポートの番号では、WindowsのシステムのCOM1と似ています。 Configure serial portシリアルポートのオープンに成功した後、シリアルポートのBaud rateおよび他のパラメータを設定する必要があります。 int openUart() { int fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY); struct termios oldtio = { 0 }; struct termios newtio = { 0 }; tcgetattr(fd, &oldtio); //Set the baud rate to 115200 newtio.c_cflag = B115200 | CS8 | CLOCAL | CREAD; newtio.c_iflag = 0; // IGNPAR | ICRNL newtio.c_oflag = 0; newtio.c_lflag = 0; // ICANON newtio.c_cc[VTIME] = 0; newtio.c_cc[VMIN] = 1; tcflush(fd, TCIOFLUSH); tcsetattr(fd, TCSANOW, &newtio); //Set to non-blocking mode, this will be used when reading the serial port fcntl(fd, F_SETFL, O_NONBLOCK); return fd; } [!Note] 上記は、プラットフォームのデフォルトのシリアルポート設定です。特別な場合を除き、変更する必要がありません。ハードウェアとドライバの限界として使用しようとする構成が適していないことがあります。 Read serial port #include unsigned char buffer[1024] = {0}; int ret = read(fd, buffer, sizeof(buffer)); readは、システム関数でシリアルポートのデータを読み取る関数です。この関数は、以下の3つのパラメータが必要です。 最初のパラメータは、シリアルポートdescriptorに、open関数の戻り値です。 第二のパラメータは、bufferポインタで読んだシリアルデータが格納されます。 第三パラメータはbufferの大きさで、読み込めるデータの最大値を示します。 もし戻り値が0よりも大きい場合、シリアルポートのデータを正常に読んだという意味であり、同時に戻り値は、読み取ったデータのbyte数です。もし戻り値が0よりも小さいか同じであれば、データがない場合、またはエラーが発生したことを意味します。 Write serial port #include unsigned char buffer[4] = {0}; buffer[0] = 0x01; buffer[1] = 0x02; buffer[2] = 0x03; buffer[3] = 0x04; int ret = write(fd, buffer, sizeof(buffer)); writeはシステム関数で、シリアルポートロールのデータを転送します。この関数は、以下の3つのパラメータが必要です。 最初のパラメータは、シリアルポートdescriptorに、open関数の戻り値です。 第二のパラメータは、送信しようとするbufferのポインタです。 第三パラメータは、伝送しようとするbufferのサイズです。 もし戻り値が0よりも大きい場合、戻り値は、第三のパラメータの値と同じで転送成功を意味します。もし戻り値が0よりも小さいか同じであれば、例外が発生したことを意味します。 [!Note] readはただのシリアルポートで受信された連続的なデータのみを読み取ります。しかし、一度にすべてのデータを読み取る届けを保証しません。 たとえば、シリアルポートに1000bytesを受け、bufferのサイズが1024でたとえ受信されたデータではなく大きいが、最初にread時ただ一部分のみ読み込むことができ、すべてのデータを読むためには、何度もreadをしなければならします。 Close serial port#include close(fd); closeはシステム関数であり、必要なパラメータは、シリアルポートdescriptorです。 総合 以下は簡単なLinux serial port programmingの例です。上記した基本的な機能がすべて使用されました。 #include #include #include int main(int argc, char** argv) { int fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY); if (fd 0) { //Output the read data to the log in turn for (int i = 0; i ソフトウェアでシリアルポートの信頼性の高い通信を確保するための方法 上記の方法を適用して正式な製品を開発するとき、私たちはしばしば次のような問題に直面します。 シリアル通信は、干渉を受けることができていて、信頼できません。 したがって、定型化された通信プロトコルを使用します。このプロトコルは、一般的にframe header、frame end、frame content、checksum、などが含まれています。 プロトコルを使用すると、データの整合性が確保されてシリアル通信を安定的に行うことができます。 例 :プロトコルのフレームヘッダが0xFF、0x55であり、後の8bytesにフレームが完成であれば、上記のコードは、おそらく次のように修正されます。 //Only the key parts are listed, the rest of the code is omitted while (true) { unsigned char buffer[1024] = {0}; int ret = read(fd, buffer, sizeof(buffer)); if (ret > 0) { if ((buffer[0] == 0xFF) && (buffer[1] == 0x55)) { if (ret == 10) { LOGD(\"Read a frame of data correctly\"); } else if (ret 上記のコードで実際頻繁にデータを送受信するテストするとき、プロトコルヘッダは合っているが、フレームのサイズが間違っている場合をよく見るようになります。 その理由は、おそらくLinux system schedulingにあるか、他の所であるでしょう。read関数は、一度にすべてのデータを読み取ることを保証しません。すべてのデータを読み取るいただくためには、何回もread関数を呼び出す必要があり、これはフレームのデータが分かれて読まれるため、これをプロトコルに合わせて一つの有効なフレームを見つける必要があります。このため、コードがもう少し複雑だろうが、これは必要なプロセスです。 これらの分析に基づいて修正されたコードは以下の通りです。 //Increase the scope of the buffer array so that the data will not be cleared in the while loop unsigned char buffer[1024] = {0}; // Add a `legacy` variable to indicate the length of data left in the buffer int legacy = 0; while (true) { //According to the size of the legacy, adjust the start pointer and size of the buffer to prevent data overwriting int ret = read(fd, buffer + legacy, sizeof(buffer) - legacy); if (ret > 0) { if ((buffer[0] == 0xFF) && (buffer[1] == 0x55)) { if ((ret + legacy) == 10) { LOGD(\"Read a frame of data correctly\"); //clean legacy legacy = 0; } else if (ret 実際の商品では、シリアル通信のみを処理するのではなく、画面上の複数のコントロールなどの処理も必要です。 上記の例では、main関数で開始され、whileループでシリアルデータを処理するため、他の処理をすることができません。 しかし、Linux systemはmultithreading機能をサポートするため、私たちは新しいthreadを作り、そのthreadにwhileループ部分を入れる場合は、同時に他のコントロールに対する処理も可能になるでしょう。 要約 Linuxのシリアル通信のプログラミングをするとき、多くの詳細な問題を処理する必要があります。また、FlywizOSは、トラブルシューティングのために一般的なコードを提供しています。 シリアルポートのopen、close、read、write operations 分割されたプロトコルデータの処理 統合データコールバックインターフェースを提供 この章のソースコードは、 open sourceです。開発者が新しいFlywizOSプロジェクトを作成するときに、プロジェクトの uartフォルダにこのコードがあるでしょう。 powered by Gitbooklast modified: 2020-12-03 16:36:21 "},"serial_introdoction.html":{"url":"serial_introdoction.html","title":"はじめに","keywords":"","body":"시리얼 포트 소개 아래 그림은 가장 간단한 통신 모델입니다. LCD와 MCU는 시리얼 포트를 통해 통신하며 정해진 프로토콜로 서로 상호 작용할 수 있습니다. 여기서 주목할 점이 있는데, 기존의 시리얼 포트 LCD는 슬레이브 장치로 사용되고 MCU를 통해 해당 명령을 전송하여 제어합니다. 그러나 FlywizOS의 시리얼 포트 LCD는 호스트처럼 자체적으로 운영이 가능하며 상호 작용할 수 있습니다. 通信に関するコードを最初から開発するには、多くの時間がかかることがあります。開発プロセスを簡素化し、開発者がビジネスロジックの開発に、より多くの注意を払うことができるようFlywizOS IDEは、新しいプロジェクトを作成するときに自動的にシリアル通信コードを生成します。 同時にプロトコルデータとアクティビティの相互作用のためのコールバックインタフェースも提供しています。 開発者は、UIアクティビティのデータの表示にもっと注意を払うことができるよう、通信部は、フレームワークによって自動的に行われます。 通信フレームワークのプロトコル解析部は、開発者が使用する通信プロトコルに応じて変更する必要があり、通信フレームワークの説明の次の章では、ウォンリグァ修正が必要な部分について集中的に調べてみましょう。シリアル通信の例の章では、いくつかの例を介して通信フレームワークの理解を深めます。 powered by Gitbooklast modified: 2020-12-07 16:54:50 "},"serial_framework.html":{"url":"serial_framework.html","title":"通信フレームワークの説明","keywords":"","body":"通信フレームワークの説明 この章では、通信フレームワークの実装原理に焦点を当てており、理論的なものは比較的多いです。最初は、通信モデルのおおよその概要について理解し、提供されているCaseを直接実行見た後戻って原理を理解しましょう。このような過程を経て、実際の実行をしてみると好きなようにプロトコルを定義して使用することができるでしょう。 フレーム ソフトウェアAPP部分は、二つの層に分かれています。 UART - プロトコル解析とカプセル化のシリアルポートHAL層 UartContext：シリアルポートスイッチ、送受信インタフェースを提供するシリアルポートの物理的な制御層 ProtocolData：通信プロトコルで変換された実際の変数を格納するために使用される通信データ構造の定義 ProtocolSender：データ転送のカプセル化完成 ProtocolParser：データのプロトコル解析を完了した、次の構文解析されたデータをProtocolDataのデータ構造体に入れると同時に、アプリケーションがシリアル・データの変更を監視することができるよう、コールバックインターフェースを管理します。 APP - アプリケーションインターフェイス層 ProtocolParserで提供されるインタフェースを介して受信し、監視するシリアルポートのデータを登録して、シリアルポートの更新されたProtocolDataを取得します。 ProtocolSenderで提供されるインタフェースを介してMCUにコマンド情報の転送 このプロセスを再 - 定義してみましょう : receiveとsend両方のプロセスが上下に進んで、各レイヤーの機能が比較的明確であることは明らかです。 コードに対応する具体的な手順は次のとおりです。 受信または送信プロセスに関係なく、シリアルポートの最終的な読み取りおよび書き込み操作は、「UartContext」を介して行われます。これは、標準化されたプロセスであるため、基本的にはUartContextを変更する必要がなく、実装方法を無視することができます。はい、もちろん関心がございましたら、確認することができます。 この時点で、私たちは、この通信モデルの一般的な理解を持っているものであり、後に具体的なコードの実装を説明します。 プロトコル受信部の使用、および編集方法 通信プロトコルの形式を変更 ここで、より一般的な通信プロトコルの例を提供しています。 frame header(2bytes) command(2bytes) length of data(1byte) command data(N) verification(1byte, option) 0xFF55 Cmd len data checksum CommDef.hファイルは、同期フレームのヘッダ情報と最小データパケットサイズ情報を定義します。 // When you need to print the protocol data, open the following macro //#define DEBUG_PRO_DATA // Support checksum verification, open the following macro //#define PRO_SUPPORT_CHECK_SUM /* SynchFrame CmdID DataLen Data CheckSum (Option) */ /* 2Byte 2Byte 1Byte N Byte 1Byte */ // Minimum length with CheckSum: 2 + 2 + 1 + 1 = 6 // Minimum length without CheckSum: 2 + 2 + 1 = 5 #ifdef PRO_SUPPORT_CHECK_SUM #define DATA_PACKAGE_MIN_LEN 6 #else #define DATA_PACKAGE_MIN_LEN 5 #endif // Sync frame header #define CMD_HEAD1 0xFF #define CMD_HEAD2 0x55 ProtocolParser.cppファイル、構成ファイルコマンドの形式 /** * Function: Analyze protocol * Parameters: pData - protocol data, len - data length * Return value: the length of the actual protocol */ int parseProtocol(const BYTE *pData, UINT len) { UINT remainLen = len; // Remaining data length UINT dataLen; // Packet length UINT frameLen; // Frame length /** * The following parts need to be modified according to the protocol format to parse out the data of each frame */ while (remainLen >= DATA_PACKAGE_MIN_LEN) { // Find the data header of a frame while ((remainLen >= 2) && ((pData[0] != CMD_HEAD1) || (pData[1] != CMD_HEAD2))) { pData++; remainLen--; continue; } if (remainLen remainLen) { // Incomplete data frame break; } // To print a frame of data, open the DEBUG_PRO_DATA macro in the CommDef.h file when needed #ifdef DEBUG_PRO_DATA for (int i = 0; i 上記の分析プロセスは少し複雑です。まず、下の図を見た後分析すると、理解し、より容易になります。データパケットは、0または複数のフレームのデータを含めることができます。下の図では、3つのフレームのデータを表示しました。そして、まだデータが5byte不足不完全なデータフレームがあります。不完全なデータフレームは、次のデータパケットにつながります。 プロトコルヘッダを変更する必要があります。 // 1.Modify the definition of the protocol header. If the length of the protocol header changes, pay attention to modifying the // statement of the protocol header judgment part. #define CMD_HEAD1 0xFF #define CMD_HEAD2 0x55 // 2.You need to modify this when the length of the protocol header changes. while ((mDataBufLen >= 2) && ((pData[0] != CMD_HEAD1) || (pData[1] != CMD_HEAD2))) プロトコルの長さの位置を変更または長さの計算方法を変更 // Here pData[4] represents the fifth data is the length byte, if it changes, please modify it here. dataLen = pData[4]; // The frame length is generally the data length plus the head and tail length. If the length calculation method passed in the // agreement changes, modify this part. frameLen = dataLen + DATA_PACKAGE_MIN_LEN; 検証が変更される場合 /** * By default, we turn off checksum verification. If you need to support checksum verification, open the PRO_SUPPORT_CHECK_SUM * macro in the CommDef.h file * When the verification is different, the verification method needs to be modified. * 1.Check the content changes to modify this location * if (getCheckSum(pData, frameLen - 1) == pData[frameLen - 1]) * 2.Check the calculation formula changes to modify the content in the getCheckSum function */ /** * Get checksum code */ BYTE getCheckSum(const BYTE *pData, int len) { int sum = 0; for (int i = 0; i データフレームの受信が完了すると、プログラムはprocParseを呼び出して分析します。 // Support checksum verification, open PRO_SUPPORT_CHECK_SUM macro in CommDef.h file when needed #ifdef PRO_SUPPORT_CHECK_SUM // Get checksum code if (getCheckSum(pData, frameLen - 1) == pData[frameLen - 1]) { // Parse a frame of data procParse(pData, frameLen); } else { LOGE(\"CheckSum error!!!!!!\\n\"); } #else // Parse a frame of data procParse(pData, frameLen); #endif 通信プロトコルのデータをUIコントロールと接続する方法 以前のプロトコルのフレームワークを続けてprocParseの解析部分に入ります。キーコードは、ここにあります : ProtocolParser.cppファイルを開いて、void procParse(const BYTE* pData、UINT len)を検索します。 /* * Protocol analysis * Input parameters : * pData: Start address of a frame of data * len: Length of frame data */ void procParse(const BYTE *pData, UINT len) { /* * Parse the Cmd value to obtain the data and assign it to the sProtocolData structure */ switch (MAKEWORD(pData[2], pData[3])) { case CMDID_POWER: sProtocolData.power = pData[5]; LOGD(\"power status:%d\",sProtocolData.power); break; } notifyProtocolDataUpdate(sProtocolData); } 上記のMAKEWORD(pData[2]、pData[3])は、プロトコルの例でCmd値を示します。 データの分析が完了すると、notifyProtocolDataUpdateを介してUIの更新を通知します。この部分は、以下のUIの更新のセクションを参照してください。 データ構造 上記のプロトコルはsProtocolData構造として解析され、sProtocolDataは、MCU（またはその他のデバイス）のシリアルポートから送信されるデータの値を格納するために使用される静的変数です。このデータ構造は、ProtocolData.hファイルにあります。ここで、プロジェクト全体で使用される通信パラメータを追加することができます。 typedef struct { // You can add protocol data variables here BYTE power; } SProtocolData; UIアップデート IDEはActivity.cppを生成するときにUIアクティビティのregisterProtocolDataUpdateListenerが完了します。これは、データが更新される登録された関数でデータを受信を意味します。 static void onProtocolDataUpdate(const SProtocolData &data) { // Serial data callback interface if (mProtocolData.power != data.power) { mProtocolData.power = data.power; } if (mProtocolData.eRunMode != data.eRunMode) { mProtocolData.eRunMode = data.eRunMode; mbtn_autoPtr->setSelected(mProtocolData.eRunMode == E_RUN_MODE_MANUAL); if (mProtocolData.eRunMode != E_RUN_MODE_MANUAL) { mbtn_external_windPtr->setText(mProtocolData.externalWindSpeedLevel); mbtn_internal_windPtr->setText(mProtocolData.internalWindSpeedLevel); } } ... } コードには、ページの静的変数であるmProtocolData変数があります。onUI_init（）の中の初期化されます。 例 : static SProtocolData mProtocolData; static void onUI_init() { //Tips :Add the display code for UI initialization here, example : mText1->setText(\"123\"); mProtocolData = getProtocolData(); // Initialize the structure of the serial port data. //Start the UI display of the initial page } シリアルデータ転送 ProtocolSender.cppを開きます。 APP層が、MCU（またはその他のデバイス）にデータを送信する場合はsendProtocolを直接呼び出すことで十分です。特定のプロトコルカプセル化はsendProtocol関数によって行われます。ユーザーは、自分のプロトコルの要件に応じて、この部分のコードを変更することができます。 /** * Need to be spliced according to the protocol format, the following is just a template */ bool sendProtocol(const UINT16 cmdID, const BYTE *pData, BYTE len) { BYTE dataBuf[256]; dataBuf[0] = CMD_HEAD1; dataBuf[1] = CMD_HEAD2; // Sync header dataBuf[2] = HIBYTE(cmdID); dataBuf[3] = LOBYTE(cmdID); // Command ID dataBuf[4] = len; UINT frameLen = 5; // Data for (int i = 0; i send(dataBuf, frameLen); } アクティビティのボタンを押すと、動作が可能です。 BYTE mode[] = { 0x01, 0x02, 0x03, 0x04 }; sendProtocol(0x01, mode, 4); powered by Gitbooklast modified: 2020-12-07 16:33:22 "},"serial_example.html":{"url":"serial_example.html","title":"シリアル通信の例","keywords":"","body":"シリアル通信の例 前の章、通信フレームワークの説明を先に要約すると、シリアル通信は、主に次の4つのポイントがあります。 データ受信 データ分析 データ表示 データ転送 データ分析部分は、比較的複雑であり、特定の通信プロトコルに応じて変更されるべきです。この章では、理論的な内容について話していないし、いくつかの実際のケースを提供しています。 事例1 ここでは、以前に実装した簡単な通信プログラムを例に説明します。完全なコードは、Sample CodeのUartDemoプロジェクトで確認することができます。達成しようとする最終的な効果は、ディスプレイのメーターの回転を制御するために、シリアルポートを介してコマンドを送信することです。UIレンダリングは、次のとおりです。 メーターの回転を制御するには、3つの位置だけを変更します。 1) 先に紹介したプロトコルの形式を再見、ここに0x0001の値に対応する独自のプロトコルコマンドCMDID_ANGLEを追加します。 Protocol header(2bytes) Command(2bytes) length of data(1byte) data(N) checksum(1byte option) 0xFF55 0x0001（See belowCMDID_ANGLE） 1 angle checksum プロトコルデータ構造に1つの変数を追加します。ProtocolData.hを参照してください。 /******************** CmdID ***********************/ #define CMDID_POWER 0x0 #define CMDID_ANGLE 0x1 // new command ID /**************************************************/ typedef struct { BYTE power; BYTE angle; // Added variable to save pointer angle value } SProtocolData; 2) 以前に定義されたプロトコルの形式を使い続けており、プロトコル解析部を変更する必要がありません。procParseからCmdID値のみを処理します。 /** * Parse each frame of data */ static void procParse(const BYTE *pData, UINT len) { // CmdID switch (MAKEWORD(pData[3], pData[2])) { case CMDID_POWER: sProtocolData.power = pData[5]; break; case CMDID_ANGLE: // New part, save angle value sProtocolData.angle = pData[5]; break; } // Notify protocol data update notifyProtocolDataUpdate(sProtocolData); } 3) プロトコルデータを受信するアクティビティのコールバック関数を見てみましょう。logic/mainLogic.ccを参照してください。 static void onProtocolDataUpdate(const SProtocolData &data) { // Serial data callback function // Set the rotation angle of the pointer mPointer1Ptr->setTargetAngle(data.angle); } 上記のプロセスを完了した後、MCUを介して対応するコマンドを画面に転送するだけでメーターの回転を見ることができます。簡単さのために、このプログラムでは、チェックサム検証を実行していないプロトコルデータは、次のとおりです。 protocol header CmdID length of data angle data 0xFF 0x55 0x00 0x01 0x01 angle CommDef.hファイルでDEBUG_PRO_DATAマクロを開き、受信したプロトコルデータを出力することができます。 この時点で、シリアルポートは、データ受信--->データ分析--->データ表示として1つのコマンドの処理が完了しました。 最後に、シリアルポートデータ転送をシミュレートしてみましょう。提供するプログラムでタイマーが実行され、データ転送が2秒ごとにシミュレーションされます。 static bool onUI_Timer(int id) { // Simulate sending serial data BYTE data = rand() % 200; sendProtocol(CMDID_ANGLE, &data, 1); return true; } 上記のコードは、実際の角度値の設定をシミュレートするためのものです。ボードで通信シリアルポートのTXとRXを短絡させて自発送受信を実装することができ、メーターが回転するのを見ることができます。 ここまでのシリアルポートデモプログラムの紹介が完了しました。開発者は、デモプログラムをコンパイルして、マシンに燃焼して効果を確認することができます。次に、これをベースに、いくつかのプロトコルを追加して、テストして、全体の通信プロセスに慣れましょう。 powered by Gitbooklast modified: 2020-12-07 16:19:00 "},"serial_configuration.html":{"url":"serial_configuration.html","title":"シリアルポートの設定","keywords":"","body":"シリアルポートを構成する方法 シリアルポート番号を選択 ソフトウェアとハードウェアの設計の互換性のためにソフトウェアのシリアル番号がハードウェアのシリアル番号の識別と異なる場合があります。具体的な関係は、次のとおりです。 F9311s Series platform Software serial port number Hardware serial port number ttyS0 UART1 ttyS1 UART2 F9306 Series platform Software serial port number Hardware serial port number ttyS0 UART0 ttyS1 UART1 ttyS2 UART2 シリアルポートBaud rate構成 新しいプロジェクトを作成するときにBaud rateを設定します。 プロジェクトのプロパティでBaud rate構成 プロジェクトを右クリックし、ポップアップメニューからPropertyを選択すると、次のプロパティボックスが表示されます。 シリアルポートを開くと閉じる jni/Main.cppを開きます。プログラムが初期化されて終了したとき、シリアルポートが開閉を見ることができます。 void onEasyUIInit(EasyUIContext *pContext) { LOGD(\"onInit\\n\"); // open serial port UARTCONTEXT->openUart(CONFIGMANAGER->getUartName().c_str(), CONFIGMANAGER->getUartBaudRate()); } void onEasyUIDeinit(EasyUIContext *pContext) { LOGD(\"onDestroy\\n\"); // close serial port UARTCONTEXT->closeUart(); } powered by Gitbooklast modified: 2020-12-07 15:57:44 "},"multiuart.html":{"url":"multiuart.html","title":"複数のシリアルポートを構成する","keywords":"","body":"複数のシリアルポートを構成する 基本的に作成されたプロジェクトは、1つのシリアルポートのみをサポートしますが、必要に応じて2つまたはそれ以上のシリアルポートを使用することができます。まず、DoubleUartDemo例をダウンロードしてください。この例では、複数のシリアルポートをサポートしているプロジェクトについてのコードが含まれています。 変更 変更は以下の通りです。 Uartのいくつかのコードが変更されました。だからproject propertiesで設定した属性は、もはや有効ではありません。 使用するシリアルポートの番号とBaudrateはjni/uart/UartContext.cppファイルのinit()関数を参考にして修正してください。 void UartContext::init() { uart0 = new UartContext(UART_TTYS0); uart0->openUart(\"/dev/ttyS0\", B9600); uart1 = new UartContext(UART_TTYS1); uart1->openUart(\"/dev/ttyS1\", B9600); } シリアルポートにデータを送信します。 unsigned char buf[2] = {1, 1}; sendProtocolTo(UART_TTYS1, 1, buf, 2); //Send to TTYS1 serial port unsigned char buf[2] = {0}; sendProtocolTo(UART_TTYS0, 1, buf, 2);//Send to TTYS0 serial port シリアルポートのデータを受信する方法は、既存のプロジェクトと同じです。もしどこから来たシリアルポートのデータなのか区別する必要がある場合は、 SProtocolData structureにメンバ変数を追加して区別をすることができます。uart/ProtocolData.h変更 typedef struct { BYTE power; int uart_from; //From which serial port } SProtocolData; uart/ProtocolParser.cpp変更 /** * Analyze each frame of data */ static void procParse(int uart, const BYTE *pData, UINT len) { // CmdID switch (MAKEWORD(pData[3], pData[2])) { case CMDID_POWER: sProtocolData.power = pData[5]; break; } sProtocolData.uart_from = uart; //Identify which serial port the frame comes from // Notify protocol data update notifyProtocolDataUpdate(sProtocolData); } Logic.ccでuart_fromフィールドを確認して、どのシリアルポートから受信したデータであることを決定することができます。 static void onProtocolDataUpdate(const SProtocolData &data) { LOGD(\"onProtocol %d\", data.uart_from); char buf[128] = {0}; snprintf(buf, sizeof(buf), \"Receive serial port %d data\", data.uart_from); mTextview1Ptr->setText(buf); } サンプルコード サンプルコードのDoubleUartDemoプロジェクトを参照してください。 powered by Gitbooklast modified: 2020-12-04 09:55:49 "},"wifi.html":{"url":"wifi.html","title":"WIFI設定","keywords":"","body":"WIFI設定アクティビティ開始 EASYUICONTEXT->openActivity(\"WifiSettingActivity\"); WiFi動作関数の説明 WifiManager 객체 가져오기 #include \"net/NetManager.h\" WifiManager *pWM = NETMANAGER->getWifiManager(); // You can define a macro to facilitate the following function calls #define WIFIMANAGER NETMANAGER->getWifiManager() 機器がWIFIをサポートすることを確認 WIFIMANAGER->isSupported(); WIFIがOnであることを確認し WIFIMANAGER->isWifiEnable(); WIFIオン WIFIMANAGER->enableWifi(true); WIFI検索 WIFIMANAGER->startScan(); WIFI接続 WIFIMANAGER->connect(ssid, pw); WIFI接続を解除 WIFIMANAGER->disconnect(); WIFIが接続されて WIFIMANAGER->isConnected(); 接続されたWIFI情報を取得する WIFIMANAGER->getConnectionInfo(); WIFI情報監視機能の登録および登録解除 void addWifiListener(IWifiListener *pListener); void removeWifiListener(IWifiListener *pListener); Sample code 詳細については、Sample CodeのNetDemoプロジェクトを参照してください。 powered by Gitbooklast modified: 2020-12-08 16:06:04 "},"wifi_ap.html":{"url":"wifi_ap.html","title":"Hotspot設定","keywords":"","body":"Hotspot設定アクティビティ開始 EASYUICONTEXT->openActivity(\"SoftApSettingActivity\"); Hotspot動作関数の説明 SoftApManagerオブジェクトの読み込み #include \"net/NetManager.h\" SoftApManager *pSAM = NETMANAGER->getSoftApManager(); // You can define a macro to facilitate the following functino calls #define SOFTAPMANAGER NETMANAGER->getSoftApManager() Hotspotオン SOFTAPMANAGER->setEnable(true); Hotspotがオンであることを確認し SOFTAPMANAGER->isEnable(); 現在hotspotの状態を取得 SOFTAPMANAGER->getSoftApState(); // There are the following states E_SOFTAP_DISABLED // Disabled E_SOFTAP_ENABLING // During tunning on E_SOFTAP_ENABLED // Turn on successfully E_SOFTAP_DISABLING // During tunning off E_SOFTAP_ENABLE_ERROR // Turn on failed Hotspot名前とパスワードを設定 SOFTAPMANAGER->setSsidAndPwd(\"zkswe\", \"abcd1234\"); Hotspot名前とパスワードを取得する SOFTAPMANAGER->getSsid(); SOFTAPMANAGER->getPwd(); Hotspot状態監視機能の登録と解除 void addSoftApStateListener(ISoftApStateListener *pListener); void removeSoftApStateListener(ISoftApStateListener *pListener); powered by Gitbooklast modified: 2020-12-08 16:07:25 "},"audio.html":{"url":"audio.html","title":"Audioプレイ","keywords":"","body":"Music player ZKMediaPlayer:: E_MEDIA_TYPE_AUDIOタイプのZKMediaPlayerクラスオブジェクトを生成します static ZKMediaPlayer sPlayer(ZKMediaPlayer::E_MEDIA_TYPE_AUDIO); メッセージ監視関数を登録します。 // The message monitoring interface is as follows class PlayerMessageListener : public ZKMediaPlayer::IPlayerMessageListener { public: virtual void onPlayerMessage(ZKMediaPlayer *pMediaPlayer, int msg, void *pMsgData) { switch (msg) { case ZKMediaPlayer::E_MSGTYPE_ERROR_INVALID_FILEPATH: case ZKMediaPlayer::E_MSGTYPE_ERROR_MEDIA_ERROR: // Error message break; case ZKMediaPlayer::E_MSGTYPE_PLAY_STARTED: // Start playback message break; case ZKMediaPlayer::E_MSGTYPE_PLAY_COMPLETED: // Stop playback message break; } } }; static PlayerMessageListener sPlayerMessageListener; // Register message monitoring sPlayer.setPlayerMessageListener(&sPlayerMessageListener); メンバ関数の説明 sPlayer.play(\"/mnt/extsd/music/test.mp3\"); // Play the file in the specified path sPlayer.pause(); // Pause playback sPlayer.resume(); // Resume playback sPlayer.seekTo(int msec); // Jump to msec time to play, msec unit: ms sPlayer.stop(); // Stop playback sPlayer.isPlaying(); // Is it playing?, return type is bool sPlayer.getDuration(); // Get the total time of current playing music sPlayer.getCurrentPosition(); // Get the current playing time of the currently playing song sPlayer.setVolume(0.5, 0.5); // Set media volume, volume range: 0.0 ~ 1.0 [!Note] オーディオファイルの再生時間が短すぎる場合、プレイができない場合があります。 Sample CodeのMusicDemoプロジェクト参照してください powered by Gitbooklast modified: 2020-12-02 15:18:24 "},"thread.html":{"url":"thread.html","title":"Thread","keywords":"","body":"Thread システムは、pthreadをサポートします。pthreadインターフェースを理解すると、posixインターフェースを使用してスレッドを実装することもできます。また、pthreadのラッパークラスを提供します。ここでは、次の3つの部分が含まれます。 Thread.h：Thread class Mutex.h：Mutex class Condition.h：Condition class 使い方 ヘッダファイルをインクルードした後、Threadクラスを継承してvirtual bool threadLoop（）関数を実装します。また、必要に応じてreadyToRun（）関数を実装します。 #include class MyThread: public Thread { public: /** * After the thread is created successfully, this function will be called, and some initialization operations can be done * in this function * return true Continue thread * false Exit thread */ virtual bool readyToRun() { LOGD(\"Thread has been created\"); return true; } /** * Thread loop function * * return true Continue thread loop * false Exit thread */ virtual bool threadLoop() { LOGD(\"Thread loop function\"); //Check if there is a request to exit the thread, if so, return false and exit the thread immediately if (exitPending()) { return false; } //Accumulate the count and display it on the screen loop_count += 1; mTextView2Ptr->setText(loop_count); //To observation, add sleep 500ms here usleep(1000 * 500); //Return true, continue the next thread loop return true; } }; Thread objectインスタンス化 static MyThread my_thread; Thread開始 //Call the run function of the thread class to start the thread //The parameter is the thread name, which can be arbitrarily specified. my_thread.run(\"this is thread name\"); Thread終了 Threadクラスは、同期または非同期の両方の関数としてthreadを終了することができ、違いは次のとおりです。 void requestExitAndWait() //Request to exit the thread and wait. The function does not return until the thread completely exits my_thread.requestExitAndWait(); void requestExit() //Request to exit the thread, the function returns immediately after sending the request but at this time, it does not mean //that the thread has also exited my_thread.requestExit(); 上記の二つの関数のいずれかを呼び出した後threadLoop関数でbool exitPending（）のメンバー関数を使用してスレッド終了要求があるかを確認することができます。 virtual bool threadLoop() { LOGD(\"Thread loop function\"); //Check if there is a request to exit the thread, if so, return false and exit the thread immediately if (exitPending()) { return false; } return true; } [!Note] 上記の関数は、threadを強制的に終了せずにthread終了を要求する表示を追加します。 threadLoop関数で特定のタスクを実行しており、threadLoop関数が終了していない場合は、threadが停止されません。 正しいアプローチは、threadLoopでthread終了要求を確認するか、終了条件を確認し、falseを返すことです。 [!Warning] threadLoop関数でrequestExitAndWaitとrequestExit関数を呼び出すことは、デッドロックを引き起こす可能性があり、禁止されています。 Threadが実行されていることを確認if (my_thread.isRunning()) { mTextView4Ptr->setText(\"Now running\"); } else { mTextView4Ptr->setText(\"Already stop\"); } Threadプロセス 上記の手順をフローチャートと理解すれば、より簡単に深く理解できます。 Sample code 詳細については、Sample CodeのThreadDemoプロジェクトを参照してください。 powered by Gitbooklast modified: 2020-12-08 11:24:07 "},"mutex.html":{"url":"mutex.html","title":"Mutex","keywords":"","body":"Mutex/lock 他の章で紹介したthreadはどのような場合に、プログラムにバグを引き起こす可能性があります。 Multi-threadedプログラミングでこう現状況は非常に一般的です。 簡単に理解するために、次のコードでこのような状況を説明します。 struct Studentをグローバル変数として宣言した後、2つのthreadを定義します。A threadはstudent変数に値を代入して、B threadはstudentの値をコピーして、各メンバ変数の値をログに出力します。Question : もし両方のthreadが同時に起動すると、B threadから出力される結果は、どうなるでしょう？ #include struct Student { char name[24]; int age; int number; }; struct Student student = {0}; class AThread: public Thread { public: virtual bool threadLoop() { snprintf(student.name, sizeof(student.name), \"David\"); student.age = 10; student.number = 20200101; return true; } }; class BThread: public Thread { public: virtual bool threadLoop() { struct Student s = student; LOGD(\"name : %s\", s.name); LOGD(\"age : %d\", s.age); LOGD(\"student id number : %d\", s.number); return true; } }; static AThread athread; static BThread bthread; まず、私たちが望む結果は以下の通りです。 name：David age：10 student id number：20200101 しかし、実際の十分なテストを行う場合には、ほとんどの結果は、我々が予想していた結果を出力しますが、以下のような結果が出力される場合も発生します。 name： age：0 student id number：0 name：xiaoming age：0 student id number：0 name：xiaoming age：10 student id number：0 もしプログラムで \"abnormal\"した結果が出た場合は、これはバグで判断することができます。 原因分析 Multiple threadsプログラムでthreadの実行順序は、システムのスケジューリングによって決定されます。A threadのinstructionsをすべて実行した後、B threadのinstructionを実行し、再びA threadのinstructionsを実行することもできます。 上記の例では、student変数に完全な値を割り当てるための3つのstatementsがあります。もし最初のstatementのみが実行されたとき（nameの値だけ割り当てられる）、システムがB threadでスイッチングをしました。 その後、この時B threadが読むstudentはnameのみ有効であり、ageとnumberは0である状態で「abnormal」が発生します。 解決方法 これらの理由から、A threadのinstructionsがすべて完了した後、B threadにスイッチングすることを確立することができている場合、この問題は解決されます。 実装方法 これらのプログラムでmutual exclusion lockは、データ共有のための整合性を確立してくれることができる概念です。「mutual exclusion lock」と呼ばれることがあると、そのオブジェクトは、いくつかの瞬間でも一つのthreadのみ、そのオブジェクトにアクセスすることができます。 以下はFlywizOSで提供されるmutual exclusion lock機能です。 Mutex 定義 static Mutex mutex1; Lockが必要なところMutex:: Autolock class instanceを定義します。 // This class utilizes the life cycle of local variables and the structure and destructor of C++ classes to automatically // implement locking and unlocking operations. Mutex::Autolock _l(mutex1); 次のコードは、上記のAとB thread例を用いて修正されたコードです。 #include struct Student { char name[24]; int age; int number; }; struct Student student = {0}; //Define a mutex static Mutex mutext1; class AThread: public Thread { public: virtual bool threadLoop() { //Lock the statement of the function, and automatically unlock after the function ends Mutex::Autolock _lock(mutext1); snprintf(student.name, sizeof(student.name), \"David\"); student.age = 10; student.number = 20200101; return true; } }; class BThread: public Thread { public: virtual bool threadLoop() { //Lock the statement of the function, and automatically unlock after the function ends Mutex::Autolock _lock(mutext1); struct Student s = student; LOGD(\"nanme：%s\", s.name); LOGD(\"age：%d\", s.age); LOGD(\"student id number：%d\", s.number); return true; } }; static AThread athread; static BThread bthread; コードでlockは、両方のthreadでstudentと関連して動作します。 A threadが実行されたとき、Mutex:: Autolock_lock(mutext1); statementを通じてmutex1のmutexが得られます。以後A threadがunlockされず、B threadが実行されると、B threadもMutex:: Autolock_lock(mutext1); statementでmutext1のmutexを欲しくなります。 しかし、このmutexはすでにA threadによって獲得されたのでB threadがこれ獲得するためには、A threadがそのmutexをunlockするのを待つしかなく、mutexを獲得した後に、通常次のstatementに進むことができます。 基本的なプロジェクトにもこれと関連したコードを参照することができます。(jni/uart/ProtocolParser.cpp) void registerProtocolDataUpdateListener(OnProtocolDataUpdateFun pListener) { Mutex::Autolock _l(sLock); LOGD(\"registerProtocolDataUpdateListener\\n\"); if (pListener != NULL) { sProtocolDataUpdateListenerList.push_back(pListener); } } Note : 以上の例でmutexの概念を十分に理解していなかった場合、インターネットを介して、より多くの情報を得ることができます。 Note : FlywizOSのシステムは、Linuxをベースにしており、standard Linuxのmutexも使用することができます。 powered by Gitbooklast modified: 2020-12-04 10:18:53 "},"screenshot.html":{"url":"screenshot.html","title":"スクリーンショット","keywords":"","body":"スクリーンショット 製品開発の後マニュアル作成時に実行されているインターフェースのスクリーンショットが必要な場合があり、下のスクリーンショットコードを参照してください。 Ready screenshot.hソースファイルをダウンロードして、プロジェクトjniディレクトリに保存します。 Use 必要なヘッダファイル#include \"screenshot.h\" 関数を呼び出して、スクリーンショットを撮るstatic bool onButtonClick_Button1(ZKButton *pButton) { //Capture the current screen, save it as a bmp picture, and save it to the TF card directory //Each time this function is called, the name of the saved picture is incremented //Example - screenshot01.bmp、screenshot02.bmp、screenshot03.bmp Screenshot::AutoSave(); return false; } 写真は基本的にTFカードに保存されるので、TFカードを挿入して、スクリーンショットを撮りなさい。 別の場所に保存する必要がある場合は、ソースコードを直接変更することができます。 powered by Gitbooklast modified: 2020-12-07 15:26:20 "},"data.html":{"url":"data.html","title":"データストア","keywords":"","body":"データストア 特定のアプリケーションのシナリオでは、特定の情報（アカウント番号、パスワード、設定情報など）を永遠に保存する必要があります。これらのデータの特徴は、データ量が小さくてもアクセスが容易する必要があります。この場合、データベースを利用することなく、FlywizOSでは簡単にkey-valueの組み合わせ形式でデータを保存する機能を提供します。 必要ヘッダファイル #include \"storage/StoragePreferences.h\" 関連する関数 // Storage function static bool putString(const std::string &key, const std::string &val); static bool putInt(const std::string &key, int val); static bool putBool(const std::string &key, bool val); static bool putFloat(const std::string &key, float val); // Delete the specified key static bool remove(const std::string &key); // Clear storage data static bool clear(); // Get function. The corresponding key value cannot be obtained, then the default value of defVal is returned static std::string getString(const std::string &key, const std::string &defVal); static int getInt(const std::string &key, int defVal); static bool getBool(const std::string &key, bool defVal); static float getFloat(const std::string &key, float defVal); [!Warning] このインターフェイスは、フラッシュにデータをファイル形式で保存するので、頻繁保存は、フラッシュの損傷を引き起こす可能性がありますので、避けるべきです。 データを保存するためのパーティションのサイズは制限されています。モデルに応じてパーティションのサイズは異なりますが、512KBを超えないように維持することをお勧めします。 使用例 保存 //Save the string, use \"username\" as the alias, the value is the name string const char* name = \"zhang san\"; StoragePreferences::putString(\"username\", name); //Save the boolean variable, alias \"power\", the value is true StoragePreferences::putBool(\"power\", true); //Save a floating point number, aliased to \"temperature\", the value is 30.12 StoragePreferences::putFloat(\"temperature\", 30.12); //Save the integer, use \"age\" as the alias, the value is 20 StoragePreferences::putInt(\"age\", 20); 読む //Read the value of the \"username\" key, if there is no value, return an empty string std::string name = StoragePreferences::getString(\"username\", \"\"); //Log print the read string LOGD(\"username %s\\n\", username.c_str()); //Read the Boolean variable, if there is no value, then specify to return false bool power = StoragePreferences::getBool(\"power\", false); //Read floating-point number, if there is no value, specify to return 0 float temperature = StoragePreferences::getFloat(\"temperature\", 0); //Read floating-point number, if there is no value, specify to return 0 int age = StoragePreferences::getInt(\"age\", 18); 削除 // Clear a value individually StoragePreferences::remove(\"username\"); StoragePreferences::remove(\"power\"); StoragePreferences::remove(\"temperature\"); StoragePreferences::remove(\"age\"); // Clear all values StoragePreferences::clear(); 修正 もし、特定の値を変更したい場合は、同じキーを使って新しい値を保存します。 powered by Gitbooklast modified: 2020-12-02 16:41:12 "},"vireeprom.html":{"url":"vireeprom.html","title":"Emulated EEPROM","keywords":"","body":"EEPROM機能のエミュレーション EEPROM(電源が供給されて、読み取り - 書き込み可能なメモリ)は、ユーザーが変更できるメモリ（ROM）には、通常よりも高い電圧に削除と再プログラミング(再書き込み)を行うことができます。 エミュレーション原理 このシステムは、独自のファイルシステムがあるLinuxベースで保存されたデータをNorFlashに記録されます(削除回数が100,000回以上、Nandfalshがありません。NandFlashは不良ブロックが発生した後、様々なリスクが発生する可能性があります)。 /dataパーティションは、ユーザーデータのためにFlywizOS内部に予約されています。マイクロコントローラの動作に慣れているユーザーの便宜のために /dataパーティションの下にファイルを作成して、EEPROM空間をシミュレートします。(/dataパーティションのサイズは、特定のシステムのバージョンに応じて、1Mまたは数百KBの範囲) 使用シナリオ 電源がオフの状態でデータを保持します。 実装段階 まず、プロジェクトの jniディレクトリにヘッダファイルを作成します。プロジェクトでjniを選択し、マウスの右ボタンをクリックして、ポップアップコンテキストメニューからNew -> Header Fileオプションを選択し、名前をvireeprom.hと指定して、[Finish]をクリックします。 追加したばかりのヘッダーファイルに次のコードをコピーします。(ヘッダファイルの作成時に、いくつかの内容が自動的に追加および削除することができます。)このコードは、EEPROMのエミュレーション機能を実装します。 #ifndef JNI_VIREEPROM_H_ #define JNI_VIREEPROM_H_ #include #include #include /** * The storage size of the emulated EEPROM, in bytes, it is recommended not to be too large */ #define EEPROM_SIZE 1024 /** * Actually saved as a file /data/eeprom.eep */ #define EEPROM_FILE \"/data/eeprom.eep\" class VirEEPROM { public: VirEEPROM() { memset(buff_, 0, sizeof(buff_)); file_ = fopen(EEPROM_FILE, \"rb+\"); if (file_) { fread(buff_, 1, EEPROM_SIZE, file_); fseek(file_, 0, SEEK_END); int f_size = ftell(file_); //Adjust the file to a suitable size if (f_size != sizeof(buff_)) { ftruncate(fileno(file_), sizeof(buff_)); fseek(file_, 0, SEEK_SET); fwrite(buff_, 1, sizeof(buff_), file_); fflush(file_); sync(); } } else { file_ = fopen(EEPROM_FILE, \"wb+\"); //Adjust the file to a suitable size ftruncate(fileno(file_), sizeof(buff_)); } } virtual ~VirEEPROM() { if (file_) { fflush(file_); fclose(file_); sync(); } } /** * Return : less than 0 is failure, greater than 0 is the actual number of bytes written * Parameter: The data pointer that value needs to save, which can be a structure pointer, char*, int*..., size is the * size of the data to be saved * Examples of use: * const char buff[]=\"12345678\"; * VIREEPROM->WriteEEPROM(0,buff,sizeof(buff); */ int Write(int addr, const void* value, int size) { if (file_ == NULL) { return -1; } if ((addr >= EEPROM_SIZE) || ((addr + size) > EEPROM_SIZE)) { //Oversize return -2; } memcpy(buff_ + addr, value, size); if (0 != fseek(file_, addr, SEEK_SET)) { return -3; } int n = fwrite((char*)value, 1, size, file_); fflush(file_); sync(); return n; } /** * Return : less than 0 is a failure, greater than 0 is the number of bytes actually read * Parameter: the data pointer to be read by value, which can be a structure pointer, char*, int*..., size is the size of * the data to be read * Examples of use: * char buff[9]; * VIREEPROM->ReadEEPROM(0,buff,sizeof(buff); */ int Read(int addr,void* value,int size) { if (file_ == NULL) { return -1; } if ((addr >= EEPROM_SIZE) || ((addr + size) > EEPROM_SIZE)) { //Oversize return -2; } memcpy(value, buff_ + addr, size); return size; } /** * Return： * 0 Success * Less than 0 failed */ int Erase() { if (file_ == NULL) { return -1; } if (0 != fseek(file_, 0, SEEK_SET)) { return -2; } memset(buff_, 0, sizeof(buff_)); if (sizeof(buff_) != fwrite(buff_, 1, sizeof(buff_), file_)) { return -3; } fflush(file_); sync(); return 0; } static VirEEPROM* getInstance() { static VirEEPROM singleton; return &singleton; } private: unsigned char buff_[EEPROM_SIZE]; FILE* file_; }; #define VIREEPROM VirEEPROM::getInstance() #endif /* JNI_VIREEPROM_H_ */ 今までの準備作業が完了したので、正常であるかをテストするために、いくつかの例を作成します。 mainLogic.ccソースファイルを開き、ファイルの先頭にある \"vireeprom.h\"ヘッダファイルをインクルードしてください。 #include \"vireeprom.h\" Test code static void onUI_init(){ //The value array, starting from address 0, is written sequentially char value[4] = {1, 2, 3, 4}; VIREEPROM->Write(0, value, sizeof(value)); //Start reading from address 0, read 4 bytes in sequence, and save the read content in buf char buf[4] = {0}; VIREEPROM->Read(0, buf, sizeof(buf)); //Output log LOGD(\"Data read : %02x, %02x, %02x, %02x\", buf[0], buf[1], buf[2], buf[3]); //Clear all eeprom to 0 VIREEPROM->Erase(); } powered by Gitbooklast modified: 2020-12-08 16:04:07 "},"brightness.html":{"url":"brightness.html","title":"画面の明るさを調整","keywords":"","body":"明るさの調整 必要なヘッダファイル#include \"utils/BrightnessHelper.h\" Dimming スクリーンの明るさの調整 明るさの範囲は、0〜100です。（Note：0このスクリーンがオフを意味しません） //Adjust the screen brightness to 80 BRIGHTNESSHELPER->setBrightness(80); 現在の明るさの値を取得するBRIGHTNESSHELPER->getBrightness(); スクリーンオン/オフ スクリーンオン BRIGHTNESSHELPER->screenOff(); スクリーンオフ BRIGHTNESSHELPER->screenOn(); 明るさの値を保存 システムが起動されると、スクリーンは、最後に調整された明るさの値を基に設定されます。もし明るさの値を保存したくない場合は、プロジェクトのプロパティで、これを変更することができます。 powered by Gitbooklast modified: 2020-12-02 10:15:44 "},"system_time.html":{"url":"system_time.html","title":"システム時間","keywords":"","body":"システム時間 必要なヘッダファイル #include \"utils/TimeHelper.h\" tm構造体の各変数の説明 struct tm { int tm_sec; /* second - the value range is [0,59] */ int tm_min; /* minute - the value range is [0,59] */ int tm_hour; /* hour - the value range is [0,23] */ int tm_mday; /* Day of the month - the value range is[1,31] */ int tm_mon; /* Month (starting from January, 0 means January) - the value range is[0,11] */ int tm_year; /* Year, the value starts from 1900 */ ... } 現在の日付と時刻を取得する struct tm *t = TimeHelper::getDateTime(); 時間表示の例 static void updateUI_time() { char timeStr[20]; static bool bflash = false; struct tm *t = TimeHelper::getDateTime(); sprintf(timeStr, \"%02d:%02d:%02d\", t->tm_hour,t->tm_min,t->tm_sec); mTextTimePtr->setText(timeStr); // Pay attention to modify the control name sprintf(timeStr, \"%d / %02d / %02d\", 1900 + t->tm_year, t->tm_mon + 1, t->tm_mday); mTextDatePtr->setText(timeStr); // Pay attention to modify the control name static const char *day[] = { \"Sun.\", \"Mon.\", \"Tue.\", \"Wed.\", \"Thu.\", \"Friu\", \"Sat.\" }; sprintf(timeStr, \"day of the week %s\", day[t->tm_wday]); mTextWeekPtr->setText(timeStr); // Pay attention to modify the control name } 時間設定の例 // Use tm structure to set time static void setSystemTime() { struct tm t; t.tm_year = 2017 - 1900; t.tm_mon = 9 - 1; t.tm_mday = 13; t.tm_hour = 16; t.tm_min = 0; t.tm_sec = 0; TimeHelper::setDateTime(&t); } // Or set the time with a string date str format: 2017-09-13 16:00:00 TimeHelper::setDateTime(\"2017-09-13 16:00:00\"); 詳細については、Sample Codeを参照してください。 powered by Gitbooklast modified: 2020-12-08 10:40:07 "},"tf.html":{"url":"tf.html","title":"TF card","keywords":"","body":"TF card TFカードを挿入すると、システムが自動的に/mnt/extsdディレクトリにマウントします。 ファイルのパス TFカードのルートディレクトリにtest.txtファイルがある場合は、ボードでは、このファイルの絶対パスは/mnt/extsd/test.txtです。 TFカードを送るの注意事項 TFカードにファイルを書き込むには、次の順序に従ってください。そうでなければ正常に書き込まれていない状況が発生する可能性があります。 カードの挿入 - >電源オン - >ファイルを開く - >ファイルの読み取りと書き込み - >fflush() - >ファイルを閉じる - >sync() - >カードの取り外し つまり、TFカードを使う必要がある場合は、ボードの電源を入れる前に、TFカードが挿入されていることを確認してください。そして、ファイルを書いた後は、同期の問題に注意してください。 TF カードの取り付け状況をチェック #include \"os/MountMonitor.h\" if (MOUNTMONITOR->isMount()) { //TF card has been mounted } else { //TF card is not mounted } [!Note] /mnt/extsdディレクトリは、TFカードを挿入するかどうかに関係なく、常に存在します。 TFカードが挿入されていない場合は、ディレクトリを読み、書くと内容がメモリに保存され、電源がオフになった後は、消えます。 powered by Gitbooklast modified: 2020-12-08 11:16:51 "},"mount.html":{"url":"mount.html","title":"カード監視","keywords":"","body":"TF card plug-in monitor TFカードの監視機能を登録することでTFカードの状態を知ることができます。以下は実装のための最初の必要です。 #include \"os/MountMonitor.h\" class MyMountListener : public MountMonitor::IMountListener { public: virtual void notify(int what, int status, const char *msg) { switch (status) { case MountMonitor::E_MOUNT_STATUS_MOUNTED: // insert // msg is the mount path LOGD(\"mount path: %s\\n\", msg); mMountTextviewPtr->setText(\"TF inserted\"); break; case MountMonitor::E_MOUNT_STATUS_REMOVE: // remove // msg is the unmount path LOGD(\"remove path: %s\\n\", msg); mMountTextviewPtr->setText(\"TF removed\"); break; } } }; Listener 定義 : static MyMountListener sMyMountListener; 登録 : MOUNTMONITOR->addMountListener(&sMyMountListener); 登録解除 : MOUNTMONITOR->removeMountListener(&sMyMountListener); 詳細は、サンプルコードのMountDemoプロジェクトを参照してください。 powered by Gitbooklast modified: 2020-12-04 09:50:01 "},"reboot.html":{"url":"reboot.html","title":"システムの再スタート","keywords":"","body":"システムの再起動 次のコードを使用してシステムを再起動することができます。 必要なヘッダファイル #include #include 코드 //Synchronize data and save cached data to prevent data loss sync(); reboot(RB_AUTOBOOT); powered by Gitbooklast modified: 2020-12-07 12:28:41 "},"i18n.html":{"url":"i18n.html","title":"複数の言語","keywords":"","body":"複数の言語 FlywizOSは、複数の言語をサポートします。 使い方 まずnew wizardを使用して、複数の言語のためのファイルを作成します。 ファイルの作成後、プロジェクトフォルダにi18nフォルダが作成され、基本的なtrファイルが生成されます。各trのファイル名は、対応する言語を示します。（ファイル名は任意に変えないことをお勧めします。） trファイルをダブルクリックしてオープンするとxml形式のコンテンツを見ることができます。ここでstring tagのnameはaliasで使用され、コードの上で文字列を表します。 Note : Alias cannot be duplicated in the same tr file. Hello world! Hello, FlywizOS もし文字列に改行をしたい場合は&#x000A;を追加します。以下は例です。 first line&#x000A;second line 上記の文字 \"hello、world!\" のaliasをhello_worldそして文字 \"hello、FlywizOS\"のaliasをhello_flywizosに決めました。より多くの文字列とaliasを追加したい場合は、例のstring tagを参照してください。 複数の言語のために、各言語に同じname tagを追加します。このように、設定言語を変えたとき、システムは自動的にその言語に対応した同じname tagの文字に置き換えます。 言語ファイルが追加された後、開発者は、UIファイルとコードでそれを使用することができます。 UIファイルを開いて、コントロールのプロパティのTextに @hellow_worldを入力した後、基板にダウンロードして実行すると、そのコントロールにHello、world！が表示されていることを確認することができます。（@シンボルは@の後のテキストが言語ファイルのaliasであることを示しています） また、コード上でも同じようにaliasを使用することができます。setTextTr()関数がその方法です。 例 : /** * Triggered when the activity is constructed */ static void onUI_init() { // The parameter of setTextTr() is the name value in the language file. Note: The string passed in here does not need to be // preceded by the @ symbol mTextview1Ptr->setTextTr(\"hello_world\"); } プログラムをボードにダウンロードして実行すると、そのコントロールにaliasに対応する文字が表示されることを確認することができます。 また、言語ファイルのaliasを利用してコンテンツを取得することもできます。例： #include \"manager/LanguageManager.h\" static bool onButtonClick_Button1(ZKButton *pButton) { //LOGD(\" ButtonClick Button1 !!!\\n\"); std::string hello = LANGUAGEMANAGER->getValue(\"hello\"); std::string world = LANGUAGEMANAGER->getValue(\"world\"); std::string ret = hello + \" \" + world; LOGD(\"ret: %s\\n\", ret.c_str()); return false; } 言語を変更する システムのデフォルト言語はzh_CN(Simplified Chinese)です。 システムに内蔵された言語設定アクティビティを使用して言語を変更できます。次のコードは、言語設定アクティビティを実行する例を示します。 EASYUICONTEXT->openActivity(\"LanguageSettingActivity\"); または提供されるAPI関数を使用し言語を自由に変更することができます。 EASYUICONTEXT->updateLocalesCode(\"zh_CN\"); //Set to Chinese EASYUICONTEXT->updateLocalesCode(\"en_US\"); //Set to English EASYUICONTEXT->updateLocalesCode(\"ko_KR\"); //Set to Korean フォントの要件 複数の言語は、フォントのサポートが必要です。もしその文字がフォントにない場合は非正常に表示されます。したがって、使用されるフォントも、複数の言語が含まれている必要があります。 システムの基本的なフォントは簡体字中国語のです。複数の言語のためにカスタムフォントを追加することをお勧めします。Font cuttingを参照してください。 例 完全なソースは、サンプルコードのTranslationDemoを参照してください。 powered by Gitbooklast modified: 2020-12-03 14:42:56 "},"adb_debug.html":{"url":"adb_debug.html","title":"ADBデバッグ","keywords":"","body":"ADBダウンロードとデバッグ FlywizOSはUSBまたはWIFIを介してプログラムを迅速にダウンロードすることができ、具体的な手順は次のとおりです。 まず、コンピュータとボードを接続するために、ここには二つの方法があります。 [!Note] Note：もしWIFI付きボードを購入した場合は、WIFIを介してのみ接続が可能です。(USB接続不可) WIFIがないバージョンを購入したら、USBを利用して、コンピュータを接続すると、以下のように接続状態を確認できますだ。 コンピュータとボードをUSBケーブルを使用して接続 - USBケーブルを使用して、コンピュータとデバイスを接続します。コンピュータがデバイスをAndroidデバイスとして認識することができれば、接続は正常です。 正常に接続できない場合は、コンピュータにドライバの問題が表示されます。ドライバのダウンロードとインストールをお試しください。 WIFI経由で接続(この方法は、ボードがWIFIをサポートする必要があります。) まず、ボードのWIFI設定を使用してボードをコンピュータと同じネットワークに接続します。ネットワーク設定後のボードのIPアドレスを確認し、そのIPアドレスをFlywizOS IDEの設定と、IDEは、ボードとの接続を試みて成功時に成功確認のポップアップが表示されます。（もし失敗した場合のボードのIPアドレスが正しいことを確認してください。） WIFI設定アクティビティ IDEのIPアドレスの設定 ダウンロードとデバッグ 上の過程が完了すると、ユーザーは、ボードにプログラムを直接ダウンロードすることができます。プロジェクトエクスプローラで、ダウンロードするプロジェクトの名前を選択し、右クリックして、ポップアップメニューからDownload and Debugを見つけてクリックすると、自動的にプログラムがコンパイルされ、コンパイルが成功すると、ボードにプログラムがダウンロードされます。以後、通常のダウンロードに成功すると、ボードからダウンロードしたプログラムが実行されることを見ることができます。 同様に、プロジェクトを選択し、Ctrl + Alt+ Rキーを押すとダウンロードが可能です。 ログを利用したデバッグ 注意事項 もしコンピュータに他のAndroidデバイスが接続されている場合は、その機器の接続を解除する必要があります。だ。そうでない場合は、ダウンロードの失敗の原因になることがあります。 Note：この方法でプログラムを実行する場合、プログラムは、ボードに保存されていないので、電源をオフにする場合は、次の電源接続時に既存のボードに内蔵されているプログラムで実行されます。（もしプログラムをボードに保存したい場合は、\"更新イメージの作成」参照してください） powered by Gitbooklast modified: 2020-12-02 10:05:02 "},"logcat.html":{"url":"logcat.html","title":"View log","keywords":"","body":"View log Log 追加 必要なヘッダファイル #include \"utils/Log.h\" FlywizOSはLOGDまたはLOGEマクロを使用して、ログを出力します。使用方法は、C言語のprintfと同じです。以下は自動的に生成されたコードの例です。 static bool onButtonClick_Button1(ZKButton *pButton) { LOGD(\"onButtonClick_Button1\\n\"); return true; } ログの確認 ADB）接続後、ツールを介してプログラムのログを確認することができます。方法は以下の通りです。 メニューからFlywizOS - >Show Log Perspectiveを選択すると、IDEは、別の画面に切り替えます。 新しい画面の左下でLogCatを選択します。もし正常であれば、右の赤い色ボックス領域から出力されるログを確認することができます。 もしコーディング画面に切り替えるしたい場合は、IDEの右上のFlywizOSアイコンをクリックしてください。 powered by Gitbooklast modified: 2020-12-03 17:14:57 "},"start_from_sdcard.html":{"url":"start_from_sdcard.html","title":"TF cardでプログラムを起動する","keywords":"","body":"TFカードからプログラムを起動する ADBを使用してプログラムをダウンロードすることができない場合は、プログラムをTFカードに保存して、TFカードでプログラムを起動することもできます。 [!Note] Note : FAT32でフォーマットTFカードのみをサポートします。 製作過程 まず、プログラムの出力ディレクトリを設定する必要があります。 IDEで下のボタン検索します。 黒のドロップダウン矢印をクリックし、ポップアップメニューから Path Setupを選択します。 ポップアップボックスでTFカードのドライブを選択して（TFカードを正常に使用できることを確認してください）、OKをクリックしてください。 上記の手順で出力ディレクトリを設定しました。今下の図のボタンをクリックしてコンパイルを開始すると、コンパイルされた結果を設定したドライブとしてパッケージ化して保存します。 操作が成功するとEasyUI.cfg、ui、libとfontと同じディレクトリとファイルが構成されたドライブに作成されます。 TFカードを取り外し機器に挿入した後、機器の電源を入れ直してください。このとき、システムはTFカードのファイルを検出すると、システムのプログラムではなく、カードからプログラムを起動します。 powered by Gitbooklast modified: 2020-12-07 17:26:06 "},"update_logo.html":{"url":"update_logo.html","title":"Boot LOGOアップグレード","keywords":"","body":"起動ロゴのアップグレード まず、以下の条件を満たしている起動ロゴイメージを準備します。 [!Note] イメージ名はboot_logo.JPGに固定されます。ファイルの拡張子は、jpgと、他の拡張子は認識されません。画像サイズは、128 KBを超えることはできません。画像の解像度は、画面の解像度と正確になります。 boot_logo.jpgをTFカードのルートディレクトリにコピーします。 TFカードをボードに挿入すると、自動的にアップグレードアクティビティを表示します。boot_logoを選択して、アップグレードをクリックしてください。 アップグレードが完了すると、システムがシャットダウンして再起動されます。この時、システムが再アップグレードされないように防止するためにすぐにTFカードを取り出します。 備考：全体が黒いインデックス画像にアップグレードして、起動ロゴを削除することができます。 powered by Gitbooklast modified: 2020-12-08 15:38:21 "},"make_image.html":{"url":"make_image.html","title":"Upgrade imageファイルの作成","keywords":"","body":"Upgrade imageファイルの作成 先進の章では、我々は、ダウンロードおよびデバッグメニューを使用してプログラムを実行しました。しかし、それはプログラムをボードに保存することがないので、TFカードを削除したり、ボードの電源をオフにした再起動時にダウンロード前のプログラムで実行されます。 したがって、もしボードにプログラムを保存したい場合は、まずプログラムを更新イメージファイルとして作成ボードを更新します。その後、更新後の再起動時に更新されたプログラムが実行されます。 使い方 まず、更新イメージファイルが作成されるパスを設定します。 ツールバーの下の画像を検索します。 ドロップダウン矢印ボタンをクリックして、ポップアップメニューのPath Setupを選択します。 ポップアップボックスで、更新イメージファイルを保存するパスを選択し、OKをクリックします。 上記の過程で、私たちは、更新イメージファイルのパスを設定しました。今下の図のボタンを押します。その後、IDEは、コンパイルを実行し、その結果をパッケージ化してupdate.imgファイルを設定されたパスに作成します。 update.img\"ファイルが正常に作成された後、TFカード（注意：FAT32形式のTFカードのみをサポート）のrootディレクトリにコピーして、ボードに挿入します。 その後、システムは、TFカードのファイルを検出し、下の図のようにアップデートプログラムを実行します。 その後のチェックボックスをタッチしてチェックした後に更新ボタンを押すと、アップデートが開始されます。アップデートが完了した後は、すぐにカードを削除して再更新されることを防止します。 もしボードのタッチが壊れているか、タッチがないボードの場合、ボタンをクリックすることができないアップデートができません。この場合は、自動更新を参照して更新します。 powered by Gitbooklast modified: 2020-12-04 09:48:18 "},"autoupgrade.html":{"url":"autoupgrade.html","title":"自動TF cardアップグレード","keywords":"","body":"自動TF cardアップデート ボードの画面またはタッチに問題がある場合のTFカードに以下のファイルを追加することでシステムを自動的に更新することができます。 zkautoupgrade (Note: 拡張子はなし) この方法を使用すれば、TF cardを挿入した後、特定の待機時間（基本2秒）後にボードを自動的に更新することができます。もしアップデート前の待機時間を調整したい場合は、 zkautoupgradeファイルに必要な時間（単位：秒）を追加します。アップデートが完了すると、TF cardを削除して、自動的に再更新されることを防止します。 powered by Gitbooklast modified: 2020-12-02 10:12:33 "},"sd_boot.html":{"url":"sd_boot.html","title":"フラッシュカードを作成する","keywords":"","body":"​ フラッシュカードを作成する [!Warning] 注：TFカードの最大容量は、16Gをサポートします。16G以上のTFカードは認識することができず、アップグレードができません。 最新のソフトウェア更新プログラムパッケージは、QQ371608200からダウンロードしてください。 ダウンロード時のボードに対応したソフトウェアのバージョン（ボードの背面Tagを確認）を確認してください。もし、他のバージョンが使用されると、アップグレード後正常動作しない場合があります！ Computer Flash Tool ダウンロードします。 コンピュータでTFカードドライブを選択します。 アップグレードイメージファイルを選択します。 製作のためにクリック プログラミングが成功した場合のTFカードを取り出し、ボードに挿入し、再度電源を入れてアップグレードしてください。 TFカードの回復 コンピュータでTFカードドライブを選択します。 カードの回復をクリックします。 フォーマット後のカードは、通常の使用が可能です。 powered by Gitbooklast modified: 2020-12-07 15:32:31 "},"remote_update.html":{"url":"remote_update.html","title":"リモートアップグレード","keywords":"","body":"リモートアップグレード 現在のシステムでは、直接リモートアップグレードのためのアクティビティがありません。 しかし、私たちは、TFカードの検出とアップグレードのメカニズムを理解し、リモートアップグレードの目的を達成するために、独自のコードを追加することができます。 まず、TFカードを挿入する一般的なアップグレードプロセスを紹介します。 TFカード検出アップグレードプロセス システムを起動するか、TFカードを挿入するときに、TFカードが正常に装着されている場合システムは、TFカードのルートディレクトリにupdate.imgファイルがあることを確認します。（TFカードのルートディレクトリは、/mnt/extsdにマッピングされます。） ファイルがある場合は、ファイルが要件を満たしていることを追加で確認します。検証に合格すると、アップグレードアクティビティが表示され、ユーザーがアップグレードを選択することができます。存在しない場合、プロセスが終了し、アクティビティにどのような行動も起こりません。 実装段階 まず、アップグレードイメージupdate.imgをダウンロードする必要があります。 通常の状況下では、HTTPプロトコルを介してファイルをダウンロードすることが最も簡単な方法であり、実際の状況に応じて、他のプロトコルを選択することもできます。 ダウンロードした後の画像ファイルをTFカードのディレクトリ/ mnt/extsd/に保存します。 [!Note] ボードにTFカードが挿入されていない場合でも、このディレクトリは、メモリに保存されるので書くことができます。メモリサイズによって制限され、画像ファイルが大きすぎる場合、異常な動作やアップグレードが失敗の原因になります。TFカードを挿入した場合、メモリサイズの問題を無視することができます。 アップグレード検出関数の呼び出し First, download the [UpgradeMonitor.h] (https://developer.flywizos.com/src/UpgradeMonitor.h) source file and save it in your project's jni/include/os directory. 次に関数を呼び出して、アップグレードを検出してください。 #include \"os/UpgradeMonitor.h\" //Actively detect whether there is a correct update.img file in the /mnt/extsd directory, //If yes, an upgrade prompt box will pop up //If not, nothing happens UpgradeMonitor::getInstance()->checkUpgradeFile(\"/mnt/extsd\"); アップグレードアクティビティが表示され、ユーザーがアップグレードするかどうかを選択することができます。 これまでのリモートアップグレード機能が完全に実現された。 ファイルのダウンロード後、自動更新 アップグレードファイルをダウンロードした後、強制的に更新するには、[自動更新]（autoupgrade.md）文書を参照して、コードでzkautoupgradeファイルを作成するだけです。 反復的なアップグレードを防止 上記の手順で画像ファイルを/mnt/extsd/ディレクトリに保存します。正常にアップグレードすると、ボードは自動的に再起動されます。 この時、システムは、定期的なアップグレードを検出プロセスを実行し、画像ファイルが存在するため、アップグレードアクティビティが再びポップアップされ、アップグレードが繰り返されます。 解決 イメージファイルをダウンロードするときに/mnt/extsd/ではなく、別のディレクトリに保存します。例：/mnt/extsd/temp/、また、検出関数の呼び出し時のパラメータも変更します。 UpgradeMonitor::getInstance()->checkUpgradeFile(\"/mnt/extsd/temp\"); Sample Complete sample downloadサンプルは、単にhttpクライアントを実装して、ファイルをダウンロードします。ソースコードのhttpの部分を参照してください。ファイルのダウンロードは、時間のかかる作業なので、インターフェースの即時応答に影響を与えないように、ファイルを別のスレッドに配置してください。 キーコード class DownloadThread : public Thread { protected: virtual bool threadLoop(){ http::HttpClient http; mTextview1Ptr->setText(\"Download the upgrade file\"); //Create a save path for the upgrade file system(\"mkdir /mnt/extsd/temp\"); //Modify here to the real service IP string err = http.Download(\"192.168.1.1/update.img\", 80, \"/mnt/extsd/temp/update.img\"); mTextview1Ptr->setText(err); if (err.empty()) { UpgradeMonitor::getInstance()->checkUpgradeFile(\"/mnt/extsd/temp\"); } mButton1Ptr->setInvalid(false); return false; }; }; サーバーの実装テストの便宜のために例には、実行ファイルであるhttp.exeが含まれています。 作成されたアップグレードイメージファイルupdate.imgとhttp.exeを同じフォルダに入れ、http.exeをダブルクリックして実行します。ネットワークが正常であれば、Webサイトのミラーファイルを使用して同じディレクトリにファイルをダウンロードすることができます。 例 :http://192.168.1.1/update.img(IPアドレスをコンピュータの現在のIPに変更します。) サーバーが開始された後、サンプルコードを実行して、リモートアップグレードをテストします。 powered by Gitbooklast modified: 2020-12-07 15:12:26 "},"demo_download.html":{"url":"demo_download.html","title":"Sample code","keywords":"","body":"サンプル ダウンロード [!Note] 最初に画面に対応するプラットフォームのサンプルコードをダウンロードしてください。そうでない場合は、コピーをダウンロードしてから、コンパイルプラットフォームの変換を参照して自分で変換してください FW9306またはFW9306sプラットフォーム 480x272サンプルコード その他のサンプルコード(Modbus、Sqlite、CURL HTTP、Mqtt) FW9311プラットフォーム 800x480サンプルコード 1024x600サンプルコード その他のサンプルコード(Modbus、Sqlite、CURL HTTP、Mqtt) powered by Gitbooklast modified: 2021-01-15 17:32:06 "},"file_read_write.html":{"url":"file_read_write.html","title":"ファイルの読み取り/書き込み","keywords":"","body":"File read/write もし、C言語のFile read/ writeに慣れている場合は、C言語のスタンダードでFile read/ writeが可能です。 簡単File read/ writeのために我々は、C言語でも提供されている簡単なFile read/ writeパッケージを提供しています。もし必要であれば、以下のプロセスをプロジェクトに追加します。 /** * Write a file. If the file exists, it will be overwritten. If the file does not exist, create a new file and write the content * Successfully returned true */ bool WriteFile(const char* filename, const void* data, int len); /** * Append content at the end of the file, if the file does not exist, create a new file first, and then write the content * Successfully returned true */ bool AppendFile(const char* filename, const void* data, int len); /** * Read file * Success - save the file in the data of string in binary form, read the binary content with string.data() * Failure - Return empty string */ string ReadFile(const char* filename); Porting steps プロジェクトのjniフォルダにioフォルダを作成 ioutil.h, ioutil.cppをダウンロードしてioフォルダに保存 使い方 Include header file#include \"io/ioutil.h\" Write file //Write the string \"0123456789\" into the file 123.txt const char* filename = \"/mnt/extsd/123.txt\"; //Path to save the file const char* str = \"0123456789\"; ioutil::WriteFile(filename, str, strlen(str)); Append file //Append the content to the end of the file, if the specified file does not exist, create a new file. const char* append_str = \"abcdefgh\"; ioutil::AppendFile(filename, append_str, strlen(append_str)); Read file const char* filename = \"/mnt/extsd/123.txt\"; //Read all the contents of the file and save it in content string content = ioutil::ReadFile(filename); //Output each byte read to the log in hexadecimal for (size_t i = 0 ; i [!Warning] `ioutil::ReadFile関数は、ファイルのすべての内容をメモリに読み込みます。もし、ファイルが大きすぎると、メモリ不足の例外が発生します。 Write file continuously, suitable for large file const char* filename = \"/mnt/extsd/123.txt\"; const char* append_str = \"abcdefgh\"; ioutil::Writer w; if (w.Open(filename, false)) { for (int i = 0; i Read file continuously, suitable for large file const char* filename = \"/mnt/extsd/123.txt\"; ioutil::Reader r; if (r.Open(filename)) { char buf[1024] = {0}; while (true) { int n = r.Read(buf, sizeof(buf)); if (n > 0) { //Have read content, output every byte for (int i = 0; i Test code /** * Triggered when the interface is constructed */ static void onUI_init() { //Write file const char* filename = \"/mnt/extsd/123.txt\"; const char* str = \"0123456789\"; ioutil::WriteFile(filename, str, strlen(str)); string content = ioutil::ReadFile(filename); LOGD(\"Number of bytes read %d, content:%s\", content.size(), content.c_str()); //Append file const char* append_str = \"abcdefgh\"; ioutil::AppendFile(filename, append_str, strlen(append_str)); content = ioutil::ReadFile(filename); LOGD(\"Number of bytes read %d, content:%s\", content.size(), content.c_str()); ioutil::Writer w; if (w.Open(filename, false)) { for (int i = 0; i 0) { //Have read content, output every byte for (int i = 0; i powered by Gitbooklast modified: 2020-12-03 10:09:10 "},"net.html":{"url":"net.html","title":"ソケットプログラミング","keywords":"","body":"Socket programming もしLinux socket programmingに精通している開発者であれば、standard Linux socket programming interfaceに応じて、ネットワークプログラミングをすることができます。 例を持ち上げるためにFlythings OSはTCPクライアントを構築するために一般的に使用されるソケットプログラミングの実装に便利なLinuxの標準インターフェースに基づいて、単純なパッケージを作成しました。必要に応じて手順に従ってソースコードをプロジェクトに統合することができます。 Porting steps プロジェクトのjniフォルダの下に新しいフォルダを作成し、名前をnetにします。 net.h, net.cpp 両方のファイルをダウンロードしてnetフォルダに保存します。 使い方 TCP Client 必要なヘッダファイル#include \"net/net.h\" 例//Use TCP protocol to connect to port 80 of the domain name www.baidu.com, and change the domain name to IP. net::Conn* conn = net::Dial(\"tcp\", \"www.baidu.com:80\"); //net::Conn* conn = net::Dial(\"tcp\", \"14.215.177.38:80\"); if (conn) { byte buf[2048] = {0}; const char* req = \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"; //send conn->Write((byte*)req, strlen(req)); while (true) { //read，1000ms timeout int n = conn->Read(buf, sizeof(buf) - 1, 1000); if (n > 0) { buf[n] = 0; LOGD(\"read %d bytes： %s\", n, buf); } else if (n == 0) { LOGD(\"Normal disconnection\"); break; } else if (n == net::E_TIMEOUT) { LOGD(\"read timeout\"); } else { LOGD(\"error\"); break; } } //Close the connection conn->Close(); //Release memory delete conn; conn = NULL; UDP Client 必要なヘッダファイル#include \"net/net.h\" 例//Use udp protocol to connect IP: 192.168.1.100 port 8080 net::Conn* conn = net::Dial(\"udp\", \"192.168.1.100:8080\"); if (conn) { byte buf[2048] = {0}; const char* req = \"hello\"; conn->Write((byte*)req, strlen(req)); while (true) { //read，1000ms timeout int n = conn->Read(buf, sizeof(buf) - 1, 1000); if (n > 0) { buf[n] = 0; LOGD(\"read %d bytes： %s\", n, buf); } else if (n == 0) { LOGD(\"Normal disconnection\"); break; } else if (n == net::E_TIMEOUT) { LOGD(\"read timeout\"); //Set timeout here to exit break; } else { LOGD(\"error\"); break; } } //Close the connection conn->Close(); //Release memory delete conn; conn = NULL; } powered by Gitbooklast modified: 2020-12-04 15:23:19 "},"http.html":{"url":"http.html","title":"HTTP","keywords":"","body":"HTTP もしHTTP Get、Post requestの実装が必要な場合は、C言語のオープンソースのライブラリであるlibcurlは非常に良い選択です。使いやすさのために、FlywizOSはコンパイルされたライブラリを提供しています。サンプルコードでThird-party porting codeのCURLDemoプロジェクトを参照してください。 [!Note] プラットフォームに合ったサンプルコードをダウンロードしてください。そうでない時正常に動作しません。 powered by Gitbooklast modified: 2020-12-03 14:24:28 "},"transcoding.html":{"url":"transcoding.html","title":"トランスコーディング","keywords":"","body":"UTF-8 encoding 現在のシステムは、UTF-8エンコーディングのみをサポートします。たとえばText Viewのようなコントロールは、一般的に、UTF-8でエンコードされた文字列のみを表示することができます。したがって、他のコードを正常に表示するには、直接トランスコードする必要があります。 sconv Sconvはトランスコーディングのためのオープンソースのライブラリでutf-8とgbk間の変換に使用されます。 준비 sconvソースファイルのダウンロード、プロジェクトjniフォルダに解凍します。 UTF-8 to GBK 必要なヘッダファイル #include #include \"utf8cover/sconv.h\" 함수 추가 string utf8_to_gbk(const char* utf8_str) { int size = sconv_utf8_to_unicode(utf8_str, -1, NULL, 0); wchar *unicode = new wchar[size / 2 + 1]; size = sconv_utf8_to_unicode(utf8_str, -1, unicode, size); unicode[size / 2] = 0; size = sconv_unicode_to_gbk(unicode, -1, NULL, 0); char *ansi_str = new char[size + 1]; size = sconv_unicode_to_gbk(unicode, -1, ansi_str, size); ansi_str[size] = 0; string gbk(ansi_str, size); delete[] ansi_str; delete[] unicode; return gbk; } 関数を使用してエンコード変換を実行します。例は次のとおりです。 const char* utf8_str = \"This is utf8 encoding\"; string gbk = utf8_to_gbk(utf8_str); LOGD(\"After conversion, a total of %d bytes\", gbk.size()); for (size_t i = 0; i GBK to UTF-8 必要なヘッダファイル #include #include \"utf8cover/sconv.h\" 関数の追加 string gbk_to_utf8(const char* gbk_str) { int size = sconv_gbk_to_unicode(gbk_str, -1, NULL, 0); wchar *unicode_str = new wchar[size / 2 + 1]; size = sconv_gbk_to_unicode(gbk_str, -1, unicode_str, size); unicode_str[size / 2] = 0; size = sconv_unicode_to_utf8(unicode_str, -1, NULL, 0); char *utf8_str = new char[size + 1]; size = sconv_unicode_to_utf8(unicode_str, -1, utf8_str, size); utf8_str[size] = 0; string utf8(utf8_str, size); delete[] unicode_str; delete[] utf8_str; return utf8; } 関数を使用してエンコード変換を実行します。例は次のとおりです。 //To testing, here is a gbk encoding array whose content is \"This is gbk encoding\" const char gbk_str[] = {0xd5, 0xe2, 0xca, 0xc7, 0x67, 0x62, 0x6b, 0xb1, 0xe0, 0xc2, 0xeb,0}; string utf8 = gbk_to_utf8(gbk_str); LOGD(\"After conversion, a total of %d bytes\", utf8.size()); LOGD(\"Content is：%s\", utf8.c_str()); powered by Gitbooklast modified: 2020-12-08 15:33:51 "},"json.html":{"url":"json.html","title":"JSON","keywords":"","body":"JSON 構成と解析 基本的には、プロジェクトには、open sourcecppjson libraryが含まれており、すぐに使用が可能です。 使用方法 必要なヘッダファイル #include \"json/json.h\" JSON string 構成 Json::Value root; //Add integer value root[\"int\"] = 1; //Add string root[\"str\"] = \"hello\"; //Due to the accuracy printing problem of floating-point numbers, it is not recommended to use, try to convert to integer root[\"float\"] = 3.14f; //add array Json::Value array; array.append(\"123\"); array.append(\"456\"); array.append(\"789\"); root[\"array\"] = array; //json nesting Json::Value sub; sub[\"int\"] = 1; sub[\"str\"] = \"sub str value\"; root[\"subJson\"] = sub; LOGD(\"The generated json string is : \"); LOGD(\"%s\", root.toStyledString().c_str()); ParsingJSON //Parsing json Json::Reader reader; Json::Value root2; //For convenience, Use the constructed json string as input for parsing json std::string test_json_string = root.toStyledString(); if (reader.parse(test_json_string, root2, false)) { LOGD(\"Parsed successfully\"); //When parsing json, you must check the legitimacy of the input more to avoid the program crash caused by illegal input. if (root2.isMember(\"int\")) { LOGD(\"int = %d\", root2[\"int\"].asInt()); } if (root2.isMember(\"str\")) { LOGD(\"str = %s\", root2[\"str\"].asString().c_str()); } if (root2.isMember(\"array\")) { Json::Value obj = root2[\"array\"]; if (obj.isArray()) { for (Json::ArrayIndex i = 0; i powered by Gitbooklast modified: 2020-12-03 15:31:56 "},"cpp_base.html":{"url":"cpp_base.html","title":"C++基本","keywords":"","body":"C++基本的な知識 この章では、C++の基本的な知識がない人にC ++の基本的な構文とクラスについて説明します。 Class C ++の場合は、まずclassを言及する必要があります。あまりにも複雑であると考えていないC言語のstructureに理解するようにします。 例えば、: // C struct Position { int left; int top; int width; int height; }; // c++ class Position { public: int left; int top; int width; int height; }; 変数の定義 : // C struct Position pos; // c++ Position pos; 変数操作 : // C is the same as c++ pos.left = 0; classは、C言語の構造よりも相続、ポリモーフィズム、オーバーロードおよびアクセス権の概念があります。Cに慣れている人は、これをどのように使用するかは十分に知るためには、そうでない場合は、多くの努力を払う必要がありません。 さらに、C言語では、関数ポインタのみ定義が、C++のclassは、関数を直接実装が可能です。この部分がCとは異なる点で、classに定義された関数は、一種の変数のように使用されます。以下は、頻繁に使用されている例です。 // Set the text content, where mTextView1Ptr is a pointer variable of type ZKTextView mTextView1Ptr->setText(\"Hello\"); 基本 class string class string classは、実際のstringとこれのために提供されている多くの関数がカプセル化されています。しかし、Cに慣れているユーザーは、c_str()関数だけ分かっても、十分に活用できます。この関数は、string classからcharactersだけを返す関数として以下のように使用することができます。 // Input box callback function static void onEditTextChanged_Edittext1(const std::string &text) { // The return value type of c_str() function : const char * const char *pStr = text.c_str(); // Then you can operate like ordinary strings, such as getting the string length strlen(pStr), etc. } 以下は、テキストコントロールのテキストを取得例です。 // std is the namespace, std::string means to use the string class under std, don’t worry too much // When encountering the string class, we can refer to the following definition std::string text = mTextView1Ptr->getText(); // The subsequent operations are the same const char *pStr = text.c_str(); snprintf 関数のプロトタイプ : int snprintf(char* dest_str,size_t size,const char* format,...); 機能 : 複数のパラメータを定められたフォーマットに合わせてstring化してdest_strに保存 (1) もしformatted stringのlengthがsizeよりも小さい場合stringがコピーされ、stringの終わりに'\\0'が追加されます。 (2) もしformatted stringのlengthがsize以上の場合のみsize-1のstringだけコピーされ、最後に'\\ 0'が追加されます。 必要ヘッダファイル : #include フォーマット形式 Specifier%d Decimal signed integer%u Decimal unsigned integer%f Floating point%s String%c Character%p Pointer value%e Exponential floating point%x, %X Unsigned integer in hexadecimal%o Unsigned integer in octal%g Output the value according to the smaller output length in %e or %f type%p Output address%lu Output long integer %llu 64-bit unsigned integer Description (1) 最大フィールド幅を示すために\"％\"と文字の間に数字を挿入することができます。 例：％3dは3つの整数の出力を意味します。3桁のができないなら、右に配置されます。 ％9.2fはフィールドの幅が9である浮動小数点数を表します。ここで、小数点以下の桁は2であり、整数桁は6です。小数点が一桁で、9桁のができないなら、右に配置されます。 ％8sは8文字の文字列を出力することを意味し、8文字できないなら右揃えされます。 文字列の長さや整数の数が指定されたフィールドの幅を超えた場合、実際の長さに応じて出力されます。 しかし、浮動小数点数の場合は、整数の数が指定された整数の幅を超えると、実際の整数で出力されます。 小数点以下の桁数が指定された小数点以下の桁数を超えると、指定された幅に応じて出力が丸められます。 また、出力値の前に0を追加するには、フィールドの幅用語の前に0を追加する必要があります。 例：％04dは、4桁の未満の値を出力するときにゼロが追加され、合計の幅が4桁がされることを意味します。 浮動小数点数を使用して文字または整数の出力形式を表す場合は、小数点の後の数字は最大幅を示し、小数点の前の数字は、最小幅を表します。 例：％6.9sは、長さが6以上9以下の文字列を表示することを意味します。9を超える場合は、9番目の文字以降の内容は削除されます。 (2) \"％\"と文字の間に小文字lを追加して、出力が長い数字であることを示すことができます。 例：％ldはlong出力を意味します。 ％lfは出力double-float数を意味します。 (3) 出力を左揃えまたは右揃えに制御することができます。つまり、「％」と文字の間に「 - 」の記号を追加して、出力が左揃えされることを示し、それ以外の場合右揃えされます。 例：％-7dは出力7つの整数が左寄せされることを意味します。 ％-10sは左揃えされた10文字の出力を意味します。 Special specifier\\n 改行\\f 画面を消去し、ページ変更 \\r キャリッジリターン\\t Tab 例 整数出力 char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%d\", 314); LOGD(\"%s\", buf);//Log output buf 出力されたlog : 314 整数の桁数を指定出力 char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%05d\", 314); //Format as 5 digits, less than 5 digits, add 0 in front LOGD(\"%s\", buf);//Log output buf string 出力されたlog : 00314 浮動小数点出力 char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%f\", 3.14); LOGD(\"%s\", buf);//Log output buf string 出力されたlog : 3.140000 浮動小数点以下の桁を指定出力 char buf[64] = {0}; //Output decimals, a total of 6 characters wide (including the decimal point), 3 decimal places, two integer digits, and 0 if //the integer is less than two digits snprintf(buf, sizeof(buf), \"%06.3f\", 3.14); LOGD(\"%s\", buf);//Log output buf string 出力されたlog : 03.140 powered by Gitbooklast modified: 2020-12-02 16:12:22 "},"touchcalibration.html":{"url":"touchcalibration.html","title":"タッチ補正","keywords":"","body":"タッチ補正 圧力式タッチスクリーンは、最初点灯した場合、タッチ補正が行われます。タッチ補正アクティビティは、次のとおりです。 タッチを補正するには、「十字アイコン」をクリックします。今後再び補正したい場合には、次の3つの方法があります。 IDEを使用して、プロジェクトのプロパティを開いて、Touch calibration after bootingオプションをチェックして、電源を入れるたびに、タッチ補正アクティビティが実行されるようにします。 TFカードのルートディレクトリにzktouchcalibファイルを作成します（注：ファイルには、拡張子がない）。カードを挿入すると、タッチ補正アクティビティに入ります。 次のコードで、タッチ補正アクティビティを開始します。 EASYUICONTEXT->openActivity(\"TouchCalibrationActivity\"); powered by Gitbooklast modified: 2020-12-08 15:14:34 "},"font_setting.html":{"url":"font_setting.html","title":"Font設定","keywords":"","body":"Font setting FlywizOS IDEの基本的なフォントは、Consolasです。 フォントのオプションがDefaultに設定されていれば、コンパイル、および更新ファイルの作成時に内蔵された基本的なフォントであるfzcircle.ttfが含まれます。 もし他のフォントを使用したい場合は、Defaultチェックオプションをオフにして、新しいフォントを設定します。（Note：ttf形式のフォントのみをサポート可能）: powered by Gitbooklast modified: 2021-01-04 09:05:32 "},"font_cut_tool.html":{"url":"font_cut_tool.html","title":"Fontトリミング","keywords":"","body":"Font cutting ほとんどのプロジェクトでは、カスタムフォントを使用します。しかし、いくつかのフォントは、非常に大きなサイズでプロジェクトに適していないことがあります。 また、フォントの特定の文字のみを使用する場合に必要なフォントだけを切り取って使用すると、フォントが占めるシェアを減らして全体的なパフォーマンスの向上にも非常に役立つことができます。 Font cutting toolの使用 上部メニューのToosでFont cutting toolを見つけることができます。 まず、「Set the font cutting method\"を設定します。ここでいくつかの文字を使用するかを決定します。 Regular expression java正規表現をサポートします。例：\\ dは、すべての数値を意味します。 Specify text特定、UTF-8でエンコードされた** txtファイル内のコンテンツだけでフォントを再構成します。（推奨する方法で、シンプルで直感的です。） Set the font使用するフォントを設定します。 Set the output path再構成されたフォントが保存されるパスを設定します。もし既存のために作らフォントファイルがある場合は、新しいファイルに置き換えられます。 すべての設定が終わった後Cutをクリックします。 もし完了メッセージが表示される場合に成功したものであり、新たなフォントが設定されたout pathに作成されます。 例 新しいtxtファイルを作成し、 \"Hellow」という単語のみを追加した後 UTF-8形式で保存してください。その後 Font cutting toolにパラメータを設定し、 Cutボタンを押すと、10KB以下のttfファイルが作成されたことを確認することができます。Online Font Editorなどでこのフォントは、唯一のtxtファイルの中の文字だけを含んでいることを確認することができます。 powered by Gitbooklast modified: 2020-12-03 10:59:29 "},"problems.html":{"url":"problems.html","title":"FAQ","keywords":"","body":"FAQ UIメインスレッドで時間のかかる作業のために、カードのアップグレードアクティビティが表示されない アクティビティの更新は基本的UIスレッドで処理されます。時間のかかる作業や基本的なUIスレッドで無限ループがある場合、UI更新に影響を及ぼして、カードをアップグレードアクティビティが表示されません。 onUI_init,onUI_intent,onUI_show,onUI_hide,onUI_quit,onUI_Timerとコントロールに関連するいくつかのコールバック関数、これらの関数はすべてUIメインスレッドから呼び出されるため、まず、これらの機能には時間がかかる作業があることを確認してください。 この場合は、カードを挿入した状態で、ボードを再起動するまで、システムが稼動すると、まず、アップグレードが必要かどうかを確認して、アップグレードのインターフェイスが正常に表示されます。 ダウンロードとデバッグ不可能/ダウンロードおよびデバッグに失敗 まず、コンピュータとボードが正しく接続されているかどうか確認してください。WIFIがあるボードである場合WIFI接続のみをサポートし、USBケーブルの接続を使用することができません。同様にWIFIがないボードの場合は、USBケーブルのみ接続できます。一般的に、コンピュータは、USBデバイスとして認識します。 サポートされている接続モードを確認した後IDEのメニュー表示の行に移動してDebug Configuration - > ADB Configurationを選択して保存します。 以後再度ダウンロードしてみてください。ADBを通じたダウンロードおよびデバッグ方法 プログラムが突然自然再起動または中断 まず、プログラムで予期しない状況が発生した場合、ログ（[ログ表示方法]（logcat.md））を確認し、問題を再現し、ログに基づいて、問題のコードを確認する必要があります。 プログラムがクラッシュして再起動すると、一般的に類似したログが表示されます。これらのログは、プログラムが開始され、初期化されるときに出力されるので、これを使用して、プログラムが再起動されたことを確認することができます。 ほとんどのプログラムがクラッシュの原因は、無効なポインタを使用可能性があります。例 : Null pointer 範囲外の配列 ポインタのメモリが解放された後でも、使用 等. プロジェクトは、C言語とC++言語のプログラミングをベースので、ポインタメモリの面で生のポインタを処理することが避けられないので、十分に注意する必要があります。 Divisorは0になることはありませんエラーに注意を払ってない可能性がある別の種類の衝突があります。 プログラムが停止した場合は、ログで再起動現象を見つけることができません。この場合、スレッドデッドロック、コード無限ループ、時間がかかる作業などを分析して確認します。 powered by Gitbooklast modified: 2021-01-04 09:20:10 "},"install_adb_driver.html":{"url":"install_adb_driver.html","title":"ADB driverインストール","keywords":"","body":"Windows XP/ Vista/7/8/10のためのAndroid ADB driverのインストール まず、ADB driverのインストールプログラムをダウンロードして解凍してください。 USBを利用して、コンピュータとAndroid deviceを接続してください。 ADBDriverInstaller.exeを実行した後Installボタンをクリックしてください。 Universal android usbドライバが自動的にコンピュータにインストールされます。 最後にインストールが完了すると、インストール成功のメッセージが表示されます。 Windows XPユーザーは、ドライバのインストール後、コンピュータを再起動することをお勧めします。 powered by Gitbooklast modified: 2020-12-03 15:25:59 "},"convert_platform.html":{"url":"convert_platform.html","title":"プラットフォーム移行","keywords":"","body":"プラットフォーム移行 FlywizOS IDEは、同じプロジェクトのソースを他のハードウェアプラットフォームに移行する機能（Convert Compie Platform）を提供しています。 使い方 : 切り替えたいプロジェクトを選択し、右クリックして、ポップアップメニューのConvert Compile Platformからの移行するプラットフォームを選択してクリックします。 プラットフォーム切替機能の注意事項 プラットフォームの切り替えは、ツールチェーンなどのような基本的なコンパイル環境のみ移行され、ソースコードなどは変わりません。 ハードウェアプラットフォーム間の基本的な違い（ex：シリアルポート、GPIOなど..）があり、これらの部分は、ユーザーが直接変更する必要があります。 ツールチェーンの変更にプラットフォーム移行後、コンパイルが失敗する場合が発生することがあります。この場合、Makefileやソースコードを直接修正して解決します。 powered by Gitbooklast modified: 2020-12-02 15:28:37 "}}