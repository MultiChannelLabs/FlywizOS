{"./":{"url":"./","title":"About us","keywords":"","body":"About us 목표 개발을보다 쉽고 효율적으로 만들고 일반 사용자에게 보다 편리한 맞춤형 개발 프로그램을 제공합니다. 가치 프로페셔널 : 전문 기술로 전문 제품 제조혁신 : 고객에게 꾸준한 가치 흐름을 제공하기위한 지속적인 혁신책임 : 기술을 사용하여 삶을 변화 시키십시오 디스플레이 모듈 정보 Linux 디스플레이 솔루션을 만드는 이유 기술의 발전과 함께 인간-컴퓨터 상호 작용 체계가 업그레이드되었습니다. 현재 일부 전통적인 분야에서 인간-컴퓨터 상호 작용의 발전은 상대적으로 느립니다. 전통적인 분야에는 MCU, MCU + FPGA를 기반으로하는 많은 디스플레이 솔루션이 있어 많은 고객의 대화 형 컬러 스크린 디스플레이 개발의 어려운 문제를 해결했습니다. 그러나 사용자 요구와 대화 형 콘텐츠가 증가함에 따라 기존의 방법은 하드웨어의 제한으로 더 이상 모든 고객의 요구를 충족 시킬 수 없어 이 제품을 만들게 되었습니다. 전통적인 분야의 편리한 인간-컴퓨터 상호 작용 경험에 프로그램 + IoT의 액세스 기능을 강화하고 개발을 돕습니다. 제품 장점 기존 MCU 시리얼 포트 디스플레이 또는 MCU + FPGA 디스플레이 솔루션과 비교 높은 고객 수용도, 낮은 제품 학습 비용 및 우수한 디스플레이 효과와 함께 휴대폰 및 태블릿 컴퓨터와 같은 최신 대화 형 경험을 제공합니다. 레이어 수를 제한하는 기존 디스플레이 방식의 문제를 해결하는 소프트웨어를 통해 다중 레이어 가상화 기술을 구현합니다. png디코딩 기능을 지원하므로 이미지 레이어 오버레이 효과가 더 좋습니다. 시스템 수준에서 WiFi, 이더넷, 2G 및 4G 액세스 기능을 지원하여 고객에게 보다 편리한 네트워크 액세스를 제공하는 동시에 Deep Zhiyun, WeChat IoT, WeChat Pay, Alipay 및 기타 플랫폼에 편리하고 빠르게 액세스 할 수 있어 공유 산업을 위한 빠른 IoT단말 솔루션을 제공 할 수 있습니다. 사용자에게 정보를 표시하는 데 더 용이한 비디오 디코딩 기능을 제공합니다. Android와 기존 Linux솔루션 비교 테스트를 위한 안정적인 하드웨어 기반을 제공하여 하드웨어 개발의 테스트 및 검증기간을 절약합니다. IoT + 디스플레이에 대한 시스템 개발 작업을 제공하여 IoT 및 디스플레이에서 시스템을 재-개발 및 디버깅하는 시간을 절약합니다. 저비용 및 고효율 운영 기능 제공 : 현재 시스템은 1G 단일 코어 CPU, 64MB DDR2, 16MB 플래시에서 실행되어 하드웨어 비용의 50% 이상을 절약합니다. 고객이 맞춤형 개발을 신속하게 완료 할 수 있도록 구성 + 사용자 로직 소스 코드가 포함 된 개발 도구를 제공합니다. 개발기간은 기존 방법보다 최소 60% 단축됩니다. 맞춤화 된 시스템은 3초 만에 빠르게 시작하고 24시간 * 365일 안전하게 작동 할 수 있습니다. 어플리케이션 시나리오 Smart home： Smart Appliances Shared industry Elevator indicator Advertising machine Charging pile Evaluation machine powered by Gitbooklast modified: 2020-12-10 10:13:37 "},"system_introdoction.html":{"url":"system_introdoction.html","title":"FlywizOS 시스템 소개","keywords":"","body":"FlywizOS 시스템 프레임워크 소개 이 시스템은 Linux 시스템을 기반으로하며 자체 개발한 시스템 프레임워크와 GUI 대화형 시스템이 추가되었습니다.우리는 이것을 FlywizOS 시스템이라고 합니다. 시스템 타겟 시나리오 현재 Iot 산업은 빠르게 발전하고 있으며 액정 디스플레이의 가격이 하락함에 따라 사용자 디스플레이에 대한 수요가 증가하고 있습니다. 현재의 발전을 고려하여 우리는 현재 단계에서 더 적합한 디스플레이 솔루션을 제안했습니다. 가전 제품 및 액세스 제어, 높은 시스템 안정성 요구 사항 및 높은 비용 성능 요구 사항과 같은 기능이 있는 소규모 어플리케이션 시나리오에서 Android를 대체합니다. 기존의 흑백 디스플레이 또는 MCU 기반 컬러 디스플레이 솔루션을 대체하고 저렴한 방법으로 대화형 경험을 개선하십시오. Iot 및 공유 시나리오의 도래로 인해 디스플레이와 상호 작용에 대한 수요가 증가했습니다. 비용 효율적이고 안정적인 시스템을 제공합니다. 시스템 구성 커널 오픈 소스 Linux 3.4 커널 버전 기반 IoT 산업에 맞게 맞춤화 및 최적화 됨 시스템 자율 GUI 프레임 워크 네트워크 API 멀티미디어 서비스 IoT 플랫폼 액세스 결제 플랫폼 액세스 기능 원격 업데이트 시스템 기능 원격으로 메시지를 푸시하는 기능 개발 지원 WYSIWYG 구성 GUI 개발 도구 제공 완전한 코드 오픈 지속적으로 업데이트되는 문서 및 샘플 지원 지속적으로 업데이트되는 컨트롤 패키지 및 시스템 업그레이드 서비스 powered by Gitbooklast modified: 2020-12-10 16:01:19 "},"docs_brief.html":{"url":"docs_brief.html","title":"시작하기","keywords":"","body":"시작하기 다음은 입문을 위한 가이드입니다. Tools편 FlywizOS의 LCD보드를 사용하기 전에 사용자는 먼저 개발 도구를 설치를 해야 합니다. Tool을 열고, 개발 환경에 익숙해지면 새로운 프로젝트를 만들어보고, 각 창의 역활에 대해 확인합니다. 새롭게 만들어진 프로젝트의 UI에는 아무것도 없습니다. 간단히 Text 컨트롤을 드래그 앤 드롭으로 만들고, 컴파일 및 다운로드하여 그 결과를 확인할 수 있습니다.Note: 만약 소유하고 있는 보드가 WIFI버전이라면 먼저 ADB IP를 설정해야 정상적으로 프로그램 다운로드가 가능합니다.(프로젝트 실행 방법참고) 우리는 많은 예제 코드를 제공합니다. 소유한 플랫폼에 맞는 예제 코드 패키지를 다운로드 한 후 압축을 해제하여 툴에 Import하면 많은 프로젝트를 확인할 수 있으며, 다른 챕터에서 이에 대해 자세하게 소개하겠습니다. 규칙편 Tool에 익숙해진 후, LCD보드의 개발 규칙에 대해 알아봅니다. 프로젝트의 폴더 구조를 이해하면 프로젝트가 무엇을 포함하며 UI파일, 코드, 리소스가 어디에 있고 저장되는지 알 수 있습니다. 다음으로 어떤 내용들이 툴에 의해 자동으로 생성되는지, UI파일에 해당하는 소스코드가 무엇인지, 컨트롤의 명명규칙등을 알아보겠습니다. 이것들을 이해하고나면 컨트롤을 조작하기 위해서 어떤 코드를 수정해야 하는지 알 수 있습니다. 컨트롤편 개발 화면, 네비게이션 바 등의 다양한 컨트롤과 각 컨트롤의 사용에 대해 소개합니다. Uart편 먼저, 보드에서 사용된 UART를 이용한 통신 모델을 소개합니다. 그 후, 제공된 샘플을 따라해보고 이를 기본으로 프로토콜과 기능을 추가합니다, 끝으로 통신 프레임웍을 실제 구현해보십시오. Update편 두 가지 업그레이드 방법이 있습니다. 이미지 파일 만들기 —— update.img : 이 방법은 프로그램을 보드에 저장하는 것으로 전원이 꺼진 후에도 프로그램이 유지됩니다. Note : 일반적인 다운로드 및 디버깅과의 차이점에 주의하세요. 이 방법은 가장 일반적으로 사용되는 방법이기도 합니다. 업그레이드 카드 만들기 —— 전체 시스템을 포맷합니다. 시스템이 새로운 버전으로 업데이트 되면, 공식적으로 해당하는 업데이트 파일이 제공됩니다. 사용자는 이 파일과 전용 툴을 이용하여 TF카드를 업그레이드 전용 카드로 만들어 보드를 업그레이드 할 수 있습니다. 또한 시스템이 켜지지 않을 경우에도 역시 이 방법을 사용하여 복구할 수 있습니다. Debug편 현재 프로그램은 로그로만 디버깅 할 수 있습니다. Module편 코어 모듈 소개를 참고하십시오. Hardware편 하드웨어 소개를 참고하십시오. FAQ편 FAQ를 참고하십시오. powered by Gitbooklast modified: 2020-12-14 10:50:21 "},"download.html":{"url":"download.html","title":"개발 환경 설치","keywords":"","body":"개발 환경 설치 FlywizOS IDE와 SDK 설치 Windows FlywizOS IDE SDK update [!TIP] 새로운 유저를 위해 SDK는 이미 FlywizOS IDE설치 패키지에 포함되어 있어 단독으로 다운로드 할 필요가 없습니다. 만약 SDK 파트만 단독으로 업데이트 하기 원한다면, SDK를 다운로드하고 압축해제해서 SDK폴더를 교체하십시오. SDK 업데이트 패키지(1.4.5) powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"flywizOS_ide_snapshot.html":{"url":"flywizOS_ide_snapshot.html","title":"처음 사용","keywords":"","body":"FlywizOS IDE 처음 사용 FlywizOS IDE가 성공적으로 설치되면 개발자는 데스크탑 바탕화면에서 바로가기를 더블 클릭하여 IDE를 실행합니다.만약 바로가기를 삭제했다면, 설치된 폴더에서 bin폴더에서 를 찾아 직접 실행할 수 있습니다. Workspace 선택 IDE를 실행하면, 아래의 팝업화면을 볼 수 있습니다. Workspace는 개발에 관련된 설정과 이력이 저장되는 공간입니다. 이 공간은 여러 프로젝트를 동시에 관리하는 컨테이너처럼 이해할 수 있어, IDE를 동시에 여러개 실행할 필요가 없습니다. Welcome 화면 만약 처음으로 IDE를 실행하고 workspace를 선택하고나면 아래 그림의 Welcome화면을 볼 수 있습니다. 이 화면은 2가지의 기능을 제공합니다 : New Project , Import Project New Project어떻게 새로운 프로젝트를 생성하는지를 단계적으로 수행합니다. Import Project이 기능을 통해 기존에 만들어졌던 프로젝트들을 현재의 Workspace에 가져와서 이전 개발을 지속할 수 있습니다.프로젝트 가져오기 Welcome화면을 다시 열기를 원한다면 메뉴에서 Help -> Welcome을 선택하십시오. ​ powered by Gitbooklast modified: 2020-12-14 10:05:31 "},"flywizOS_ide_layout_introduce.html":{"url":"flywizOS_ide_layout_introduce.html","title":"작업 영역 소개","keywords":"","body":" FlywizOS IDE의 작업 영역 새로운 프로젝트가 만들어지면, 아래의 화면을 볼 수 있습니다. 에디터는 대략 6개의 영역으로 나누어지며, 관련된 기능은 다음과 같습니다. ① Area-Project Explorer 이 영역은 트리의 형태로 프로젝트의 폴더 및 파일들을 표시합니다. 자유롭게 확장/축소가 가능하며, 더블 클릭으로 원하는 파일을 열어 수정할 수 있습니다. ② Area-Edit box 이 영역은 코드를 수정하거나, UI화면을 미리보기 할 수 있습니다. 개발의 주 영역입니다. ③ Area-Control Box 이 영역은 모든 컨트롤을 포함하고 있습니다. 여기에서 필요한 컨트롤을 클릭하고 ②area로 드래그하여 컨트롤을 만들 수 있습니다. ④ Area-Properties 이 영역은 area②에 있는 컨트롤을 클릭하면, 해당 컨트롤의 속성들을 표시합니다. 모든 속성들은 테이블의 형식으로 표시되며, 이 곳에서 원하는대로 속성을 변경할 수 있습니다. ⑤Area-Outline 이 영역은 트리의 형태로 UI파일 안의 모든 컨트롤을 표시합니다. 역시 자유롭게 확장/축소가 가능하며, 컨트롤간의 계층 관계를 파악할 수 있습니다. 그리고, 노드를 드래그하여 빠르게 계층 구조를 변경할 수 있으며, 각 컨트롤을 숨기거나 보일 수 있습니다. 이 기능은 복잡한 계층 구조를 사용하기 쉽게 합니다. ⑥ Area-Console 코드를 컴파일하면 이 영역에 컴파일에 대한 결과가 표시됩니다. 만약 컴파일이 실패할 경우 해당 에러를 더블 클릭하면 바로 해당 코드로 이동할 수 있습니다. powered by Gitbooklast modified: 2020-12-09 11:51:03 "},"new_flywizOS_project.html":{"url":"new_flywizOS_project.html","title":"새로운 프로젝트","keywords":"","body":"새로운 FlywizOS 프로젝트 생성 새로운 FlywizOS 프로젝트를 만드는 것은 매우 간단합니다. 구체적인 단계는 다음과 같습니다. IDE의 상단 메뉴바에서 File -> New -> FlywziOS Application Project를 선택합니다. 선택이 완료되면 FlywizOS New Wizard가 팝업됩니다. 새로운 프로젝트를 만드는데 필요한 파라미터들을 채우십시오. Project name프로젝트의 이름입니다. 숫자와 문자의 조합으로 만들 수 있습니다. Location프로젝트가 저장될 경로입니다. Platform소유한 보드에 맞는 플랫폼을 선택하십시오. FW9311 FW9306 위의 파라미터들을 채운 후, 바로 Finish를 누르면 프로젝트가 생성됩니다. 그러나 지금은 더 많은 설정을 위해 Next를 선택하겠습니다. Next 클릭 후, 아래와 같은 파라미터들을 볼 수 있습니다. 프로젝트의 각 속성의 의미와 기능 Screen saver timeoutFlywizOS 시스템은 스크린세이버 기능을 제공합니다. 만약 특정 시간 내에 터치 조작이 없거나, 코드를 통해 스크린세이버 시간을 리셋하지 않는다면 시스템은 자동으로 스크린세이버로 진입합니다.시간이 -1이면 스크린세이버 기능을 사용하지 않겠다는 의미입니다. Serial port통신용 시리얼 포트이며 일반적으로 수정할 필요가 없습니다. Baud rate통신용 시리얼 포트의 Baud rate입니다. Resolution스크린의 width와 height입니다. 단위는 픽셀입니다. Screen rotation화면을 회전시킬 수 있습니다. FontFlywizOS는 custom font를 지원합니다. 만약 기본 폰트가 만족스럽지 않다면, Default를 해제하고 사용할 폰트를 선택할 수 있습니다. Input method만약 중국어 입력이 필요하다면 선택하십시오. 그리고 Edit Text 컨트롤의 중국어 입력을 해결하십시오. 위 속성들은 이후 다시 수정이 가능하니 이곳을 채우는 것을 걱정하지 마십시오.(프로젝트의 속성을 수정하는 방법)채워진 모든 속성을 확인하고, Finish를 누르면 프로젝트 생성이 끝납니다. 생성 프로세스에는 약간의 시간이 걸리므로 잠시 기다려주십시오. 프로젝트가 생성되면 먼저 FlywizOS 프로젝트 코드 구조를 이해해야 합니다. powered by Gitbooklast modified: 2020-12-09 17:38:43 "},"import_project.html":{"url":"import_project.html","title":"프로젝트 가져오기","keywords":"","body":"Import FlywizOS project 현재의 워크스페이스에 다운로드한 샘플 프로젝트를 가져올 수 있습니다.그 과정은 아래와 같습니다. 상단의 메뉴에서 File -> Import를 선택합니다. 팝업되는 박스에서 General -> Existing Project to Workspace를 선택 후 Next를 누릅니다. 팝업 박스에서 Browse버튼을 누르고, 가져오려 프로젝트가 있는 폴더를 선택한 후 OK를 누르면 폴더 안의 프로젝트가 팝업창에 표시됩니다. 만약 프로젝트가 손상되지 않았다면, 팝업창에는 각각의 프로젝트가 나열되고, 가져오려는 프로젝트를 선택 후 Finish를 누르면 Project Explorer에 선택한 프로젝트가 추가됩니다. 아래는 예제 영상입니다. powered by Gitbooklast modified: 2020-12-09 14:40:18 "},"new_flywizOS_ui_file.html":{"url":"new_flywizOS_ui_file.html","title":"새로운 UI파일","keywords":"","body":"새로운 FlywizOS UI 파일 생성 새로운 UI파일을 생성하는 것은 새로운 FlywizOS 프로젝트 생성과 유사합니다. Project Explorer에서 UI파일을 생성하고자하는 프로젝트의 ui폴더에서 오른쪽 클릭 후 팝업되는 메뉴에서 New -> FlywizOS UI file을 선택합니다. 위의 단계를 수행하면 New FlywizOS UI File Wizard가 아래 보이는 것처럼 팝업됩니다. 여기에는 지정할 세 가지의 속성이 있습니다. File nameUI파일의 파일 이름을 지정해야 합니다. 파일 이름은 문자와 숫자로 지정되며 확장자는 ftu (FlywizOS UI파일) 입니다. Resolution해상도를 픽셀 단위로 조정하여 UI 인터페이스의 width와 height를 제어할 수 있습니다. UI Type현재 창 유형에는 Normal, Status Bar, Navigation Bar, Screensaver가 있습니다. 일반적으로 Normal이 선택되고, 다른 세 가지 유형에 대해서는 시스템 어플리케이션 소개를 참고하십시오. 속성 설정이 끝난 후 Finish를 선택하면 생성 과정이 종료되며, project explorer의 프로젝트 ui폴더에서 새로 생성된 파일을 볼 수 있습니다. powered by Gitbooklast modified: 2020-12-09 17:41:12 "},"how_to_compile_flywizOS.html":{"url":"how_to_compile_flywizOS.html","title":"프로젝트 컴파일","keywords":"","body":"FlywizOS 프로젝트 컴파일 FlywizOS 프로젝트를 컴파일 하는 것은 매우 간단하며, 3가지 방법이 있습니다. 1. Project Explorer에서 컴파일 Project Explorer에서 컨파일하려는 프로젝트를 찾아 선택하고 마우스 오른쪽 클릭하여 팝업되는 메뉴에서 Compile Project를 선택하면 자동으로 프로젝트가 컴파일됩니다. 아래는 관련 동영상입니다. 2. Toolbar에서 컴파일 IDE의 상단부 툴바에 컴파일 단축키가 있습니다. 1과 유사하게 Project Explorer에서 컴파일하려는 프로젝트를 찾아 선택하고 해당 버튼을 누르면 컴파일이 진행됩니다. 프로젝트 선택 후 녹색의 삼각형을 클릭하면 컴파일이 진행됩니다. 3. 단축키로 컴파일 가장 간단한 방법으로 코딩 중 Ctrl + Alt + Z를 누르면 빠르게 컴파일이 진행됩니다. 프로젝트 클린 업 프로젝트 컴파일 후, 일반적으로 오브젝트 파일과 임시 파일들이 남게됩니다. 예를 들어 컴파일 시간이 단축을 위해 libs와 obj 폴더가 남겨집니다. 개발자는 이것들을 수동으로 삭제할 수도 있고, 메뉴를 통해 자동으로 삭제할 수도 있습니다. 수동 삭제먼저 삭제하려는 폴더를 선택하고 마우스 오른쪽 버튼을 클릭하여 팝업되는 메뉴에서 Delete를 선택하여 삭제합니다. 자동 삭제만약 매번 수동으로 삭제한다면, 다른 중요한 파일을 삭제하는 등의 실수가 발생할 수 있습니다. 그러므로 자동 클린업으로 이러한 상황을 방지하십시오. 먼저 프로젝트의 이름을 선택하고 마우스 오른쪽 클릭을하여 팝업되는 메뉴에서 Clear Project를 선택합니다. 그러면 자동으로 libs와 obj 폴더가 삭제됩니다. (이 경우 폴더 안의 파일들은 삭제되지만, 폴더 자체가 삭제되지는 않습니다.) Note: 만약 컴파일 중 이상한 문제가 발생하거나, 프로그램에서 소스가 컴파일되지 않는다면 먼저 Clear Project를 실행하고, 다시 컴파일을 수행해 보십시오. 특히 다른 사람의 프로젝트를 가져와서 컴파일 하는 경우 종종 이러한 현상이 발생할 수 있습니다. Recompile 만약 코드를 다시 컴파일하고 싶다면, 먼저 프로젝트를 클린업하고 컴파일을 하십시오. powered by Gitbooklast modified: 2020-12-09 14:30:50 "},"run_project.html":{"url":"run_project.html","title":"프로젝트 실행","keywords":"","body":"프로젝트 실행 방법 프로젝트를 컴파일 후 실제 보드에서 실행되도록 할 수 있습니다. 모델에 따라 다음과 같은 몇 가지 동작 모드가 있습니다. WIFI를 사용하여 장치를 빠르게 연결 이 방법은 WIFI가있는 모델 만 지원하며 현재 지원되는 모델은 다음과 같습니다. sw480272043B_CW 4.3인치 sw480272043B_CWM 4.3인치 sw80480043B_CW 4.3인치 sw48854050B_CW 5인치 sw80480070A_CW 7인치 sw80480070A_CWM 7인치 sw80480070AI_CW 7인치 sw80480070AI_CWM 7인치 sw10600070A_CW 7인치 제품 모델 설명 장치가 WIFI를 지원하는지 확인한 후 아래 단계에 따라 구성을 완료하십시오. 먼저 장치의 WIFI 설정 액티비티에 진입하고, 장치를 컴퓨터와 동일한 WIFI 네트워크에 연결합니다. 즉, 컴퓨터와 기기가 동일한 WIFI에 연결되어야 합니다.(다른 네트워크일 경우 다운로드가 실패할 수 있습니다) 무선 네트워크 연결에 성공하면 WIFI 설정 액티비티의 오른쪽 상단 모서리에 있는 메뉴를 클릭하여 장치의 IP 주소를 확인합니다. 이후 컴퓨터의 IDE로 돌아가 상단 메뉴에서 FlywizOS -> ADB Configuration을 선택하고 팝업 상자에서 ADB connection method의 Net를 선택합니다. 장치의 IP 주소를 입력하고 저장하십시오. 연결 설정을 완료 한 후 다운로드 및 디버그 메뉴 항목을 선택하면 프로젝트 코드를 연결된 장치와 일시적으로 동기화하여 실행할 수 있습니다. USB 연결 장치로 빠른 작동 WIFI 기능이 없는 모델의 경우 거의 모두 USB 케이블 연결을 지원합니다.참고 : WIFI 기능이 있는 경우 USB 케이블 연결이 유효하지 않습니다. USB 케이블을 통해 기기를 컴퓨터에 연결하세요. 컴퓨터가 기기를 Android 기기로 인식 할 수 있으면 연결이 정상입니다. 정상적으로 연결할 수 없는 경우 컴퓨터에 드라이버 문제가 표시됩니다. 드라이버 다운로드를 시도해보십시오. 컴퓨터가 장치를 올바르게 인식하면 IDE로 돌아가 상단 메뉴에서 FlywizOS->ADB Configuration을 선택하고 팝업 상자에서 ADB connection method의 USB를 선택 후 저장합니다. 연결 설정을 완료 한 후 다운로드 및 디버그 메뉴 항목을 선택하면 프로젝트 코드를 연결된 장치와 일시적으로 동기화하여 실행할 수 있습니다. TF 카드에서 부팅 USB와 WIFI를 모두 정상적으로 사용할 수 없거나 사용중인 경우 TF카드를 사용하여 TF카드에서 프로그램을 시작할 수 있습니다. 자세한 내용은 TF 카드에서 프로그램 시작을 참조하십시오. powered by Gitbooklast modified: 2020-12-10 11:49:33 "},"project_structure.html":{"url":"project_structure.html","title":"프로젝트 구조 소개","keywords":"","body":"FlywizOS 프로젝트의 코드 구조 소개 프로그래밍을 시작하기 전에 먼저 FlywizOS 프로젝트의 기본 구조를 이해해야 코드를 추가해야하는 위치를 알 수 있습니다.기본 FlywizOS 프로젝트의 경우 디렉터리 구조는 다음과 같습니다. 크게 jni, resources, ui의 세 폴더로 나뉘며 각 폴더의 역할은 아래와 같습니다. ui폴더 ui폴더 확장합니다. main.ftu파일이 기본적으로 포함되어 있음을 알 수 있습니다. ftu는 FlywizOS프로젝트 UI 파일의 접미사입니다. 각 ftu파일은 액티비티에 해당합니다. 일반적으로 애플리케이션에는 여러 액티비티가 포함되어 있으므로 ui폴더에 여러 ftu파일을 만들어야 합니다. 새 ftu파일을 추가하려면 새로운 FlyThings UI 파일 생성 방법을 참조하세요. 설명의 편의를 위해 이후부터는 ftu파일을 UI 파일이라고 하겠습니다.. 더블 클릭하여 UI 파일을 열고 편집하여 즉시 효과를 미리 볼 수 있습니다. UI파일 편집의 특정 단계는 컨트롤 소개를 참조하십시오. 편집 후 compile을 시작할 수 있습니다. (컴파일 방법) [!Note]참고 : 여기에 언급 된 컴파일은 소스 코드의 컴파일일 뿐만 아니라 ui 파일의 전처리 및 템플릿 코드 생성과 같은 일련의 작업이기도 하지만 이러한 작업은 모두 자동화되어 있으므로 수동으로 작업 할 필요가 없습니다.컴파일 - 이 작업의 모든 특정 작업에 대해서는 컴파일 과정 및 UI 파일과 소스 코드 간의 상관 관계를 참조하십시오. 이를 읽은 후에는 이해하기 쉽고 빠르게 시작할 수 있을 것입니다 resources folder 이 폴더의 내용은 비교적 간단하며 주로 그림, 폰트, 입력 방법 구성 파일 등을 포함하여 프로젝트의 다양한 리소스 파일을 저장하는 데 사용됩니다. 다른 리소스 파일이 있는 경우 이 폴더에 추가 할 수도 있습니다. 폴더는 시스템에 완전히 복사됩니다. 단, 기기 자체 저장 공간의 제한으로 이 디렉토리에 대용량 파일을 저장하지 않는 것이 좋으며 대용량 리소스 파일은 TF카드에 저장하는 것이 좋습니다. 코드의 resources디렉토리에 있는 파일의 절대 경로를 얻을 수 있습니다.예 : 다음 코드는 resources/test.txt의 절대 경로를 가져올 수 있습니다. #include \"manager/ConfigManager.h\" std::string resPath = CONFIGMANAGER->getResFilePathEx(\"test.txt\"); jni folder 이 폴더는 주로 코드 파일을 저장하는 데 사용됩니다.jni 폴더를 확장합니다. 위에 보이는 것처럼 여기에는 activity, include, logic, uart, Main.cpp, Makefile의 6 개 부분이 포함되어 있습니다. 각 부분의 기능은 다음과 같습니다. activity subfolder UI 파일의 기본 클래스 코드를 저장합니다. 각 UI파일이 컴파일 된 후 동일한 접두사 이름을 가진 Activity클래스와 Logic.cc파일이 생성됩니다. 예 : ui 폴더에 main.ftu가 있는 경우 컴파일 후 mainActivity.h, mainActivity.cpp 및 mainLogic.cc가 생성되고 mainActivity클래스가 activity폴더에 저장됩니다. mainLogic.cc 파일은 logic폴더에 저장됩니다. [!Warning] 특별한 상황을 제외하고 activity 폴더 아래의 코드는 수정하지 않는 것이 좋습니다. logic subfolder 특정 논리 코드를 저장합니다. 위의 설명과 동일하게 모든 UI파일은 컴파일 후 해당 접두사 이름이 있는 Logic.cc파일을 생성합니다. 참고 : 사용자 지정 코드는 주로 이러한 Logic.cc파일에 추가됩니다. include subfolder 시스템 관련 헤더 파일 및 모든 컨트롤 관련 헤더 파일이 주로 여기에 저장됩니다. uart subfolder 이름에서 알 수 있듯이 이 폴더에는 시리얼 포트 읽기 및 쓰기, 프로토콜 분석 등을 포함한 시리얼 포트 동작 관련 코드가 저장됩니다. Main.cpp 부팅 및 시작 액티비티를 선택하는 함수 등 전체 FlywizOS 응용 프로그램의 초기화 코드를 포함하며 일반적으로 파일을 수정할 필요가 없습니다. Makefile/Android.mk、Application.mk 특정 소스 코드 컴파일 프로세스를 포함하는 컴파일 구성 파일로 일반적으로 수정할 필요가 없습니다. 컴파일 후 libs디렉토리와 obj디렉토리가 프로젝트 아래에 생성됩니다. 이 디렉토리는 컴파일된 대상의 라이브러리 디렉토리와 컴파일된 임시 파일 디렉토리이며 둘 다 직접 정리하거나 삭제할 수 있습니다. powered by Gitbooklast modified: 2020-12-10 09:56:12 "},"ftu_and_source_relationships.html":{"url":"ftu_and_source_relationships.html","title":"UI파일과 생성된 코드 설명","keywords":"","body":"FlywizOS의 컴파일 과정과 UI파일 및 소스 코드의 상관 관계 UI파일의 컨트롤이 포인터 변수와 연결되는 방식 FlywizOS는 간편한 관리를 위해 UI와 code를 분리했습니다.아래 그림에서, UI파일은 프로젝트의 UI폴더의 모든 ftu파일들입니다.개발하는 동안 코드의 중복을 줄이기 위해서, FlywizOS IDE는 컴파일 과정을 개선했습니다. 실제 소스 코드를 컴파일 하기 전에, IDE는 먼저 UI파일로부터 생성된 동일한 접두사 이름을 가지는 Logic.cc파일을 생성합니다.(예 : main.ftu는 mainLogic.cc파일이 생성됨). 여기서 Logic.cc파일의 생성은 바로 덮어써지는 것이 아니라, 점차적으로 수정된다는 것에 주의해야 합니다.컴파일 시, IDE는 각 Ui파일을 순회하며 UI파일에 포함된 컨트롤을 읽어 코드에 컨트롤을 위한 포인터 변수를 정의하고, 개발자는 이 포인터를 이용하여 해당하는 컨트롤을 제어할 수 있습니다. 이 포인터 변수들은 UI파일과 동일한 접두사 이름을 가지는 Activity.cpp 파일 안에 정의됩니다. main.ftu를 예로 들면, 아래와 같습니다. 위의 그림에서 보는 것처럼 모든 포인터들은 static global변수들입니다. 그리고, 그것들은 모두 동일한 이름 지정 규칙에 의해 생성되었습니다. 이 이름 지정 규칙은 컨트롤의 ID를 기반으로 한 포인터 변수의 이름 지정 규칙을 참고하십시오. 그리고 위 그림에서 #include \"logic/mainLogic.cc\"도 주의해야 할 부분으로, mainLogic.cc은 mainActivity.cpp에 포함되고, 개발자는 mainLogic.cc에서 필요한 코딩을 하기에 모든 컨트롤 포인터 변수를 사용할 수 있습니다.만약 이 포인터들의 초기화에 관심이 있다면 mainActivity의 onCreate 함수를 찾아보십시오. UI파일들과 Logic.cc파일들 사이의 관계 위에서 우리는 UI파일의 컨트롤이 어떻게 포인터 변수와 연결되는지에 대해서 알아보았습니다. 이제는 mainLogic.cc파일에 어떤 것들이 자동으로 생성되는지 알아보겠습니다. 만약 UI파일에 아무런 컨트롤도 추가하지 않았다면 mainLogic.cc파일은 아래와 같습니다. /** * Register timer * Fill the array to register the timer * Note: id cannot be repeated */ static S_ACTIVITY_TIMEER REGISTER_ACTIVITY_TIMER_TAB[] = { //{0, 6000}, //Timer id=0, period 6 second //{1, 1000}, }; /** * Triggered when the interface is constructed */ static void onUI_init(){ //Add the UI initialization display code here, for example : //mText1Ptr->setText(\"123\"); } /** * Triggered when switching to this interface */ static void onUI_intent(const Intent *intentPtr) { if (intentPtr != NULL) { //TODO } } /* * Triggered when the interface is displayed */ static void onUI_show() { } /* * Triggered when the interface is hidden */ static void onUI_hide() { } /* * Triggered when the interface completely exits */ static void onUI_quit() { } /** * Serial data callback interface */ static void onProtocolDataUpdate(const SProtocolData &data) { } /** * Timer trigger function * It is not recommended to write time-consuming operations in this function, otherwise it will affect UI refresh * Parameter : id * The id of the currently triggered timer is the same as the id at registration * Return : true * Keep running the current timer * false * Stop running the current timer */ static bool onUI_Timer(int id){ switch (id) { default: break; } return true; } /** * Triggered when there is a new touch event * Parameter : ev * new touch event * Return : true * Indicates that the touch event is intercepted here, and the system will no longer pass this touch event to the control * false * Touch events will continue to be passed to the control */ static bool onmainActivityTouchEvent(const MotionEvent &ev) { switch (ev.mActionStatus) { case MotionEvent::E_ACTION_DOWN://Touch press // LOGD(\"event time = %ld axis x = %d, y = %d\", ev.mEventTime, ev.mX, ev.mY); break; case MotionEvent::E_ACTION_MOVE://Touch move break; case MotionEvent::E_ACTION_UP: //Touch up break; default: break; } return false; } 아래는 각 함수들에 대한 설명입니다. REGISTER_ACTIVITY_TIMER_TAB[ ] array타이머 등록에 사용됩니다. 이 구조체 배열은 아래와 같습니다. typedef struct { int id; // Timer ID, cannot be repeated int time; // Timer interval, unit millisecond }S_ACTIVITY_TIMEER; 본질적으로, 이 배열은 void registerTimer(int id, int time)함수에 의해 시스템에 등록되고, mainActivity.cpp의 rigesterActivityTimer()함수에서 참조될 것입니다. void onUI_init()액티비티의 초기화에 사용됩니다. 만약 UI 액티비티의 시작 시 초기화가 필요한 컨텐츠가 있다면 이 함수에 코드를 추가할 수 있습니다.이 함수는 mainActivity.cpp의 onCreate()함수에서 호출됩니다. void onUI_quit()액티비티의 종료에 사용됩니다. 만약 UI 액티비티 종료 시 어떤 작업이 필요하다면, 이 함수에 코드를 추가할 수 있습니다.이 함수는 mainActivity.cpp의 파괴자에서 호출됩니다. void onProtocolDataUpdate(const SProtocolData &data)시리얼 포트 데이터를 받는데 사용됩니다. 시리얼 데이터 프레임이 분석된 후 이 함수가 호출됩니다.이 함수는 mainActivity.cpp의 onCreate()에서 void registerProtocolDataUpdateListener(OnProtocolDataUpdateFun pListener)를 통해 등록되고, mainActivity.cpp의 파괴자에서 등록 해제됩니다. 더 자세한 사항은 시리얼 프레임웍을 참고하십시오. bool onUI_Timer(int id)타이머 콜백 함수입니다. 등록된 타이머의 타이머 주기가 도달했을 때, 시스템에 의해 호출됩니다. 타이머가 여러 개 등록되었었다면, id파라미터로 각 타이머를 구분할 수 있습니다. 이 id는 REGISTER_ACTIVITY_TIMER_TAB[] array에 등록된 id와 같습니다.Return true 해당 타이머를 계속 유지합니다.Return false 해당 타이머를 중지합니다.false를 반환하여 타이머를 중지했다면 어떻게 다시 시작합니까?타이머를 임의로 시작 및 중지하는 방법을 참조하십시오. bool onmainActivityTouchEvent(const MotionEvent &ev)터치 이벤트 콜백 함수입니다. 모든 터치 메세지를 수신 가능합니다.유사하게 mainActivity.cpp의 registerGlobalTouchListener를 통해 등록되며, 등록이 완료된 이후에야 터치 이벤트가 수신됩니다.Return true 터치 이벤트가 더이상 다른 컨트롤로 전달되지 않습니다.Return false 터치 이벤트가 지속적으로 다른 컨트롤로 전달됩니다.터치 이벤트 처리에 대한 이해를 참고하십시오. 이상은 기본 UI파일이 컴파일 될 때 자동으로 Logic.cc에 생성됩니다. UI파일에 컨트롤을 추가하고 컴파일을 한다면, IDE는 해당하는 Logic.cc에 각각의 컨트롤과 관련된 함수들을 자동을 생성할 것입니다.예를 들어, main.ftu UI 파일에 두 개의 버튼 컨트롤을 추가하고, 각가의 ID를 Button1과 Button2로 만들어 컴파일하면, 아래의 2개 함수가 mainLogic.cc파일에 생성됩니다. static bool onButtonClick_Button1(ZKButton *pButton) { //LOGD(\" ButtonClick Button1 !!!\\n\"); return false; } static bool onButtonClick_Button2(ZKButton *pButton) { //LOGD(\" ButtonClick Button2 !!!\\n\"); return false; } 함수의 이름에 주목하십시오. 함수의 이름은 컨트롤의 ID를 포함하고 있어, 컨트롤의 ID는 C언어의 네이밍 표준을 준수해야 합니다. 만약 계속적으로 컨트롤을 추가한다면, 추가된 컨트롤과 관련된 함수들은 컴파일 후에 mainLogic.cc에 생성됩니다. 일반적으로 개발하는 동안, UI파일에서 컨트롤의 추가/삭제/수정이 매우 빈번히 일어나는데, 이러한 상황에서 IDE는 아래와 같이 동작합니다. 컨트롤을 추가하는 경우 - IDE는 컴파일 시 컨트롤의 ID를 기반으로하여 관련된 함수를 생성하는데, 만약 동일한 함수가 이미 존재한다면, 그 과정을 건너뛰어지고, Logic.cc파일도 변경되지 않습니다. 컨트롤을 삭제하는 경우 - UI파일에 존재하는 컨트롤을 삭제하더라도 관련된 함수는 계속적으로 존재합니다. 만약 관련 함수 역시 삭제된다면, 의도하지 않은 코드의 손실이 발생할 수 있어 FlywizOS IDE에서는 삭제하지 않는 것으로 결정했습니다. 컨트롤을 수정하는 경우 - 생성된 컨트롤 관련 함수는 오직 컨트롤의 ID와만 관련이 있습니다. 만약 Ui파일에서 컨트롤의 ID 이외의 속성을 수정한다면 이는 관련 함수에는 영향을 미치지 않습니다. 만약 컨트롤의 ID를 수정 후 컴파일을 한다면, 새롭게 컨트롤을 추가하는 것과 동일한 과정이 진행되고, 기존 생성되었던 관련 함수는 유지됩니다. 이 장에서는 오직 버튼 컨트롤과 관련된 예제로 UI파일의 컨트롤과 Logic.cc에 생성된 관련 함수의 관계에 대해서만 설명하였습니다. FlywizOS는 또한 다른 컨트롤(예 : Slide Bar, List, Slide Windows등) 에 대해서도 관련된 함수를 제공합니다. 더 자세히 다른 컨트롤과 관련된 함수에 대해 알고 싶다면 컨트롤에 의해 자동으로 생성된 함수들의 관계에 대한 설명을 참고하십시오. 끝으로, 아래의 그림은 ftu파일과 코드 사이의 상관 관계에 대한 간략한 그림입니다. powered by Gitbooklast modified: 2020-12-09 14:25:07 "},"named_rule.html":{"url":"named_rule.html","title":"컨트롤 이름 지정 규칙","keywords":"","body":"이름 지정 규칙 UI파일에 추가한 대부분의 컨트롤은 컴파일 후 관련된 포인터 변수와 매크로 ID가 자동으로 생성됩니다. 컨트롤 ID와 포인터 변수 이름를 위한 이름 지정 규칙 포인터 변수 이름은 각기 고정된 소문자 접두사m + ID 값+ Ptr의 세 개의 파트로 구성됩니다.Textview1을 ID로 가지는 컨트롤을 예로 들어보겠습니다. 컴파일 후 해당하는 포인터 변수의 이름은 mTextview1Ptr로 생성됩니다. 포인터 변수의 class는 컨트롤에 의해 결정됩니다. 각 컨트롤에 해당하는 포인터 class는 아래와 같습니다. (프로젝트의 jni/include폴더에서 각 class의 헤더파일을 찾을 수 있습니다.) Control name Class name ZKQRCode ZKEditText ZKButton ZKTextView ZKSeekBar ZKPointer ZKCircleBar ZKDigitalClock ZKVideoView ZKCameraView ZKWindow ZKListView ZKSlideWindow ZKDiagram 컨트롤 ID와 macro definition의 naming 규칙 이 macro definition은 UI파일에서 컨트롤의 매핑 관계를 나타냅니다.Macro definition은 고정된 대문자 ID, 대문자 UI파일 이름, 컨트롤 property의 ID값의 세 파트로 구성됩니다. ID를 Textview1로 가지는 컨트롤의 예를 보겠습니다. 컴파일 후, 해당하는 macro statement는 #define ID_MAIN_TextView1 50001로 생성됩니다. [!Warning] Macro definition의 값을 수정하지 마십시오. 그렇지 않으면 비 정상동작의 원인이 될 수 있습니다. 컨트롤에 의해 생성되는 관련 함수 어떤 컨트롤들은 관련된 함수를 자동으로 생성할 것입니다. 아래는 이러한 컨트롤들에 의해 자동으로 생성된 함수들에 대한 설명입니다. [!Note] 함수에서 XXXX는 컨트롤의 ID값 입니다. Button 컨트롤 static bool onButtonClick_XXXX(ZKButton *pButton) { return false; } 버튼이 클릭되면 호출되는 함수입니다. 파라미터 ZKButton *pButton은 클릭된 버튼의 포인터이고, 포인터의 멤버 변수들을 통해 일련의 operation을 수행할 수 있습니다. 이 포인터는 전역 변수 mXXXXPtr가 가리키는 객체와 동일한 객체의 포인터입니다. Edit Text 컨트롤 static void onEditTextChanged_XXXX(const std::string &text) { } Edit box가 변경되었을 때, 시스템에 의해 자동적으로 호출되는 함수입니다. 파라미터 std::string &text는 현재 Input box의 contents입니다. Seek Bar 컨트롤 static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress) { } Seek Bar의 프로그래스 값이 변경되면, 시스템에 의해 자동으로 호출되는 함수입니다. 파라미터 ZKSeekBar *pSeekBar는 Seek Bar의 포인터 변수이고, 포인터의 멤버 변수들을 통해 일련의 operation을 수행할 수 있습니다. 파라미터 int progress는 현재 Seek Bar의 프로그래스 값입니다. Slide window 컨트롤 static void onSlideItemClick_XXXX(ZKSlideWindow *pSlideWindow, int index) { } Slide window컨트롤의 아이콘이 클릭되었을 때, 시스템에 의해 자동으로 호출되는 함수입니다. 파라미터 ZKSlideWindow *pSlideWindow는 Slide window 컨트롤의 포인터 변수이고, 포인터의 멤버 변수들을 통해 일련의 operation을 수행할 수 있습니다. 파라미터 int index는 현재 클릭된 아니콘의 index 값입니다. 예를 들어, Slide window에 총 10개의 아이콘을 추가했다면 index 값의 범위는 [0, 9]입니다. List 컨트롤 리스트 컨트롤은 가장 복잡한 컨트롤로 세 개의 관련된 함수를 생성합니다. 비록 많은 함수들이 있지만 아래 단계에 따라하면 쉽게 이해할 수 있습니다. 먼저, 만약 시스템이 리스트 컨트롤을 그리기 원하면, 얼마나 많은 아이템이 있는지 알아야합니다. 아래는 이와 관련된 함수입니다. static int getListItemCount_XXXX(const ZKListView *pListView) { return 0; } 파라미터 const ZKListView *pListView는 List 컨트롤의 포인터이고, 전역 변수 mXXXXPtr와 동일한 객체를 가리킵니다. 리턴 값은 정수이고 리스트에 있는 아이템의 수를 나타내며, 필요에 따라 결정됩니다. 시스템이 리스트의 아이템 수를 알아냈지만 이것 만으로 리스트를 그리기에는 부족하고 각 아이템에 어떤 컨텐츠를 표현해야 하는지도 알아야합니다. 그래서 아래의 함수가 있습니다. 표시하려는 아이템의 수 만큼 아래 함수가 호출되어 표시할 내용을 설정하게 됩니다. static void obtainListItemData_XXXX(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { //pListItem->setText(index) } 파라미터 ZKListView *pListView는 List 컨트롤의 포인터이고, 전역 변수 mXXXXPtr와 동일한 객체를 가리킵니다. 파라미터 ZKListView::ZKListItem *pListItem는 리스트 아이템의 포인터이고 UI파일에서 Item에 해당합니다. 파라미터 int index는 전체 리스트에서 pListItem의 index값 입니다.예 : getListItemCount_XXXX함수의 리턴 값이 10이라는 의미는 리스트에 10개의 아이템이 있고, index 값의 범위가 [0, 9]라는 것입니다.pListItem과 index를 연결하여 전체 리스트에서 어떤 아이템을 설정해야 할지 알 수 있습니다. 이 함수에서 index에 따라 각 아이템에 표시될 컨텐츠가 설정될 수 있습니다. 버튼 컨트롤과 유사하게, 리스트 컨트롤 역시 클릭 이벤트를 위한 함수를 가지고 있고, index값을 기반으로 현재 어떤 아이템이 클릭되었는지 판단합니다. static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); } 리스트 컨트롤이 클릭되면, 시스템은 클릭된 위치에 해당하는 아이템의 index값을 계산하여 자동으로 이 함수를 호출합니다. 파라미터 ZKListView *pListView는 List 컨트롤의 포인터이고, 전역 변수 mXXXXPtr와 동일한 객체를 가리킵니다. 파라미터 int index는 전체 리스트 컨트롤에서 현재 클릭된 아이템의 index값 입니다. 파라미터 int id는 현재 클릭된 컨트롤의 ID입니다. 이 ID는 properties에 있는 ID와는 다르니 주의하십시오. 이에 대한 macro definition은 해당하는 Activity.h파일에 있습니다. mainActivity.h를 예로 들면 아래와 같습니다.이 ID 파라미터의 함수는 list item에 여러개의 subitem이 있을 경우 현재 클릭된 subitem이 어떤 것인지를 구분하는데 사용될 수 있습니다.예 : 아래 그림에서 보이는 것처럼, list item에 스위치 이미지가 배치된 2개의 subitem이 추가되었고, 각각의 property ID는 SubItem1과 SubItem2입니다. SubItem1이 클릭되었을 때, 파라미터 id와 ID_MAIN_SubItem1 그리고 ID_MAIN_SubItem2의 관계로 판단될 것이며 어떤 스위치가 클릭되었는지 결정할 수 있습니다. static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); switch(id) { case ID_MAIN_SubItem1: //LOGD(\"Clicked the first subitem of item %d in the list\", index); break; case ID_MAIN_SubItem2: //LOGD(\"Clicked the second subitem of item %d in the list\", index); break; } } 끝으로, 그림을 이용해서 그들 사이의 규칙을 요약해보겠습니다. 다른 컨트롤도 이와 동일합니다. powered by Gitbooklast modified: 2020-12-09 16:42:48 "},"editor_tip.html":{"url":"editor_tip.html","title":"공통 스킬 및 개발 도구","keywords":"","body":"개발 툴을 위한 공통 설정들 관련 함수로 이동 UI 파일에 많은 컨트롤을 추가하면 Logic.cc파일 역시 많은 관련 함수들이 생성되고, 이는 특정 컨트롤과 관련된 함수를 찾고 싶을 경우 많은 시간을 소모할 수 밖에 없습니다. 그러나 다행히 FlywizOS IDE는 빠르게 컨트롤과 관련된 코드를 찾아갈 수 있는 기능을 지원합니다.UI파일의 에디터 화면에서 컨트롤을 선택 후 오른쪽 클릭으로 팝업되는 메뉴 중 Goto relative code를 클릭하면 해당하는 Logic.cc파일의 관련된 함수로 바로 이동합니다. Note : 이 기능은 해당 컨트롤이 자동으로 생성되는 함수를 가지고 있는 경우에만 유효합니다. 폰트 변경 상단 메뉴에서 Window -> Preferences 선택합니다. 팝업 메뉴에서 아래 그림처럼 폰트를 변경 가능합니다. 코드 자동 완성 코딩 시 사용자가 시작 부분을 입력하고 \"Ctrl + Space\" 키를 누르면 코드 자동 완성 기능이 실행됩니다. 아래 그림처럼 UA를 입력 후 \"Ctrl + Space\"키를 누르면 다중 완성 옵션이 팝업되고, 키보드의 업/다운키를 이용하여 원하는 옵션을 선택하고 Enter키를 누르면 코드가 자동으로 완성됩니다. 재-색인 만약 코드 자동 완성 기능이 실패하거나 에디터에서 코드 에러가 보이지만 아무 문제 없이 컴파일이 되는 경우 재-색인 기능을 사용 하십시오. 재-색인을 하는 방법은 아래와 같습니다. powered by Gitbooklast modified: 2020-12-09 11:33:57 "},"ctrl_common.html":{"url":"ctrl_common.html","title":"공통 속성","keywords":"","body":"공통 속성 각각의 컨트롤을 소개하기 전에 컨트롤의 기본적인 공통 속성과 설정 값들을 알아보겠습니다. 컨트롤 ID ID는 컨트롤에 대한 고유 식별자입니다. 각 ftu파일 안에서는 중복된 ID를 허용하지 않습니다. 다른 ftu파일 간에는 동일한 ID를 허용합니다.ID를 설정 후 컴파일하면 ftu파일에 해당하는 activity의 헤더파일이 생성되고, 해당 헤더파일 안에 컨트롤의 ID가 정의됩니다. 컨트롤로부터 ID가져오기 /** * The interface is defined in the control base class \"ZKBase\" * Header file location: include/control/ZKBase.h * * Note: The following interfaces, unless otherwise specified, mean that all controls defined in the ZKBase class directly or * indirectly inherit the ZKBase class, so all controls can call the public interface in the ZKBase class */ int getID() const; /* Operation example: Click the button control to print the ID value of the control */ static bool onButtonClick_Button1(ZKButton *pButton) { int id = pButton->getID(); LOGD(\"onButtonClick_Button1 id %d\\n\", id); return false; } 컨트롤 위치 ftu파일에서 컨트롤을 선택하면 속성 창의 Location을 통해 컨트롤이 표시되는 위치를 결정할 수 있습니다. 왼쪽 상단 모서리의 좌표는 상위 컨트롤의 왼쪽 상단 모서리를 기준으로합니다. 컨트롤의 좌표는 코드를 통해서도 설정하거나 현재 설정된 좌표를 얻어올 수 있습니다. /* Interface description */ // Set location void setPosition(const LayoutPosition &position); // Get location const LayoutPosition& getPosition(); /* Operation esample */ // Click the button control to set the button position static bool onButtonClick_Button1(ZKButton *pButton) { // left：0，top：0，width：100，height：200 LayoutPosition pos(0, 0, 100, 200); pButton->setPosition(pos); return false; } // Click the button control to get the button position static bool onButtonClick_Button2(ZKButton *pButton) { // The mLeft, mTop, mWidth, and mHeight variables of pos correspond to the coordinate values respectively. LayoutPosition pos = pButton->getPosition(); return false; } 배경색 비교적 간단합니다. 색상을 수정하여 효과를 확인하십시오.다음은 배경색을 설정하는 코드입니다. /* When color is -1, the background is set to transparent; other color values are 0xRGB, and the color value does not support alpha */ void setBackgroundColor(int color); /* Operation example : Click the button control and set the background color to red */ static bool onButtonClick_Button1(ZKButton *pButton) { pButton->setBackgroundColor(0xFF0000); return false; } 배경 이미지 이미지를 선택하면 툴에서 바로 확인이 가능합니다. 아래는 코드를 통해 배경 이미지를 설정하는 방법입니다. /** * The pPicPath parameter can have the following two ways : * 1. The absolute path, such as : \"/mnt/extsd/pic/bg.png\" * 2. Relative resource directory path, you only need to put the picture in the resources directory of the project, after * compiling, you can use it. If there is a bg.png picture in the resource directory, just set \"bg.png\". */ void setBackgroundPic(const char *pPicPath); /* Operation example */ mButton1Ptr->setBackgroundPic(\"/mnt/extsd/pic/bg.png\"); // Set the absolute path mButton1Ptr->setBackgroundPic(\"bg.png\"); // Set the bg.png picture in the resource directory 표시 / 숨김 컨트롤의 기본 상태를 표시 또는 숨김으로 설정할 수 있습니다.Outline 창에서 해당 컨트롤을 더블 클릭하는 것으로 이 속성을 변경할 수 있습니다. 추가적으로 코드를 통해서도 표시/숨김의 속성 변경이 가능합니다. void setVisible(BOOL isVisible); BOOL isVisible() const; /* Operation example */ mButton1Ptr->setVisible(TRUE); // Show the button control mButton1Ptr->setVisible(FALSE); // Hide the button control /** * Window controls can also use the following interface, the same function * Header file location : include/window/ZKWindow.h */ void showWnd(); // Show window void hideWnd(); // Hide window bool isWndShow() const; // Whether the window is displayed /* Operation example */ mWindow1Ptr->showWnd(); mWindow1Ptr->hideWnd(); 컨트롤 스테이트 텍스트, 버튼, 리스트 뷰 컨트롤은 5개의 스테이트(Normal/Pressed/Selected/Pressed and Selected /Invalid state)를 가지고 있으며, 아래는 각 스테이트에 대해 설명합니다. Pressed 스테이트는 별도로 코드에서 설정할 필요가 없이 터치를 통해 자동으로 변경됩니다.아래는 Selected와 Invalid스테이트에 대한 운영 예제입니다. // Set selected state void setSelected(BOOL isSelected); BOOL isSelected() const; /* Operation sample */ mButton1Ptr->setSelected(TRUE); mButton1Ptr->setSelected(FALSE); /** * Invalid state function description: when the control is set to the invalid state, the touch control has no effect, that is, * it does not respond to the press and lift event */ // Set invalid state void setInvalid(BOOL isInvalid); BOOL isInvalid() const; /* Operation example */ mButton1Ptr->setInvalid(TRUE); mButton1Ptr->setInvalid(FALSE); 예제 설명 아래의 간단한 예제를 통해 공통 속성과 관련된 함수들에 대해 알아보겠습니다. 1. 컨트롤 생성 먼저 새로운 FlywizOS 프로젝트를 만들고, 프로젝트 탐색기에서 ui폴더의 main.ftu파일을 더블 클릭하여 엽니다. 그리고 우측의 컨트롤 박스에서 버튼 컨트롤과 텍스트 컨트롤을 main.ftu에 드래그하여 컨트롤을 생성합니다. 2. 프로젝트 컴파일 (더 자세한 사항은 \"FlywizOS 프로젝트 컴파일\" 참고하십시오) 3. 컨트롤 속성 함수 호출 컴파일이 끝난 후 프로젝트의 jni/logic/mainLogic.cc을 열면 파일의 하단부에 onButtonClick_Button1함수가 생성된 것을 확인할 수 있습니다. 이 함수에 getID()함수를 호출하여 Button1 버튼 컨트롤의 ID 값을 가져오고 setText()함수를 호출하여 TextView1 텍스트 컨트롤에 표시합니다. (컨트롤ID와 컨트롤 포인터 변수의 관계에 대해 더 자세히 알고 싶다면 여기를 클릭하십시오.) 4. 다운로드 및 디버깅 Project explorer에서 프로젝트 이름을 선택, 오른쪽 클릭 후 팝업 메뉴에서 Download and Debug를 선택하면 프로그램이 보드에 다운로드되고 실행됩니다. 프로그램 실행 후 버튼(Button1컨트롤의 버튼)을 눌러 텍스트 컨트롤에 버튼의 ID인 20001이 표시되는지 확인합니다. Note : 공통 속성의 설정 함수에 대해 더 알고 싶다면, /jni/include/control/ZKBase.h파일을 참고하십시오 powered by Gitbooklast modified: 2020-12-09 11:07:04 "},"textview.html":{"url":"textview.html","title":"Text","keywords":"","body":"Text View 컨트롤 Note 텍스트의 공통 속성을 수정하는 방법을 모르는 경우 《공통 속성》을 참조하세요. 텍스트 / 라벨을 표시해야 합니다. 어떻게 해야합니까? 텍스트를 표시해야하는 경우 기존 Text view로 빠르게 구현할 수 있습니다. 구체적인 단계는 다음과 같습니다. 더블 클릭하여 main.ftu 파일을 엽니다. 오른쪽 컨트롤 박스에서 Text View컨트롤을 찾습니다. Text View 컨트롤에서 마우스 왼쪽 버튼을 클릭 한 다음 원하는 위치로 드래그하고 왼쪽 버튼을 놓으면 자동으로 생성 된 Text View 컨트롤을 볼 수 있습니다. 코드를 통해 텍스트 컨텐츠를 동적으로 업데이트하는 방법 시리얼 포트 LCD를 사용할 때 Text View의 컨텐츠는 종종 동적으로 업데이트됩니다. 코드에서 Text View 컨트롤에 해당하는 포인터를 통해 Text View 컨트롤의 내용을 동적으로 업데이트 할 수 있습니다. 구체적인 단계는 다음과 같습니다. 먼저 코드에서 텍스트 컨트롤에 해당하는 포인터 변수를 알아야합니다 (UI 파일의 컨트롤 ID에 해당하는 컨트롤 포인터 변수의 이름 지정 규칙을 모를 경우 여기를 클릭하십시오), 여기에 ID가 Textview1인 Text View가 있습니다. 이 컨트롤을 예로 들어 보면 해당 컨트롤의 포인터 변수는 mTextview1Ptr입니다. Textview1컨트롤의 텍스트 내용을\"Hello World\"로 수정하려면 텍스트 컨트롤의 멤버 함수void setText(const char * text)를 호출하여 수정 할 수 있습니다. 해당 Logic.cc파일에서 구체적인 코드는 다음과 같습니다.mTextview1Ptr->setText(\"Hello World\"); 실제 사용 예제 : 아래 코드의 기능은 다음과 같습니다 : ID가 Button1인 버튼을 누르면 ID가 Textview1인 Text View의 컨텐츠가 \"Hello World\"로 설정됩니다.static bool onButtonClick_Button1(ZKButton *pButton) { mTextview1Ptr->setText(\"Hello World\"); return false; } 문자열 설정 외에도 Text View컨트롤은 숫자 및 문자 설정도 지원합니다. /* function definition header file: include/control/ZKTextView.h */ void setText(int text); // set number void setText(char text); // set character /* Operation example */ mTextview1Ptr->setText(123); // Textview1 control will display the string \"123\" mTextview1Ptr->setText('c'); // The Textview1 control will display the'c' character 텍스트 색상을 수정하는 방법 기본 텍스트는 흰색으로, 다은 두 가지 방법으로 텍스트 색상을 수정할 수 있습니다. 속성 창에서 직접 컨트롤의 색상을 수정합니다. Project explorer에서 UI 파일을 선택하고 더블 클릭하여 엽니다.미리보기 인터페이스에서 수정할 컨트롤을 찾아 마우스 왼쪽 버튼으로 클릭하면 편집기 오른쪽에서 해당 컨트롤의 속성 창을 볼 수 있습니다. 이때 필요에 따라 속성 값을 입력 할 수 있습니다. Excel과 마찬가지로 수정해야하는 속성을 찾은 다음 마우스로 클릭 후 수정합니다. Text View 컨트롤에서는 색상과 관련된 3개의 속성 항목이 있음을 볼 수 있습니다. Foreground Colors 이 속성은 컨트롤의 각 상태에서 텍스트의 색상 값을 개별적으로 설정할 수 있습니다. Background color 컨트롤의 전체 직사각형 영역의 배경색을 설정합니다(컨트롤 상태에 따라 변경되지 않음). Background colors 배경색 속성의 확장으로 컨트롤의 각 상태에 대한 배경색을 개별적으로 설정할 수 있습니다. 구체적인 예： 미리보기： 위 그림은 속성 창의 색상 부분 스크린 샷으로 의미는 배경색은 검은 색, 텍스트 색상은 흰색으로 설정되어 있습니다. 컨트롤이 선택된 상태로 설정되면 텍스트 색상이 빨간색으로 변경됩니다. 코드를 통한 색상 변경 속성 테이블에서 색상을 설정하는 것은 직관적이고 편리하지만 유연성이 부족하여 이에 대한 보완으로 코드에서 컨트롤의 포인터와 멤버 함수를 통해 색상을 동적으로 변경 할 수 있습니다. ID Textview1의 Text View컨트롤을 예로 들면 다음과 같은 방법으로 색상을 수정할 수 있습니다.(UI 파일의 컨트롤 ID에 해당하는 컨트롤 포인터 변수의 이름 지정 규칙을 모를 경우 여기를 클릭하십시오) void setInvalid(BOOL isInvalid) //Set the control Textview1 to the invalid state; if the `color when invalid` property in the propert table is not empty, //set it to the specified color, otherwise there is no change. mTextview1Ptr->setInvalid(true); void setSelected(BOOL isSelected) //Set the control Textview1 to the selected state; if the `color when selected` property in the property table is not //empty, set it to the specified color, otherwise there is no change. mTextview1Ptr->setSelected(true); void setPressed(BOOL isPressed) //Set the control Textview1 to the pressed state; if the `color when pressed` property in the property sheet is not empty, //set it to the specified color, otherwise there is no change. mTextview1Ptr->setPressed(true); void setTextColor(int color) //The parameter color represents RGB color in hexadecimal. //Set the control Textview1 to red. mTextview1Ptr->setTextColor(0xFF0000); 소수를 표시하는 방법 Text View컨트롤은 문자열 설정을 위한 인터페이스를 제공합니다. /** * @brief Set string text */ void setText(const char *text); 숫자를 표시하려면 먼저 'snprintf'함수를 사용하여 숫자를 문자열로 포맷 한 다음 Text View컨트롤에 설정할 수 있습니다.예 : float n = 3.1415; char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%.3f\", n); //Fixed display 3 decimal places, extra decimal places will be ignored, if not enough, //0 will be added mTextView1Ptr->setText(buf); snprintf는 C 언어 표준 함수로 인터넷에서 관련 정보를 검색하거나 여기 간단한 소개 및 사용 예에서 확인할 수 있습니다. 애니메이션 구현 Text View 컨트롤은 배경 이미지를 추가 할 수 있으므로 단순히 이미지 표시하는 데에도 사용할 수 있습니다. 또한 한 단계 더 나아가 코드에서 Text View컨트롤의 배경 이미지를 동적으로 전환하고 전환 시간 간격을 충분히 짧게 한다면 애니메이션 효과를 얻을 수도 있습니다. 이미지 자료 준비부드러운 프레임 애니메이션에는 반드시 여러 이미지가 필요합니다. 여기에서는 총 60개를 준비했습니다. 각 이미지는 프레임을 나타내며 일련 번호에 따라 이름이 균일하게 지정되어 연속적으로 사용하기 용이하게 되어 있음을 알 수 있습니다. Note: 시스템은 이미지를 로드 할 때 더 많은 리소스를 소비하므로 액티비티를 원활하게 실행하려면 사진이 너무 크지 않도록 하는 것이 좋습니다. 예를 들어, 예제에서 하나의 이미지의 크기는 약 5KB 입니다. 이 이미지를 프로젝트의 resources폴더에 복사합니다. resources폴더 아래에 하위 폴더를 만들어 다양한 이미지 리소스를 쉽게 구성하고 분류 할 수 있습니다. Text View 컨트롤 만들기UI파일에서 임의의 Text View컨트롤을 만듭니다. 그리고 Text View컨트롤의 배경 이미지를 이미지 중 하나로 설정합니다. 여기서는 첫 번째 이미지를 배경 이미지로 설정했습니다. 이 단계는 Text View컨트롤의 width와 height를 이미지의 width와 height에 맞게 조정하는 것입니다. 설정하지 않도록 선택할 수도 있습니다.아래는 전체 속성입니다. 프로젝트 컴파일, 타이머 등록Text View 컨트롤을 추가 한 후 프로젝트를 다시 컴파일하고 생성 된 Logic.cc 파일에 타이머를 등록하고 시간 간격을 50ms로 설정합니다. 타이머를 사용하여 50ms마다 이미지를 전환합니다.프로젝트 컴파일 방법타이머 등록 방법 Text View 컨트롤의 배경을 동적으로 전환해당 Logic.cc파일에 다음 함수를 추가하여 배경 이미지를 전환하고 타이머 트리거 함수 bool onUI_Timer(int id)에서 호출합니다. static void updateAnimation(){ static int animationIndex = 0; char path[50] = {0}; snprintf(path, sizeof(path), \"animation/loading_%d.png\", animationIndex); mTextviewAnimationPtr->setBackgroundPic(path); animationIndex = ++animationIndex % 60; } 위의 기능에는 주의해야 할 두 가지 사항이 있습니다. 텍스트 컨트롤의 배경 이미지 전환은 setBackgroundPic(char * path)함수로 구현됩니다. setBackgroundPic(char * path)함수의 파라미터는 그림의 상대 경로입니다. 경로는 프로젝트의 resources폴더에 상대적입니다. 예 : 아래 그림과 같이 프로젝트의 resources/animation/폴더에 이미지가 배치되는 경우 이 loading_0.png의 상대 경로는animation/loading_0.png입니다. setBackgroundPic(char * path)함수는 절대 경로를 허용 할 수도 있습니다. 예 : 이미지 example.png를 TF카드의 루트 디렉토리에 넣는 경우 해당 절대 경로는 /mnt/extsd/example.png이며 여기서/mnt/extsd/는 TF카드의 경로입니다. 다른 경로의 이미지 리소스는 소프트웨어에 자동으로 패키징되지 않으므로 모든 이미지 리소스는 프로젝트의 resoources폴더 또는 하위 폴더에 배치하는 것이 좋습니다. 다운로드 및 실행하여 결과를 확인해 봅시다. 이미지 문자 세트 사용 ascii 코드의 정의에 따르면 character char와 integer int사이에는 상관 관계가 있습니다. 예를 들어 문자 '0'의 ascii 코드는 '48'입니다. 이미지 문자 집합은 ascii 코드를 이미지에 매핑하는 기능입니다. 이 기능을 설정 한 후 문자열을 표시 할 때 시스템은 문자열의 각 문자를 지정된 이미지에 매핑하고 마지막으로 화면에 이미지 문자열을 표시합니다. 설정 방법 Text View컨트롤에서 Picture Character Set을 찾아 오른쪽의 more옵션을 클릭하면 이미지 문자 집합 선택 상자가 나타납니다. 오른쪽 상단의 Import버튼을 선택하여 이미지를 문자 집합에 추가합니다. 이미지를 추가 한 후 해당 ascii 코드 또는 문자를 이미지의 매핑 문자로 수정할 수 있습니다. 그런 다음 Save를 클릭합니다. 이미지 문자 집합이 성공적으로 추가되었는지 확인하기 위해 텍스트를 수정하면 미리보기에서 그 효과를 확인할 수 있습니다. 참고 : 이미지 문자 집합을 설정하면 시스템이 각 문자를 문자 집합에 지정된 이미지에 매핑하려고 시도합니다. 문자가 이미지에 설정되지 않은 경우 이 문자는 화면에 표시되지 않습니다. 사용법 위의 이미지 문자 집합 설정 상자에서 우리는 문자 0-9와 : 콜론을 각각 이미지에 매핑했습니다. 그런 다음 코드에서 setText(char * str)함수를 통해 문자열을 설정합니다. TextTime Text View컨트롤에서 이미지 문자 집합을 설정했으므로 문자는 해당 이미지로 변환됩니다. static void updateTime() { char timeStr[20]; struct tm *t = TimeHelper::getDateTime() sprintf(timeStr, \"%02d:%02\", t->tm_hour, t->tm_min); mTextTimePtr->setText(timeStr); } 단일 문자 만 표시해야하는 경우 ascii 코드 또는 문자를 문자열로 변환하지 않고 직접 설정할 수 있습니다.예 : mTextTimePtr->setText((char)48); //Set the ascii code directly, it needs to be //converted to char mTextTimePtr->setText('0'); //Set character directly Sample code 더 자세한 내용은 Sample code의 TextViewDemo프로젝트를 참고하십시오. 미리보기 : powered by Gitbooklast modified: 2020-12-10 16:21:56 "},"button.html":{"url":"button.html","title":"Button","keywords":"","body":"Button 버튼 추가 및 속성 변경 프로젝트 창에서 버튼을 추가하고자 하는 액티비티의 UI을 더블 클릭합니다. 우측의 컨트롤 박스에서 Button 컨트롤을 선택합니다. Button컨트롤을 왼쪽 클릭 후 원하는 위치에 클릭하거나 드래그 앤 드롭하면 컨트롤이 만들어집니다. 만들어진 버튼을 왼쪽 클릭하면 속성 창에서 해당 버튼과 관련된 속성들을 확인하고, 변경할 수 있습니다. 버튼 색 변경 \"텍스트 및 색상 변경\"을 참고하십시오. 버튼에 에니메이션 효과 추가 \"버튼 상태에 따른 이미지 추가\"를 참고하십시오. 버튼 상태에 따른 이미지 추가 기본 버튼 컨트롤의 색은 단색이지만, 사용자가 원하는 이미지 등을 추가할 수 있으며, 아래는 그 방법입니다. 먼저 UI파일에 버튼을 추가합니다. 추가된 버튼을 왼쪽 클릭하여 속성 창을 불러옵니다. 속성에서 이미지와 관련한 속성은 아래와 같습니다. Picture settings 버튼의 각 상태에 따른 이미지를 설정할 수 있고, 버튼의 상태가 바뀌면 자동으로 해당 이미지로 변경됩니다. Picture location 기본적으로 버튼에 설정된 이미지는 버튼의 중앙을 기준으로 확대/축소되어 버튼과 같은 크기로 변경되는데, 이 속성은 이미지를 버튼의 특정 위치에 특정 크기로 위치시킬 수 있습니다. Background picture 버튼의 배경 이미지를 설정합니다. 이미지는 자동으로 버튼의 크기만큼 확대/축소되어 표시됩니다. 예제： 결과 이미지 : 위의 스크린샷은 속성 창의 파라미터 값을 보여주며, 그것의 의미는 다음과 같습니다.버튼은 기본적으로 \"off_normal.png\"를 표시하고, 선택되었을 때 \"on_normal.png\"로 변경됩니다.left, top, width, height는 이미지의 표시 위치(픽셀 단위)를 결정합니다. 사각형의 왼쪽 위 모서리가 시작 점(0, 0)이고, 오른쪽/아래쪽 방향으로 값이 증가하고, (131, 63)이 종료 점입니다. 만약 이미지의 실제 width와 height가 속성 창의 파라미터 값과 다르다면 이미지는 해당 속성 값에 따라 확대/축소됩니다. 버튼 컨트롤 간의 계층 관계 일반적으로 버튼 컨트롤은 4단계의 과정을 거쳐 디스플레이 됩니다. 버튼의 텍스트 버튼의 이미지 버튼의 배경 이미지 버튼의 배경 색 버튼에 이미지 추가 \"버튼 상태에 따른 이미지 추가\"를 참고하십시오. 버튼이 눌렸을 때, 어디에, 어떻게 코드를 추가하나요? 실제 개발에서 버튼은 매우 자주 사용되는 컨트롤 중 하나입니다. 보통 버튼 클릭 이벤트 발생 후 UI 화면의 내용이 갱신되는 등의 과정이 수행됩니다. 이를 위해 버튼이 클릭되었을 때 응답을 처리하는 과정이 필요하며, 아래는 그 과정입니다. 먼저 ID가 Button1인 버튼을 만듭니다. 프로젝트 탐색기에서 현재 프로젝트를 선택하고 마우스 오른쪽을 클릭하여 보여지는 팝업 메뉴 중 Compile FlyThings를 선택합니다. 이 기능은 UI파일을 기반하여 자동으로 템플릿코드를 생성합니다.(코드 생성에 대한 자세한 이해) UI 파일 main.ftu을 예로 들면, 이전 과정이 끝난 후 jni/logic/mainLogic.cc 파일이 현재 프로젝트 폴더에 아래와 같이 생성됩니다. Note : main.ftu 로 자동 생성된 mainLogic.cc, 두 파일의 prefixes는 동일합니다.(코드 생성에 대한 자세한 이해) mainLogic.cc을 더블 클릭하여 열면, 파일에 아래의 코드가 있는 것을 확인할 수 있습니다. static bool onButtonClick_Button1(ZKButton *pButton) { //LOGD(\" ButtonClick Button1 !!!\\n\"); return false; } 스크린에서 생성된 버튼을 클릭하면 자동으로 위 함수가 호출됩니다. 그러므로 이 함수에 코드를 추가하는 것으로 사용자는 자신만의 프로세스를 추가할 수 있습니다. 함수의 이름은 특정한 규칙에 의거하여 생성되는 것을 확인할 수 있고, 위의 예제에서처럼 생성된 함수의 이름은 onButtonClick_XXXX(ZKButton *pButton)로 여기서 XXXX는 해당 컨트롤의 ID로 대체됩니다. (컨트롤과 함수의 관계에 대한 이해) 시스템 버튼 사용자가 정한 ID이외에 버튼 컨트롤은 2개의 시스템 버튼 ID를 가지고 있는데, sys_back과 sys_home이 바로 그것입니다. 이름으로부터 대략적으로 그 기능을 알 수 있듯이 뒤로 와 홈 기능을 위한 ID입니다. sys_back버튼을 클릭하면 직전 액티비티로 돌아가고, sys_home을 클릭하면 \"mainActivity\"로 바로 돌아가며, 특별한 추가 구현 없이 ID의 값만 해당 시스템 아이디로 설정하는 것으로 기능을 구현할 수 있습니다. 액티비티간의 상호 작용에 대한 이해 Long key 이벤트 처리 만약 long key 이베트를 처리할 필요가 있다면 직접 해당 이벤트 리스너를 추가해야 합니다. 아래는 그 과정입니다. 버튼 컨트롤의 속성 창에서 Long Click Timeout과 Long Click event trigger interval time을 다음 그림과 같이 설정합니다.(단위 : 밀리세컨드) 속성 설정 후 컴파일을 하고 해당 파일의 Logic.cc파일을 열어 파일의 시작 부분에 ZKBase::ILongClickListener 클래스를 상속받는 class LongClickListener와 virtual void onLongClick(ZKBase *pBase) 함수를 구현합니다. namespace { // Add an anonymous scope to prevent multiple source files from defining the same class // name and conflict at runtime // Realize the long press monitoring interface class LongClickListener : public ZKBase::ILongClickListener { virtual void onLongClick(ZKBase *pBase) { LOGD(\"Trigger long press event\"); static int count = 0; char buf[128] = {0}; snprintf(buf, sizeof(buf), \"Long press event trigger times %d\", ++count); //Each time a long press event is triggered, modify the text of the button mLongButtonPtr->setText(buf); } }; } class LongClickListener의 오브젝트 생성 static LongClickListener longButtonClickListener; static void onUI_init()함수에서 long click 모니터링 인터페이스를 등록하는 함수를 추가 static void onUI_init(){ //Register the button long press monitoring interface mLongButtonPtr->setLongClickListener(&longButtonClickListener); } static void onUI_quit() 함수에 long click 모니터링 인터페이스를 등록을 해제하는 함수를 추가 static void onUI_quit() { //Un-register the button long press monitoring interface mLongButtonPtr->setLongClickListener(NULL); } 코드 추가 후 컴파일, 다운로드하여 보드에서 테스트하십시오. 만약 버튼의 텍스트가 변경되었다면 onLongClick함수가 성공적으로 동작하였음을 의미합니다. 버튼 터치 이벤트 처리 만약 버튼 컨트롤에 press 또는 lift 이벤트에 대한 응답이 필요하다면 터치 모니터링 인터페이스를 등록하여 구현할 수 있습니다. 아래는 예제 코드입니다. 사용자만의 터치 모니터링 인터페이스 구현 namespace { // Add an anonymous scope to prevent multiple source files from defining the same class name // and conflict at runtime // Implement touch monitoring interface class TouchListener : public ZKBase::ITouchListener { public: virtual void onTouchEvent(ZKBase *pBase, const MotionEvent &ev) { switch (ev.mActionStatus) { case MotionEvent::E_ACTION_DOWN: mTouchButtonPtr->setText(\"Press\"); break; case MotionEvent::E_ACTION_UP: mTouchButtonPtr->setText(\"Lift\"); break; default: break; } } }; } 리스너 오브젝트 생성 static TouchListener sTouchListener; static void onUI_init() 함수에 터치 모니터링 인터페이스 등록 코드 추가 static void onUI_init() { //Register the button touch monitoring interface mTouchButtonPtr->setTouchListener(&sTouchListener); } static void onUI_quit() 함수에 터치 모니터링 인터페이스 등록 해제 코드 추가 static void onUI_quit() { //Un-register the button touch monitoring interface mTouchButtonPtr->setTouchListener(NULL); } 코드 추가 후 컴파일, 다운로드하여 보드에서 테스트하십시오. 예제 코드 예제 코드의 ButtonDemo 프로젝트를 참고하십시오 프리뷰 화면 : powered by Gitbooklast modified: 2020-12-09 10:02:11 "},"checkbox.html":{"url":"checkbox.html","title":"Checkbox","keywords":"","body":"체크박스 체크박스 컨트롤의 기본은 버튼 컨트롤입니다. 만약 스위치 버튼이나 체크박스 버튼과 같이 클릭 시 버튼의 상태가 변화되고, 클릭을 해제해도 이를 유지할 필요가 있다면 체크박스 컨트롤을 이용하여 더 쉽게 구현 가능합니다. 사용법 프로젝트 창에서 체크박스를 추가하고자 하는 액티비티의 UI을 더블 클릭합니다. 오른쪽의 컨트롤 박스에서 Checkbox 컨트롤을 선택합니다. Checkbox컨트롤을 마우스 왼쪽 클릭 후 드래그하여 버튼을 만들 위치에 놓으면, 자동으로 컨트롤이 만들어집니다. 만들어진 버튼을 마우스 왼쪽 클릭하면 속성 창에서 해당 버튼과 관련된 속성들을 확인하고, 변경할 수 있습니다.버튼 컨트롤과 마찬가지로 이미지의 크기는 기본적으로 체크박스 컨트롤 크기를 따라가며, 필요한 경우 위치와 크기를 속성에서 조정 가능합니다. 속성 설정 후 컴파일하면 해당하는 Logic.cc 파일에 관련된 함수가 생성됩니다. 그리고, 해당 컨트롤을 클릭 시 시스템에서 관련된 함수를 자동으로 호출합니다. 해당 함수의 파라미터 중 bool isChecked는 컨트롤의 선택 상태를 나타냅니다. static void onCheckedChanged_Checkbox1(ZKCheckBox* pCheckBox, bool isChecked) { if (isChecked) { //Check box is selected LOGD(\"checked\"); } else { //Checkbox is unselected LOGD(\"unchecked\"); } } 실제 보드에 다운로드 후 테스트해 보십시오. 예제 코드 Sample code의 CheckBoxDemo 프로젝트를 참고하십시오.예제 코드 실행 결과 프리뷰 : powered by Gitbooklast modified: 2020-12-09 10:18:30 "},"radiogroup.html":{"url":"radiogroup.html","title":"RadioGroup","keywords":"","body":"RadioGroup 여러 옵션 중 단일 선택이 필요한 UI의 경우 RadioGroup컨트롤을 직접 사용할 수 있습니다. 옵션 중 하나를 클릭하면 옵션이 자동으로 선택된 상태로 전환되고 동일한 그룹의 다른 옵션은 선택되지 않은 상태가 됩니다. 이러한 옵션의 상태를 전환하는 동안 그림과 색상도 속성 창의 설정에 따라 자동으로 전환됩니다. 사용법 더블 클릭하여 UI 파일을 엽니다. 우측의 컨트롤 박스에서 RadioGroup 컨트롤을 찾습니다. RadioGroup컨트롤에서 마우스 왼쪽 버튼을 클릭 한 상태에서 원하는 위치로 드래그 한 후 왼쪽 버튼을 놓으면 자동으로 직사각형 영역이 생성되는 것을 볼 수 있고, 그 역역은 RadioButton컨트롤을 보유 할 수있는 컨테이너를 나타냅니다. 동일한 드래그 앤 드롭 방법을 사용하여 지금 바로 직사각형 영역에 여러 RadioButton컨트롤을 추가 할 수 있습니다. 추가 된 RadioButton컨트롤을 마우스 왼쪽 버튼으로 클릭하면 우측에서 관련 속성을 볼 수 있습니다. 필요에 따라 각 컨트롤의 각 상태에 따른 그림과 색상을 설정할 수 있습니다. 여기서 Picture and Background Colors속성에 주의하십시오. 그림을 설정 한 후 그림의 크기가 비정상적으로 표시되는 경우 Picture Location속성에서 그림의 위치와 크기를 조정할 수 있습니다. Default State속성에서 Checked또는 Unchecked을 설정할 수도 있습니다. 속성 설정 후 컴파일하면 해당하는 Logic.cc에 관련 함수가 생성됩니다. RadioButton 중 하나를 클릭하면 시스템에서 관련 함수를 호출합니다. 여기서 int checkedID매개 변수는 선택한 RadioButton의 'ID'를 나타내고, 이 ID 값을 기반으로 현재 클릭 된 RadioButton을 확인할 수 있습니다.이 'ID'는 매크로 정의 정수 값입니다. UI파일이 컴파일 된 후 각 컨트롤은 해당 매크로 ID를 자동으로 생성합니다(매크로에 대한 자세한 내용은 이름 지정 규칙을 확인하십시오). 각 옵션의 매크로 ID는 해당Activity.h 헤더 파일에서 찾을 수 있습니다.예 : 그런 다음 관련 함수에서 클릭된 항목이 무엇인지 판단 할 수 있습니다. static void onCheckedChanged_RadioGroup1(ZKRadioGroup* pRadioGroup, int checkedID) { LOGD(\"Checked ID = %d\", checkedID); switch (checkedID) { case ID_MAIN_RadioButton1: LOGD(\"First RadioButton\"); break; case ID_MAIN_RadioButton2: LOGD(\"Second RadioButton\"); break; case ID_MAIN_RadioButton3: LOGD(\"Third RadioButton\"); break; default: break; } } 다운로드 및 디버그하여 효과를 확인합니다. Sample code Sample Code의 RadioGroupDemo 프로젝트를 참고하십시오. 예제 미리보기 : powered by Gitbooklast modified: 2020-12-10 10:06:25 "},"seekbar.html":{"url":"seekbar.html","title":"Seek Bar","keywords":"","body":"Seek Bar 컨트롤 Seek Bar 컨트롤 사용법 많은 어플리케이션에서 Seek Bar을 사용합니다. 예를 들면 다음과 같습니다.Volume 조정 몇 가지 간단한 그림을 사용하여 이 효과를 빠르게 얻을 수 있습니다. 먼저 4개의 리소스 이미지를 준비합니다. Background picture Valid picture Thumb - normal picture Thumb - pressed picture 편집기에서 Seek Bar 컨트롤을 만듭니다. 컨트롤을 만드는 방법을 모르는 경우 Button 컨트롤 만들기 참조 하십시오. 기본 Seek Bar 스타일은 투명하며 정상적으로 동작하려면 이미지 리소스를 추가해야 합니다. 속성 창에서 Valid Picture, Thumb-Normal Picture, Thumb-Pressed Picture, Background Picture 이미지를 설정합니다. 위 단계가 완료되면 기본적으로 Seek Bar생성이 완료됩니다. IDE에서 Seek Bar의 슬라이딩 효과를 미리 보려면 Max Value속성 및 Default Progress속성을 수정하십시오. 미리보기에서 슬라이더 커서의 위치 변경을 확인할 수 있습니다. 코드에서 Seek Bar의 프로그래스를 제어하는 방법은 무엇입니까? Seek Bar의 현재 프로그래스 값을 확인하는 방법은 무엇입니까? Seek Bar를 사용하여 Volume Bar를 구현하는 경우 현재 Volume Bar의 프로그래스 값을 알아야하며 Volume Bar가 변경되면 동시에 볼륨도 조정해야 합니다. 따라서 이러한 문제를 해결하기 위해 다음과 같은 3가지 함수가 있습니다. static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress)프로그래스 값 변경 모니터링 함수UI 파일에 Seek Bar컨트롤을 생성한 후 컴파일 하면 이 함수가 해당 XXXXLogic.cc파일에 자동으로 추가됩니다. 터치 스크린에서 Seek Bar를 조작하거나 프로그래스의 현재 값이 변경되면 시스템이 이 함수를 자동으로 호출합니다.static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress) { //LOGD(\"XXXXThe progress value of the seek bar changes to %d !\\n\", progress); } void setProgress(int progress)Seek Bar의 현재 프로그래스 값을 설정하는 데 사용됩니다.예 ://Set the seek bar progress to 28 mSeekbarPtr->setProgress(28) int getProgress()현재 Seek Bar의 프로그래스 값을 가져 오는 데 사용됩니다.예 :int progress = mSeekbarPtr->getProgress(); LOGD(\"The current progress value of the seek bar %s\", progress); 예제 더 자세한 내용은 Sample Code의 SeekBarDemo 프로젝트를 참고하십시오. 예제 미리보기 : powered by Gitbooklast modified: 2020-12-10 14:07:53 "},"pointer.html":{"url":"pointer.html","title":"Pointer","keywords":"","body":"Pointer control 특징 미터기 또는 시계의 회전과 유사한 효과를 얻으려면 이 컨트롤로 쉽게 구현 할 수 있습니다. 이 컨트롤은 그래픽 회전을 처리하도록 특별히 설계되었습니다. 아이디어 미터기는 다이얼로 사용하는 정적 배경 이미지와 배경 이미지에서 회전하는 포인터 이미지의 두 부분으로 나눌 수 있습니다. 따라서 배경 이미지와 포인터 이미지를 선택한 후 포인터 회전의 중심 좌표만 결정하면 됩니다. 사용법 먼저 Pointer컨트롤을 만들면, 아래 속성들을 확인할 수 있습니다. 여전히 컨트롤 생성 방법을 모르는 경우 버튼 컨트롤 생성 방법을 참조하세요. 속성 창에서 Pointer Picture와 Background Picture를 추가 한 것을 볼 수 있습니다. 추가 프로세스는 애니메이션에 표시됩니다. 위의 마지막 미리보기 이미지로 판단하면 문제가 발견되지 않았으며, 배경 이미지와 포인터 위치가 정상적인 것처럼 보입니다. 그러나 프로그램이 실제로 실행된 후에는 포인터가 잘못된 것을 확인할 수 있습니다. 이를 수정하기 위해 Starting Angle속성을 120으로 조정합니다. 그러나 포인터가 120°회전한 후에도 결과가 예상과 다르다는 것을 알 수 있습니다. 그 이유는 포인터가 회전하는 원의 중심 좌표가 올바르지 않기 때문입니다. 포인터 회전 중심의 좌표를 결정하는 두 가지 속성은 Rotation point와 Fixed point입니다. Rotation point좌표는 컨트롤의 전체 사각형 영역을 참조합니다. 컨트롤의 사각형 영역의 왼쪽 위 모서리는 [0,0] (픽셀 단위)입니다. 이러한 미터기의 경우 원하는 회전 점의 좌표는 분명히 다이얼의 중앙에 있습니다. 그러면 해당 그림의 특정 좌표는 아래와 같이 (250, 250)입니다. Fixed point좌표는 포인터 그림을 참조하고 그림의 왼쪽 위 모서리는 [0,0]으로 단위는 픽셀입니다. 사용된 포인터 그림의 경우 원하는 포인터의 고정 점 좌표는 (30, 210)입니다. 두 좌표를 속성 창에 입력하면 포인터가 올바른 위치로 회전하는 것을 볼 수 있습니다. Starting angle은 음수를 지원합니다. 위의 예에서 Starting angle을 -120으로 변경하면 포인터가 다이얼 0 위치를 가리 킵니다. 포인터 Fixed Point에 대한 팁 위의 예에서 포인터의 Fixed Point 좌표는 포인터 그림에 위치하며 실제로이 좌표는 커서 효과를 얻기 위해 그림의 범위를 초과 할 수도 있습니다. 아래 그림과 같이 빨간색 상자의 흰색은 실제로 포인터 그림으로 상대적으로 작지만 오른쪽 속성에서는 그림의 실제 크기를 훨씬 넘는 포인터 고정 점 좌표를 설정 한 다음 회전 좌표를 조정하여 원형 커서의 효과을 얻습니다. 조작 함수 이러한 유형의 컨트롤의 조작을 위한 가장 일반적인 방법은 코드를 통해 포인터의 회전 각도를 조정하는 것입니다. //Adjust the pointer to 90 degrees mPointer1Ptr->setTargetAngle(90.0); Sample code Sample Code의 PointerDemo 프로젝트를 참고하십시오. powered by Gitbooklast modified: 2020-12-10 09:37:16 "},"listview.html":{"url":"listview.html","title":"List","keywords":"","body":"List control 기능 리스트 컨트롤은 한 페이지에 모든 정보를 표시할 수 없을 경우 그리고 어떤 정보들이 일정한 속성으로 분류될 필요가 있을 때 자주 사용됩니다. 예 WiFi 리스트, device 리스트, table 정보 등 사용법 UI파일을 열어 List View컨트롤을 만듭니다. 그리고, 2개의 List Subitem컨트롤을 추가합니다.아래는 동영상 예제입니다. 만들어진 리스트를 선택하면 아래와 같이 속성을 확인할 수 있습니다. 각각의 속성을 수정해보고 보드에 다운로드하여 어떻게 변하는지 확인해 볼 수 있습니다. 이제 Outline을 살펴보겠습니다. 먼저 List1을 보면 리스트의 행과 열을 나타내는 Item노드가 기본적으로 포함되고, 여기에는 추가했던 ListSub노드 2개가 포함된 것을 확인할 수 있습니다.여기서 각 아이템 노드들을 클릭하면 속성 창에서 관련된 속성들과 그 속성이 영향을 미치는 범위를 에디터 영역의 프리뷰에서 확인 할 수 있습니다.Note : 각 List View 컨트롤은 최대 32개의 List item을 가질 수 있습니다. Item과 List Subitem컨트롤은 Button컨트롤과 유사한 속성들을 가지고 있습니다. 개발자는 원하는 스타일에 맞게 해당 속성들을 수정할 수 있습니다. 아래는 예제를 이용해 수정한 결과입니다 : UI파일에서 리스트의 전반적인 속성을 조정하여 표시되는 모양을 확인한 후 컴파일 하십시오(FlywizOS 프로젝트 컴파일). 그 후 자동으로 생성되는 상관 함수에 필요한 기능들을 추가 하십시오. 컴파일이 끝나면 해당하는 Logic.cc파일에 각 리스트 컨트롤과 관련된 3가지 함수가 생성될 것입니다. int getListItemCount_ListView1()： 그려질 리스트 컨트롤의 아이템 수예 : 100개의 아이템을 디스플레이 한다면, 100이 리턴됩니다. void obtainListItemData_List1： 리스트의 각 아이템에 표시될 컨텐츠를 설정위 두 함수는 리스트의 컨텐츠를 공동으로 제어합니다. onListItemClick_List1： 리스트 컨트롤 클릭 이벤트 함수 리스트 상의 아이템을 클릭 시 시스템은 이 함수를 호출합니다. 그리고 파라미터로 현재 클릭된 리스트 아이템의 인덱스를 전달합니다. List drawing 과정 리스트를 그리기를 원할 때, 시스템은 먼저 리스트에 총 몇 개의 아이템이 있는지 알 필요가 있고, 이를 위해 제공된 int getListItemCount_ListView1()함수를 통해 총 아이템 수를 획득하며, 그 수는 동적으로 획득 가능합니다. 따라서 프로그램이 동작하는 중, 필요에 따라 다른 값을 리턴함으로 리스트의 아이템 수를 동적으로 조정할 수 있습니다. 그 후, 시스템은int getListItemCount_ListView1()로 리턴된 수 만큼 void obtainListItemData_ListView1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index)함수를 호출하고, 호출 시 파라미터로 전달되는 포인터를 이용하여 각 아이템의 컨텐츠를 설정할 수 있습니다. Example 1. 리스트 아이템에 표시할 컨텐츠 설정 static void obtainListItemData_ListView1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { //The pListItem pointer represents a list item, which can only be used in this function char buf[32] = {0}; //The parameter index indicates which item of the list is currently drawn, starting from 0. //Here, we format the index value into a string snprintf(buf, sizeof(buf), \"Item %d\", index); //Display the string as text in the list item area pListItem->setText(buf); //If you have configured the list item \"Picture when selected\" in the ui file, //Then, by setting the selected state of the list item through the following line of code, you can control the list item to //display the corresponding state picture pListItem->setSelected(true); } Example 2. 리스트 서브 아이템에 표시할 컨텐츠 설정만약 리스트 서브 아이템을 사용한다면 아래 방법처럼 리스트 아이템 컨트롤 포인터로부터 서브 아이템의 컨트롤 포인터를 획득해서 조정할 수 있습니다. static void obtainListItemData_ListView1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { char buf[32] = {0}; //The parameter index indicates which item of the list is currently drawn, starting from 0. //Here, we format the index value into a string snprintf(buf, sizeof(buf), \"The first child of item %d\", index); //We can get the pointer of the list item through the findSubItemByID() function and the ID of the list item //Same as the pListItem pointer, the list item pointer that is found can only be used in this function ZKListView::ZKListSubItem* subitem1 = pListItem->findSubItemByID(ID_MAIN_SubItem1); if (subitem1 != NULL) { //Set the text of list item 1 subitem1->setText(buf); } snprintf(buf, sizeof(buf), \"The second child of item %d\", index); ZKListView::ZKListSubItem* subitem2 = pListItem->findSubItemByID(ID_MAIN_SubItem2); if (subitem2 != NULL) { //Set the text of list item 2 subitem2->setText(buf); } } 리스트의 수정 FlywizOS 시스템에서 리스트는 일련의 규칙적인 데이터의 매핑입니다. 만약 데이터를 추가하거나 특정 아이템을 수정하는 것처럼 리스트를 수정하기 원한다면 먼저 데이터를 수정하고 리스트를 갱신해야 합니다. 그러면 시스템은 자동적으로 obtainListItemData_ListView1함수를 호출하고, 이 함수로 최종적으로 수정된 데이터에 따라 리스트를 갱신합니다.이러한 과정은 아래 예제에 반영되어 있습니다. 예제 코드 예제 코드의 ListViewDemo 프로젝트를 참고하십시오. 예제 설명 List View 컨트롤을 생성서로 다른 속성을 가지는 2개의 List View 컨트롤을 만듭니다.Cycle List control : Cycle 속성을 on 합니다. 프로젝트 컴파일이 단계는 Logic.cc 파일에 자동으로 List View컨트롤과 관련된 함수를 생성합니다.\"FlywizOS 프로젝트 컴파일\"을 참고하십시오. List1 리스트 생성에 필요한 데이터 구조체 설정일반적으로 리스트의 각 아이템을 위한 모델로 구조체를 정의합니다. typedef struct { //The text displayed in the list item const char* mainText; //The text to be displayed in list sub item 1 const char* subText; //Turn on/off logo bool bOn; } S_TEST_DATA; 가상의 리스트 데이터를 위한 구조체 배열을 정의합니다. static S_TEST_DATA sDataTestTab[] = { { \"Test1\", \"testsub1\", false }, { \"Test2\", \"testsub2\", false }, { \"Test3\", \"testsub3\", false }, { \"Test4\", \"testsub4\", true }, { \"Test5\", \"testsub5\", false }, { \"Test6\", \"testsub6\", true }, { \"Test7\", \"testsub7\", false }, { \"Test8\", \"testsub8\", false }, { \"Test9\", \"testsub9\", false }, { \"Test10\", \"testsub10\", false }, { \"Test11\", \"testsub11\", false } }; 자동으로 생성된 리스트 관련 함수에 코드를 추가합니다. static int getListItemCount_List1(const ZKListView *pListView) { //Use the length of the array as the length of the list return sizeof(sDataTestTab) / sizeof(S_TEST_DATA); } static void obtainListItemData_List1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { //Get the pointer of the list sub item 1 and name it psubText ZKListView::ZKListSubItem* psubText = pListItem->findSubItemByID(ID_MAIN_ListSub1); //Get the pointer of the list sub item 2 and name it psubButton ZKListView::ZKListSubItem* psubButton = pListItem->findSubItemByID(ID_MAIN_ListSub2); pListItem->setText(sDataTestTab[index].mainText); //Take index as the subscript, get the corresponding structure from the array, get the text that needs to be displayed //from the structure, and finally set it to the corresponding list item psubText->setText(sDataTestTab[index].subText); //In the UI file, we set the selected image property for the list sub item 2 //Here, according to the `bOn` value of the structure, the selected state of the list item is set, so that if the member //`bOn` is true, it is set to be selected, and the system will automatically display the selected picture previously set psubButton->setSelected(sDataTestTab[index].bOn); } static void onListItemClick_List1(ZKListView *pListView, int index, int id) { //When you click the index item in the list, modify the bOn variable to reverse bOn. In this way, every time you click on //the list, the picture will switch once //Note that the operation of picture switching is completed in the obtainListItemData_List1 function, and now we only //modify the value of this variable. sDataTestTab[index].bOn = !sDataTestTab[index].bOn; //The last sentence of code modified the structure data, and now we want to refresh the list immediately, and call //refreshListView to force a refresh //After the refresh is triggered, the system will call the two functions getListItemCount_List1 and //obtainListItemData_List1 again, so that the modified data corresponds to the list display. mList1Ptr->refreshListView(); } 코드 추가가 완료되면 다운로드하여 실행 후 결과를 확인합니다. powered by Gitbooklast modified: 2020-12-09 15:16:12 "},"diagram.html":{"url":"diagram.html","title":"Diagram","keywords":"","body":"다이어그램 이 컨트롤을 사용하여 쉽게 곡선 또는 직선 다이어그램을 그릴 수 있습니다. 사용법 먼저 UI파일에 다이어그램이 위치할 영역을 정한 후 Diagram컨트롤을 만들고, Waveform컨트롤을 추가하면 대략적인 다이어그램을 확인할 수 있습니다. 구체적인 생성 과정은 다음과 같습니다. 필요한 경우 Waveform컨트롤을 추가하여 파형을 추가할 수 있습니다.Note : 프리뷰에서는 Diagram컨트롤에 있는 Waveform 컨트롤을 선택할 수 없기 때문에 Waveform컨트롤의 속성을 확인하거나 수정하기 위해서는 outline에서 waveform컨트롤을 선택할 수 밖에 없습니다. Diagram과 Waveform컨트롤 각각의 속성을 확인하면 Diagram컨트롤의 속성으로는 파형의 x, y좌표의 범위와 그려질 영역을 결정한다는 것을 알 수 있습니다. 그리고 Waveform컨트롤의 속성으로는 각 파형의 선 스타일을 결정합니다. Waveform컨트롤의 속성 중 Step과 Erase Space은 아래와 같습니다. Step 새로운 파형 데이터가 하나 추가되었을 때, 파형이 움직이는 거리(단위 : 픽셀)을 나타냅니다. 이 값은 x-axis zoom속성의 영향을 받습니다. Erase Space파형이 갱신 되었을 때 빈 부분의 넓이를 나타냅니다. 위의 두 가지 속성은 모두 void addData(int index, float data)함수를 이용해 새로운 파형 데이터를 추가 할 경우에만 유효합니다. 좌표와 스케일 전체 파형의 스케일은 자동으로 결정되므로, 속성 창의 x축, y축의 범위와 표시 영역의 크기만을 결정하면 됩니다. Note : Waveform 컨트롤의 X scale과 Y scale 속성은 해당 값의 배율에 따라 파형이 스크린에 그려집니다. 기본은 1.0이며 스케일되지 않음을 의미합니다. 파형의 좌표는 x-axis min value, x-axis max value, y-axis min value, and y-axis max value에 의해 결정됩니다. 예로, 기본 x-axis의 범위가 [0, 100]이고, y-axis의 범위가 [0,100]라면, 파형이 그려지는 영역의 좌표는 아래와 같습니다. 일반적으로 x-axis min 값은 x-axis max 의 값보다 작습니다. 그러나 반대로 값을 넣을 경우 파형은 동일한 데이터를 가진 파형이 x축으로 반전됩니다. 만약 void setData(int index, const MPPOINT *pPoints, int count)함수를 사용해서 데이타를 추가할 경우 갱신되는 방향 역시 반대 방향이 됩니다. 또한 이와 유사한 일이 y축에 발생한다면 위, 아래로 반전됩니다. 운영 코드 UI파일은 오직 파형의 형태만 빠르게 수정할 수 있고, 실제 파형은 코드를 통해 데이터를 추가해야 합니다. 프로젝트의 jni/include/control/ZKDiagram.h에서 이를 위한 지원 함수들을 찾아볼 수 있습니다.Note : 다른 컨트롤과는 다르게, Waveform컨트롤 역시 ID를 가지고 있지만, 이 ID로 독립적인 포인터 변수가 만들어지지 않습니다. 오직 Diagram컨트롤만 독립적인 포인터 변수가 만들어집니다. 그러므로 파형을 조정하기 위해서는 Diagram컨트롤의 포인터를 이용하여 index값으로 파형을 조정해야 합니다. index는 0부터 시작합니다. void setPenWidth(int index, int width)파형의 두께를 설정합니다. 속성 창의 Pen Width에 해당합니다. void setPenColor(int index, ARGB color)파형의 색을 설정합니다. 속성 창의 Pen Color에 해당합니다. void setXScale(int index, double xScale)X-axis의 스케일을 설정합니다. 속성 창의 X-axis Xcale에 해당합니다. void setYScale(int index, double yScale)Y-axis의 스케일을 설정합니다. 속성 창의 Y-axis Scale에 해당합니다. void setData(int index, const MPPOINT *pPoints, int count) typedef struct _MPPOINT { float x; float y; }MPPOINT; MMPOINT구조체는 파형 데이터의 x와 y값을 포함합니다. 이 함수는 index번 째 Waveform컨트롤에 count개의 데이터를 가지는 pPoints배열로 파형을 그리라는 의미입니다.(Note : count값은 pPoints의 실제 크기보다 클 수 없습니다.)이 함수를 이용해 파형을 그리는 경우 : 먼저 sPoints배열에 파형 데이터를 채우고 한 번에 파형을 갱신합니다. 그러므로 만약 파형을 왼쪽이나 오른쪽으로 움직이는 효과를 얻고 싶다면 배열 전체의 값을 조정해야 합니다. 보통 이러한 경우 타이머를 사용하여 구현하며, 이 함수 호출 시 전체 파형이 갱신됩니다. void addData(int index, float data) 파형에 하나의 데이터를 추가합니다. data는 y값이며 x값은 Step에 의해 자동으로 결정됩니다. void setData(int index, const MPPOINT *pPoints, int count) 와 void addData(int index, float data) 의 파형 갱신 방식을 비교하자면, 데이타의 사이즈가 클 경우에는 2번째 방법이 더 효율적으로 파형을 갱신할 수 있습니다. setData(index, NULL, 0)파형 데이타를 전부 0으로 클리어합니다. 파형 이동 방법 추가 위에서 보았 듯 void setData (int index, const MPPOINT * pPoints, int count)를 사용하여 파형을 그리는 경우 일반적으로 배열의 값을 직접 설정해야합니다. static void movePoints(MPPOINT* p,int size){ for(int i =0;i 타이머를 추가하여 파형 데이터를 주기적으로 갱신 일반적으로 주기적인 파형 갱신을 위해 가장 손쉬운 방법으로 타이머를 추가합니다. 예제 코드 프리뷰 구체적인 내용은 예제 코드의 DiagramDemo 프로젝트 참고하십시오. powered by Gitbooklast modified: 2020-12-09 11:23:59 "},"circlebar.html":{"url":"circlebar.html","title":"Circle Bar","keywords":"","body":"원형 프로그래스 바 특정 어플리케이션의 경우 \"일직선의 프로그래스 바\" 보다 \"원형의 프로그래스 바\"가 더 적합할 수 있습니다. 사용법 먼저 UI파일을 오픈 후 circular progress bar 컨트롤을 만듭니다. 그리고 valid picture 속성에 이미지를 추가하면 기본적인 원형 프로그래스 바가 완성됩니다.원형 프로그래스 바의 모든 속성은 아래와 같습니다. 원형 프로그래스 바는 현재의 프로그래스가 부채꼴 영역으로 표시되며, 이 영역은 valid picture의 일정 영역만을 디스플레이 하는 것으로 구현됩니다. 예를 들어, 만약 속성이 위의 이미지와 같이 설정되었다면, 최대 값은 100이고, 초기 시작 각도는 0°이며 프로그래스의 방향은 시계방향입니다. 그 후 프로그래스를 25로 설정한다면 오직 0°부터 90°의 부채꼴 영역에 해당하는 valid picture만 표시됩니다. 그리고 만약 프로그래스가 100이라면 전체 valid picture가 표시됩니다. Note: 프로그래스 값에 따른 디스플레이 영역의 변경은 valid picture에만 적용되고, background picture에는 적용되지 않습니다. 운용 코드 원형 프로그래스 바에서 제공하는 함수는 매우 단순합니다. //Set current progress void setProgress(int progress); //Get current progress int getProgress()； //Set maximum progress void setMax(int max); //Get maximum progress int getMax()； 예제 코드 예제에서 위쪽 슬라이드 바를 조정하면 아래의 2개 원형 프로그래스 바가 변경됩니다.Sample code의 CircleBarDemo 프로젝트 참고하십시오. powered by Gitbooklast modified: 2020-12-09 10:21:17 "},"qrcode.html":{"url":"qrcode.html","title":"QR Code","keywords":"","body":"QR code QR code를 추가하는 방법 QR code를 표시해야하는 경우 기존의 QR code컨트롤을 사용하여 빠르게 구현할 수 있습니다. 구체적인 단계는 다음과 같습니다. 더블 클릭하여 UI파일을 엽니다. 우측의 컨트롤 박스에서 QR code컨트롤을 찾습니다. QR code컨트롤을 마우스 왼쪽 버튼으로 누른 상태에서 원하는 위치로 드래그 한 후 왼쪽 버튼을 놓으면 QR code 컨트롤이 생성됩니다. 방금 생성 한 QR code컨트롤을 선택 후 우측의 속성 창에서 QR code의 내용을 수정하면 QR code의 이미지가 동시에 변경되는 것을 볼 수 있습니다. QR code를 동적으로 업데이트 IDE를 통해 QR code의 컨텐츠를 설정하는 것 외에도 코드를 통해 QR code의 컨텐츠를 동적으로 설정할 수도 있습니다. bool loadQRCode(const char *pStr); Sample code 더 자세한 사항은 Sample Code의 QrCodeDemo 프로젝트를 참고하십시오. powered by Gitbooklast modified: 2020-12-10 09:58:14 "},"video.html":{"url":"video.html","title":"Video View","keywords":"","body":"Video view FlywizOS는 동영상 재생을 위한 컨트롤도 제공합니다. [!Note] 동영상 재생 기능은 모든 버전의 기기에서 지원되지 않습니다! 이 기능을 정상적으로 사용하려면 멀티미디어 기능이 있는 버전을 구입하세요. 컨트롤의 Loop 속성 사용법 먼저 Video View 컨트롤을 만듭니다. 기본 배경색은 검은 색입니다. Video view 의 속성 창을 확인합니다. 그 중 하나의 속성으로 Loop 가 있습니다. 해당 속성을 Yes로 선택하면 이 UI 액티비티에 들어갈 때마다 자동으로 TF 카드 디렉토리의 구성 파일을 읽고 파일에 지정된 동영상를 반복 재생합니다. 액티비티를 종료하면 자동으로 재생을 중지합니다. 이 속성은 광고 장치와 같이 짧은 동영상의 자동 재생 등, 사용자의 개입없이 동영상 만 재생해야하는 장치에 매우 적합합니다. No를 선택하면 동영상의 렌더링 영역 만 생성되고 다른 작업은 수행되지 않습니다. 그 후 직접 조작하여 동영상를 재생해야 합니다. 동영상 구성 파일 만들기 위에서 언급했듯이 Loop가 Yes인 경우 동영상 구성 파일을 자동으로 읽습니다.(파일은 직접 만들어야 합니다.) 이 구성 파일은 TF 카드의 루트 디렉토리에 있어야 하고 파일 이름은 XXXX_video_list.txt입니다. XXXX는 해당 UI 파일 이름을 나타냅니다. 예 : main.ftu에 Video View 컨트롤을 추가하면 해당 구성 파일 이름은 main_video_list.txt 입니다. 구성 파일은 라인 단위이며 각 라인은 동영상 파일의 절대 경로입니다. 동영상 파일이 TF 카드의 루트 디렉토리에 있는 경우/mnt/extsd/를 입력하고 동영상 파일 이름을 추가하면 됩니다. Note : 파일 이름 인코딩 문제로 인한 동영상 파일 읽기 실패를 방지하려면 동영상 파일 이름을 영어로 지정하십시오. 프로그램이 실행 된 후 구성 파일의 동영상를 자동으로 반복 재생 할 수 있습니다. 지정된 동영상 파일 재생 Video View 컨트롤을 만듭니다. Loop를 No로 설정합니다. 재생을 제어하는 코드 추가합니다. Play //Play the test.mp4 file, starting from time 0 mVideoView1Ptr->play(\"/mnt/extsd/test.mp4\", 0); Pause //Pause playback mVideoView1Ptr->pause(); Resume //Resume playback mVideoView1Ptr->resume(); Stop mVideoView1Ptr->stop(); 특정 시간으로 이동 후 플레이 //Jump to the 10 second position mVideoView1Ptr->seekTo(10 * 1000); 재생 볼륨 설정, 범위 0 ~ 1.0 //Set the volume to 0.5 mVideoView1Ptr->setVolume(0.5); 재생 중인지 확인 bool state = mVideoView1Ptr->isPlaying(); if （state) { LOGD(\"Now Playing\"); } 동영상의 총 길이(ms)를 가져옵니다. int n = mVideoView1Ptr->getDuration(); 동영상의 현재 재생 위치를 ms단위로 가져옵니다. int n = mVideoView1Ptr->getCurrentPosition(); 동영상은 비동기 적으로 재생되며 자동으로 생성 된 관련 기능이 동영상 재생 상태를 알려줍니다. static void onVideoViewPlayerMessageListener_VideoView1(ZKVideoView *pVideoView, int msg) { switch (msg) { case ZKVideoView::E_MSGTYPE_VIDEO_PLAY_STARTED: LOGD(\"Start playback\"); break; case ZKVideoView::E_MSGTYPE_VIDEO_PLAY_COMPLETED: LOGD(\"End playback\"); break; case ZKVideoView::E_MSGTYPE_VIDEO_PLAY_ERROR: LOGD(\"Error\"); break; } } 완전한 동영상 플레이어 구현 동영상 재생에 대한 더 높은 요구 사항이 있는 경우 재생/일시 중지 및 현재 재생 시간 등을 조작할 수 있서야 합니다. 전체 동영상 플레이어 샘플(계속)을 참조하세요. Sample code 더 자세한 내용은 Sample Code의 VideDemo 프로젝트를 참고하십시오. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"edittext.html":{"url":"edittext.html","title":"Edit Text","keywords":"","body":"Edit Text 만약 숫자 키보드가 필요거나 사용자가 텍스트를 입력할 수 있게 하려면 어떻게 해야할까요? Edit Text box 추가하기 만약 숫자나 텍스트 입력이 필요하다면, Edit Text컨트롤을 이용해서 빠르게 구현할 수 있습니다. 그 과정은 아래와 같습니다. 프로젝트 창에서 버튼을 추가하고자 하는 액티비티의 UI을 더블 클릭합니다. 우측의 컨트롤 박스에서 Edit Text컨트롤을 선택합니다. Edit Text컨트롤을 마우스 왼쪽 클릭 후 원하는 위치에 클릭하거나 드래그 앤 드롭하면 컨트롤이 만들어집니다. 만들어진 버튼을 왼쪽 클릭하면 속성 창에서 해당 컨트롤과 관련된 속성들을 확인하고, 변경할 수 있습니다. 프로그램을 보드에 다운로드해서 실행 후 Edit Text 컨트롤을 터치하면 내장된 가상 숫자 키보드나 가상 텍스트 키보드가 자동으로 팝업되고, 이를 통해 숫자나 텍스트를 입력할 수 있습니다. 내장 가상 텍스트 입력 키보드 내장 가상 숫자 입력 키보드 기본 Edit Text는 흰색이며, 속성 창을 통해 사용자가 원하는 스타일로 변경이 가능합니다. Edit Text와 관련된 속성은 다음과 같습니다. Password만약 \"Yes\"를 선택하면 키보드 입력 시 표시되는 텍스트가 Password Char로 표시되고, \"No\"일 경우 입력한 텍스트가 표시됩니다. Password CharPassword가 \"Yes\"일 경우 키보드 입력 시 표시되는 텍스트를 설정합니다. 기본적으로 \"*\"가 표시됩니다. Input Type입력 형식은 2가지가 있습니다. Text - 영어 또는 숫자를 입력할 수 있습니다. Number - 숫자만 입력이 가능합니다. Hint Text아무런 입력이 없을 경우 자동으로 표시되는 텍스트를 설정합니다. Hint Text ColorHint Text의 색을 설정합니다. 가상 키보드로부터 입력된 컨텐츠 가져오기 Edit Text컨트롤을 성공적으로 완성 후 컴파일하면 이와 관련된 함수들이 자동으로 생성됩니다. 프로젝트 디렉토리에서 jni/logic/****Logic.cc파일을 열면 해당 함수를 찾을 수 있습니다. static void onEditTextChanged_XXXX(const std::string &text) { //LOGD(\"The current input is %s \\n\", text.c_str()); } 가상 키보드로 텍스트를 입력하면 시스템은 자동으로 해당 함수를 호출하고, text파라미터를 통해 현재 입력된 컨텐츠가 전달됩니다.std::string은 C++의 string이며, 사용자는 아래의 예제처럼 string의 포인터를 가져올 수 있습니다. const char* str = text.c_str(); 입력된 컨텐츠를 숫자로 전환 Edit Text와 관련된 함수로는 획득한 데이타는 문자로만 획득이 가능합니다. 그래서 숫자를 입력해도 문자로 획득되기 때문에 이를 숫자로 바꿀 필요가 있습니다. atoi함수는 문자를 숫자로 바꿀 수 있습니다. 예를 들어, 문자 \"213\"은 정수213으로 바꿀 수 있습니다.만약 숫자로 변경할 수 없는 문자가 입력되면, 전환이 실패할 수 있습니다.예 :atoi(\"213abc\"); return 213atoi(\"abc\"); return 0static void onEditTextChanged_EditText1(const std::string &text) { int number = atoi(text.c_str()); LOGD(\"String to number = %d\", number); } atof는 문자를 부동 소수점 수로 전환하는 함수입니다. 예를 들어, \"3.14\"는 부동 소수점 수 3.14로 전환됩니다.만약 부동 소수점 수로 변경할 수 없는 문자가 입력되면, 전환이 실패할 수 있습니다.예 :atoi(\"3.14abc\"); return 3.14atoi(\"abc\"); return 0static void onEditTextChanged_EditText1(const std::string &text) { // The atof function can convert a string to a corresponding floating point number, for example, \"3.14\" can be converted to an // integer 3.14 // If the parameters are not standardized, the conversion will fail, and the number 0 will be returned uniformly double f = atof(text.c_str()); LOGD(\"Convert string to floating point = %f\", f); } 커스텀 입력기 기본 입력 방법에 추가적으로 사용자가 원하는 형태의 입력기를 만들 수 있습니다. Sample Code Package의 ImeDemo 프로젝트에서 그 예를 찾아볼 수 있습니다. (현재는 문자와 숫자만 제공됩니다.) 보통 입력기와 커스텀 입력기의 차이는 아래와 같습니다. 보통 입력기는 Activity를 상속받아 구현되지만, 커스텀 입력기는 IMEBaseApp의 상속이 필요합니다. 추가적으로 등록 방법에 차이가 있습니다. 보통 입력기는 REGISTER_ACTIVITY(****Activity);를 통해 등록되지만, 커스텀 입력기는 REGISTER_SYSAPP(APP_TYPE_SYS_IME, ****Activity);를 통해 등록됩니다.(**는 UI파일 이름) ImeDemo프로젝트를 수정해서 사용자만의 커스텀 입력기를 만들 수 있습니다. 먼저 UserIme.ftu파일을 사용자 프로젝트의 ui디렉토리에 복사합니다. UserImeActivity.h와 UserImeActivity.cpp를 사용자 프로젝트의 activity 디렉토리에 복사합니다. UserImeLogic.cc 파일을 사용자 프로젝트의 logic 디렉토리에 복사합니다. 이후 UserImeLogic.cc파일을 사용자에 요구에 맞게 수정합니다. powered by Gitbooklast modified: 2020-12-09 11:44:02 "},"window.html":{"url":"window.html","title":"Window","keywords":"","body":"Window 기능 설명 Window는 실제로 컨테이너이며 모든 컨트롤을 포함하거나 새 Window를 다시 포함 할 수 있고 다음과 같은 시나리오에서 사용할 수 있습니다. 컨트롤 조합 표시 및 숨기기 탭 페이지를 완성해야 할 때 여러 Window를 통해 다른 Window 사이를 전환 할 수 있습니다. 팝업 대화 상자 사용법 Window 컨트롤을 만듭니다. 기본 Window는 투명합니다. 배경 이미지를 추가하거나 필요에 따라 배경색을 수정할 수 있으며 Window에 다른 컨트롤을 추가 할 수도 있습니다. 위의 속성 창에는 설명해야 할 두 가지 속성이 있습니다. Modal모달인 경우 이 Window 컨트롤이 표시 될 때 Window 바깥 쪽을 클릭하면 창이 자동으로 숨겨집니다. 모달이 아닌 경우 창 컨트롤의 표시/숨기기를 자체적으로 제어해야 합니다. Timeout auto hide모달 Window인 경우 Window는 표시 시작부터 계산을 시작하고 지정된 시간이 지나면 자동으로 숨겨집니다. 단위는 초이며 값이 -1이면 자동으로 숨겨지지 않음을 의미합니다. 모달이 아닌 경우이 속성은 효과가 없습니다. 코드 조작 Window 컨트롤의 경우 일반적으로 다음 함수가 포함됩니다. //Show window void showWnd(); //Hide window void hideWnd(); //Determine whether the window is displayed bool isWndShow(); 동적으로 배경 설정 화면 전체에 Window를 펼친 다음 이 Window의 배경을 설정하면 화면 배경을 수정하는 효과를 얻을 수 있습니다. 관련된 함수 /** * @brief Set background picture * @param pPicPath Picture path */ void setBackgroundPic(const char *pPicPath); /** * @brief Set background color * @param color When -1, the background is set to transparent; other color values are 0xRGB, and the color value does not * support alpha */ void setBackgroundColor(int color); 사용 예제 //Set the image of the path /mnt/extsd/bg.png as the background image of this window control mWindow1Ptr->setBackgroundPic(\"/mnt/extsd/bg.png\"); //Set the background color of the window with ID window1 to red mWindow1Ptr->setBackgroundColor(0xff0000); //Set the background color of the window with ID window1 to green mWindow1Ptr->setBackgroundColor(0x00ff00); //Set the background color of the window with ID window1 to blue mWindow1Ptr->setBackgroundColor(0x0000ff); 많은 컨트롤에는 배경색 및 배경 이미지를 설정하는 인터페이스가 있으며 방법은 동일합니다. Sample code 더 자세한 내용은 Sample Code의 WindowDemo 프로젝트를 참고하십시오. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"slidewindow.html":{"url":"slidewindow.html","title":"Slide Window","keywords":"","body":"Slide Window컨트롤 Slide Window컨트롤은 휴대폰의 메인 인터페이스에서 좌우로 슬라이딩하는 인터페이스와 유사한 효과를 제공하며 Slide Window와 여러 개의 Slide Window icon으로 구성됩니다. 사용법 먼저 UI 파일에 Slide Window컨트롤을 만든 다음 Slide Window icon컨트롤을 추가합니다. Slide Window icon컨트롤을 추가하면 아이콘이 순서대로 자동 정렬됩니다. 만약 한 페이지에 추가가 완료된 후에도 계속 추가하면 페이지가 자동으로 넘어갑니다. 추가 된 모든 아이콘 컨트롤은 Outline에서 찾을 수 있습니다. Slide Window Icon의 위치를 조정하려면 Outline에서 노드를 선택한 다음 드래그하여 직접 조정할 수 있습니다. 아래 애니메이션의 왼쪽 하단에 있는 Outline의 동작에 유의하십시오. Outline에서 Slide Window Icon컨트롤을 선택하면 그림을 추가하고 텍스트를 개별적으로 수정할 수 있습니다. Slide Window을 선택하여 행과 열 수를 조정하고 글꼴 크기, 아이콘 크기를 균일하게 조정할 수도 있습니다. 코드 조작 Slide Window컨트롤을 추가하면 컴파일 후 자동으로 관련 함수가 생성되며, 자세한 기능 설명은 슬라이드 윈도우 관련 함수를 참조하십시오. 일반적인 상황에서는 터치하고 슬라이드하여 위아래로 스크롤하기 만하면 됩니다. 그러나 페이지 넘김 기능도 제공합니다. 다음 페이지로 전환// Switch to the next page with animation mSlideWindow1Ptr->turnToNextPage(true); // Switch to the next page without animation mSlideWindow1Ptr->turnToNextPage(false); 이전 페이지로 전환// Switch to the previous page with animation mSlideWindow1Ptr->turnToPrevPage(true); // Switch to the previous page without animation mSlideWindow1Ptr->turnToPrevPage(false); Slide Window가 코드를 통해 어떤 페이지로 전환되었는지 모니터링 할 수도 있습니다. namespace { // Add an anonymous scope to prevent multiple source files from defining the same class name and conflict at // runtime // Implement your own listening interface class MySlidePageChangeListener : public ZKSlideWindow::ISlidePageChangeListener { public: virtual void onSlidePageChange(ZKSlideWindow *pSlideWindow, int page) { LOGD(\"Now switch to page %d\", page); } }; } // Define the listening object static MySlidePageChangeListener sMySlidePageChangeListener; static void onUI_init() { mSlidewindow1Ptr->setSlidePageChangeListener(&sMySlidePageChangeListener); } 현재 페이지 가져오기 int i = mSlideWindow1Ptr->getCurrentPage(); LOGD(\"Current page %d\", i); Sample code 더 자세한 내용은 Sample Code의 SlideWindowDemo프로젝트를 참고하십시오. powered by Gitbooklast modified: 2020-12-10 15:34:26 "},"painter.html":{"url":"painter.html","title":"Painter","keywords":"","body":"Painter Painter 컨트롤은 간단한 기하학적 그리기 인터페이스를 제공합니다. 사용법 Painter컨트롤을 생성합니다. 기본 Painter컨트롤은 투명합니다. 필요에 따라 배경 이미지를 추가하거나 배경 색을 수정할 수 있습니다. 코드 조작 Painter 컨트롤의 변수 포인터를 통해 함수들을 호출하여 그림을 그릴 수 있습니다. 이 컨트롤의 대부분의 함수들은 코드로 구현해야합니다. 예제는 다음과 같습니다. static void onUI_init() { /** * Draw a rounded rectangle border */ mPainter1Ptr->setLineWidth(4); mPainter1Ptr->setSourceColor(0x7092be); mPainter1Ptr->drawRect(10, 10, 430, 230, 5, 5); /** * Draw an arc */ mPainter1Ptr->setLineWidth(3); mPainter1Ptr->setSourceColor(0xadc70c); mPainter1Ptr->drawArc(80, 80, 40, 40, -20, -120); /** * fill an arc */ mPainter1Ptr->setLineWidth(3); mPainter1Ptr->setSourceColor(0x008ecc); mPainter1Ptr->fillArc(80, 80, 40, 40, -20, 120); /** * Draw triangle */ mPainter1Ptr->setLineWidth(4); mPainter1Ptr->setSourceColor(0xff804f); mPainter1Ptr->drawTriangle(200, 40, 160, 90, 240, 90);//空心三角形 mPainter1Ptr->fillTriangle(300, 40, 260, 90, 340, 90); //实心三角形 /** * Draw straight line */ MPPOINT points1[] = { {50 , 150}, {150, 150}, {70 , 200}, {100, 120}, {130, 200}, {50 , 150} }; /** Connect to a line according to the provided coordinates of multiple points */ mPainter1Ptr->setLineWidth(2); mPainter1Ptr->setSourceColor(0x88cffa); mPainter1Ptr->drawLines(points1, TABLESIZE(points1)); /** * Draw a curve */ MPPOINT points2[] = { {250, 150}, {350, 150}, {270, 200}, {300, 120}, {330, 200}, {250, 150} }; mPainter1Ptr->setLineWidth(3); mPainter1Ptr->setSourceColor(0xe28ddf); /** Connect as a curve according to the provided multiple point coordinates */ mPainter1Ptr->drawCurve(points2, TABLESIZE(points2)); } Sample code Painter컨트롤의 사용을 보여줍니다. 더 자세한 사항은 Sample Code의 PainterDemo를 참고하십시오. powered by Gitbooklast modified: 2020-12-09 17:54:54 "},"camera.html":{"url":"camera.html","title":"Camera","keywords":"","body":"카메라 FlywizOS는 카메라 컨트롤 기능을 제공합니다. [!Note] 모든 버전의 보드에서 카메라 기능을 지원하지는 않습니다. 만약 이 기능이 필요하다면 USB카메라 기능을 지원하는 보드를 구매해야 합니다. 사용법 먼저 카메라 컨트롤을 만듭니다. 기본 배경은 검은색입니다. 카메라 컨트롤의 속성창을 확인합니다. Auto Preview속성을 On으로 설정합니다. 연결되는 카메라 타입에 따라 CVBS Signal 속성을 선택합니다. 카메라을 보드에 연결하고 프로그램을 다운로드하면 카메라로부터 입력되는 영상을 볼 수 있습니다. 프리뷰 시작/정지 소스 코드를 통해 프리뷰의 시작/정지를 제어할 수 있습니다. 프리뷰 시작mCameraView1Ptr->startPreview(); 프리뷰 정지mCameraView1Ptr->stopPreview(); 프리뷰 화면 캡쳐 카메라 콜백 인터페이스 구현 class PictureCallback : public ZKCamera::IPictureCallback { public: virtual void onPictureTakenStarted() { mTextView1Ptr->setText(\"Start taking a photo\"); } virtual void onPictureTakenEnd() { mTextView1Ptr->setText(\"End of photo\"); } virtual void onPictureTakenError() { mTextView1Ptr->setText(\"Photo error\"); } virtual const char* onPictureSavePath() { //Photo save path return \"/mnt/extsd/camera.jpg\"; } }; 카메라 콜백 인터페이스 선언 //Defined as a global static variable static PictureCallback picture_callback; 카메라 컨트롤에 터페이스 등록 및 등록 해제 static void onUI_init(){ mCameraView1Ptr->setPictureCallback(&picture_callback); } static void onUI_quit() { //Remember to empty the registration interface when the interface exits mCameraView1Ptr->setPictureCallback(NULL); } 버튼 추가하여 버튼이 눌릴 시 화면 캡쳐static bool onButtonClick_Button3(ZKButton *pButton) { //Request a photo mCameraView1Ptr->takePicture(); return false; } 예제 코드 이 예제에는 카메라 프리뷰, 앨범 기능등이 구현되어 있습니다.Sample code의 CameraDemo 프로젝트 참고하십시오. powered by Gitbooklast modified: 2020-12-09 10:06:03 "},"digital_clock.html":{"url":"digital_clock.html","title":"Digital Clock","keywords":"","body":"디지탈 시계 디지탈 시계는 시간을 표시하는 전용 컨트롤로, 많은 시나리오에서 사용자는 시간을 표시해야 하며 시스템 시간에 따라 자동으로 표시됩니다. 사용법 프로젝트 창에서 디지탈 시계를 추가하고자 하는 액티비티의 UI 파일을 더블 클릭합니다. 우측의 컨트롤 박스에서 Digital Clock 컨트롤을 선택합니다. Digital Clock컨트롤을 마우스 왼쪽 클릭 후 드래그하여 디지탈 시계를 만들 위치에 놓으면, 자동으로 컨트롤이 만들어집니다. 만들어진 디지탈 시계를 마우스 왼쪽 클릭하면 속성 창에서 해당 컨트롤과 관련된 속성들을 확인하고, 변경할 수 있습니다. Format 시간을 표시하는 형식을 설정합니다. 24시간 또는 12시간 시스템, 그리고 초에 대한 표시 유무를 선택할 수 있습니다. Blinking :이 항상 표시되는지, 점멸되는지를 설정합니다. Color 디지탈 시계의 글자 색을 설정합니다. Font size 디지탈 시계의 글자 크기를 설정합니다. Picture Character Set숫자나 글자를 지정된 이미지로 표시할 수 있도록 설정합니다.(Text 컨트롤의 이미지 캐릭터 설정을 참고하십시오) 저장, 다운로드 후 효과를 확인합니다. 만약 시간을 수정하기 원한다면 시스템 시간을 참고하십시오. 예제 코드 Sample code의 DigitalClockDemo 프로젝트 참고하십시오. powered by Gitbooklast modified: 2020-12-09 11:28:21 "},"relation_function.html":{"url":"relation_function.html","title":"상관 함수 소개","keywords":"","body":"컨트롤에 의해 자동으로 생성 된 관련 함수에 대한 설명 일부 컨트롤은 관련 함수를 자동으로 생성합니다. 이러한 컨트롤에 의해 생성 된 관련 함수에 대한 구체적인 설명은 다음과 같습니다. [!Note] 함수에서XXXX는 컨트롤 ID를 나타내므로 실제 프로세스에서 직접 수정하십시오. Button control static bool onButtonClick_XXXX(ZKButton *pButton) { return false; } 버튼을 클릭하면 함수가 호출됩니다. 파라미터 ZKButton* pButton은 클릭 한 버튼의 포인터입니다. 포인터의 멤버 함수를 통해 컨트롤에 대해 일련의 작업을 수행 할 수 있습니다. 이 포인터는 전역 변수 mXXXXPtr이 가리키는 객체와 동일한 객체입니다. Edit Text control static void onEditTextChanged_XXXX(const std::string &text) { } Edit box의 텍스트가 변경되면 시스템이 자동으로 이 함수를 호출합니다. 파라미터 std::string &text 현재 Input box의 전체 문자열입니다. Seek Bar control static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress) { } Seek Bar의 현재 프로그래스 값이 변경되면 시스템이 자동으로 이 함수를 호출합니다. 파라미터ZKSeekBar * pSeekBar는 Seek Bar컨트롤의 포인터이며 포인터의 멤버 함수를 통해 컨트롤에서 일련의 작업을 수행 할 수 있습니다. 파라미터 int progress는 현재 Seek Bar의 프로그래스 값입니다. Slide Window control static void onSlideItemClick_XXXX(ZKSlideWindow *pSlideWindow, int index) { } Slide Window컨트롤에서 아이콘을 클릭하면 시스템이 자동으로 이 함수를 호출합니다. 파라미터 ZKSlideWindow * pSlideWindow는 Slide Window컨트롤의 포인터이며 포인터의 멤버 함수를 통해 컨트롤에 대해 일련의 작업을 수행 할 수 있습니다. 파라미터 int index는 현재 클릭 된 아이콘의 Index값입니다. 예를 들어 총 10개의 아이콘이 Slide Window에 추가되었다면 Index값의 범위는 [0, 9]입니다. List control List컨트롤은 가장 복잡한 컨트롤이며 세 가지 관련 함수를 만듭니다. 많은 기능이 있지만 다음 단계에 따라가면 이해하기 매우 쉽습니다. 첫째, 시스템이 List컨트롤을 그리려면 얼마나 많은 아이템이 있는지 알아야합니다. 따라서 다음과 같은 관련 함수가 있습니다. static int getListItemCount_XXXX(const ZKListView *pListView) { return 0; } 파라미터 const ZKListView * pListView는 전역 변수mXXXXPtr과 동일한 객체를 가리키는 List컨트롤의 포인터입니다. 리턴 값은 정수로, List에 있는 아이템 수를 의미하며 필요에 따라 정의 할 수 있습니다. 시스템이 그려야 할 아이템의 수를 알아도 각 아이템에 표시할 내용을 모를 경우 리스트를 그리기에는 충분하지 않습니다. 이를 위해 아래 함수가 제공되고, 제공된 함수가 아이템의 수 만큼 호출되어 각 아이템의 표시 내용을 설정합니다. void obtainListItemData_XXXX(ZKListView *pListView, ZKListView::ZKListItem *pListItem, int index) { //pListItem->setText(index) } 파라미터 ZKListView * pListView는 전역 변수 mXXXXPtr과 동일한 객체를 가리키는 List컨트롤의 포인터입니다. 파라미터 ZKListView :: ZKListItem * pListItem은 List Item의 포인터이며 UI파일의 Item에 해당합니다. 파라미터 int index는 전체 List에서 pListItem의 Index값이며 특정 범위가 있습니다. 예 : getListItemCount_XXXX함수의 반환 값이 10이면 이는 List에 10개의 Item이 있음을 의미합니다. 그러면 index의 범위는 [0, 9]이며, 이를 이용하여 현재 설정해야 할 List Item이 전체 List에서 어디에 있는지 알 수 있습니다. 이 함수에서는 index에 따라 각 List의 표시 내용을 개별적으로 설정할 수 있습니다.예 : 함수에서 주석 처리 된 문은 다음을 의미합니다. 각 List Item은 해당 Index값을 텍스트로 표시합니다. Button컨트롤과 마찬가지로 List컨트롤에도 클릭 이벤트가 있고, Index값을 기준으로 현재 클릭 된 List Item을 판단합니다. static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); } List컨트롤을 클릭하면 터치 좌표가 어떤 List Item에 속하는지 시스템이 결정하고 List Item의 인덱스 번호를 계산 한 후 자동으로 이 함수를 호출합니다. 파라미터 ZKListView * pListView는 전역 변수 mXXXXPtr과 동일한 객체를 가리키는 List 컨트롤의 포인터입니다. 파라미터 int index는 전체 List컨트롤에서 현재 클릭 된 List Item의 Index값입니다. 파라미터 int id는 현재 클릭 된 컨트롤의 ID입니다. 이 ID는 속성 창의 ID와 다릅니다. 이에 대한 매크로는 해당 Activity.h파일에 정의되어 있습니다. 예를 들어 mainActivity.h에서 이 id의 기능은 List Item에 여러 subItem이 있을 때 현재 클릭 된 subItem을 구별하는 데 사용할 수 있다는 것입니다.예 : 아래 그림과 같이 List Item에 두 개의 subItem을 추가하고 스위치 버튼으로 그림을 추가했습니다. 속성 ID는 각각 SubItem1및 SubItem2입니다. SubItem1을 클릭하면 id와 ID_MAIN_SubItem1, ID_MAIN_SubItem2의 관계를 판단하여 어떤 스위치를 클릭했는지 확인할 수 있습니다. 예제 코드 : static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); switch(id) { case ID_MAIN_SubItem1: //LOGD(\"Clicked the first subitem of item %d in the list\", index); break; case ID_MAIN_SubItem2: //LOGD(\"Clicked the second subitem of item %d in the list\", index); break; } } powered by Gitbooklast modified: 2020-12-10 10:35:21 "},"first_app.html":{"url":"first_app.html","title":"시작 액티비티","keywords":"","body":"새로운 프로젝트를 생성하면 jni폴더에 템플릿 코드가 들어있는 Main.cpp파일이 생성됩니다. 위의 붉은 색 사각형의 코드에서 어떤 액티비티가 시작 액티비티인지 알 수 있고, 이로부터 mainActivity가 시작 액티비티임을 알 수 있습니다. 또한 jni/activity/mainActivity.cpp파일에서는 어떤 UI파일이 해당 액티비티의 UI파일인지 확인 가능합니다. powered by Gitbooklast modified: 2020-12-14 10:11:43 "},"open_close_app.html":{"url":"open_close_app.html","title":"어플리케이션 액티비시 실행/종료","keywords":"","body":"앞서 우리는 이미 시작 액티비티에 대해 배웠습니다. 시작 액티비티 실행 후 두 번째, 세 번째의 다른 액티비티를 실행할 수 있습니다. 여기서는 액티비티를 실행하고 종료하는 방법에 대하여 배우도록 하겠습니다. Application activity 실행 예를 들어 이제 sub.ftu에 해당하는 액티비티를 실행해야 합니다. 앞서 시작 액티비티의 분석에 따라 UI 파일에 해당하는 액티비티 객체가 subActivity임을 알 수 있습니다. 이것들은 IDE에 의해 자동으로 생성되는 코드이고, 이 액티비티는 아래의 코드를 통해 실행할 수 있습니다. EASYUICONTEXT->openActivity(\"subActivity\"); 만약 버튼 클릭을 통해 sub.ftu액티비티로 진입하려면 버튼 클릭 이벤트 함수에서 위의 함수를 호출하십시오. static bool onButtonClick_Button1(ZKButton *pButton) { // Jump to the sub.ftu activity EASYUICONTEXT->openActivity(\"subActivity\"); return false; } 정상적인 상황에서는, 위의 호출 코드로 충분합니다. 그러나 결제 페이지처럼 액티비티 간에 어떤 정보를 전달할 필요가 있다면, openActivity로 전달되는 두 번째 파라미터를 사용해서 정보를 전달해야 합니다. Intent *pIntent = new Intent(); pIntent->putExtra(\"cmd\", \"open\"); pIntent->putExtra(\"value\", \"ok\"); EASYUICONTEXT->openActivity(\"subActivity\", pIntent); 이 정보는 subLogic.cc의 onUI_intent콜백에서 수신 할 수 있습니다. static void onUI_intent(const Intent *intentPtr) { if (intentPtr) { // Key value analysis std::string cmd = intentPtr->getExtra(\"cmd\"); // \"open\" std::string value = intentPtr->getExtra(\"value\"); // \"ok\" ...... } } Note： 인텐트는 수동으로 삭제할 필요가 없으며 프레임 워크 내에서 자동으로 삭제됩니다. putExtra는 string의 key-value pair 메소드만 제공합니다. int 또는 다른 유형의 값을 전달해야 하는 경우 문자열 유형으로 변환 후 onIntent에서 수신하고, 원래대로 변환을 수행해야 합니다. Application activity 종료 위의 openActivity함수를 통해 subActivity를실행했는데, 원래 액티비티로 돌아가고 싶으면 어떻게 해야할까요?다음 코드를 통해 이전 액티비티로 돌아갈 수 있습니다. EASYUICONTEXT->goBack(); 버튼에 의해 goBack()이 트리거되는 경우, IDE를 사용하여 버튼의 ID값을 sys_back으로 설정하면 직접 goBack()기능을 사용할 수 있습니다. 만약 여러개의 액티비티가 실행되어 있는 상태에서 바로 시작 액티비티로 돌아가길 원한다면, 아래 코드로 구현 가능합니다. EASYUICONTEXT->goHome(); 시작 액티비티로 돌아갑니다. 또한 버튼으로 트리거되는 경우 IDE를 사용하여 버튼의 ID값을 sys_home으로 설정하면 직접 goHome()기능을 사용할 수 있습니다. 끝으로, EasyUIContext의 closeActivity함수를 통해 액티비티를 종료할 수도 있습니다. 예를 들어 subActivity를 종료하고 싶을 경우 아래처럼 할 수 있습니다. EASYUICONTEXT->closeActivity(\"subActivity\"); 이 함수를 사용하려면 호출자가 종료할 액티비티의 이름을 알아야합니다. Note : 이 함수는 시작 액티비티를 종료할 수 없습니다. 시작 액티비티는 항상 존재합니다. powered by Gitbooklast modified: 2020-12-09 17:53:21 "},"activity_life_cycle.html":{"url":"activity_life_cycle.html","title":"액티비티 라이프 사이클","keywords":"","body":"액티비티 활동 주기 액티비티 활동 주기를 소개하기 전에 먼저 액티비티 간의 계층 관계에 대해 알아보겠습니다. FlywizOS의 어플리케이션은 가장 먼저 mainActivity라는 시작 액티비티가 실행되고, openActivity함수를 통해 subActivity, thirdActivity를 실행할 수 있습니다. 위 그림은 액티비티 간의 관계를 나타내고 있으며, 그림처럼 액티비티가 저장되는 스택이 있고, 이 스택에 mainActivity부터 나중에 실행된 액티비티가 기존 액티비티 위에 쌓이는 형태로 구성됩니다. 액티비티 실행 과정 openActivity함수를 호출 한 후의 과정을 살펴 보겠습니다. 두 가지 경우가 있습니다. 액티비티 스택에 실행하려는 액티비티가 없는 경우 subLogic.cc의 onUI_init함수를 살펴 보겠습니다. 액티비티 스택에 액티비티가 없는 경우에 이 함수가 사용됩니다. 이 함수가 호출되었다는 것은 모든 컨트롤 포인터가 초기화가 완료되었음을 의미합니다. 이 함수에서는 다음과 같이 몇 가지 작업을 수행 할 수 있습니다. static void onUI_init() { //Tips :Add the display code of UI initialization here, such as:mTextView1Ptr->setText(\"123\"); LOGD(\"sub onUI_init\\n\"); mTextView1Ptr->setText(\"123\"); } 만약 초기화 시 사용자가 특정한 데이터를 전달하고 싶다면 onUI_intent 함수로 그 데이터를 전달받을 수 있습니다. static void onUI_intent(const Intent *intentPtr) { LOGD(\"sub onUI_intent\\n\"); // Judge not empty if (intentPtr) { // Key value analysis std::string cmd = intentPtr->getExtra(\"cmd\"); // \"open\" std::string value = intentPtr->getExtra(\"value\"); // \"ok\" ...... } } onUI_show 함수 - 액티비티 디스플레이 완료 콜백 함수 액티비티 스택에 실행하려는 액티비티가 존재하는 경우 이 경우 해당하는 액티비티가 액티비티 스택의 최상위로 이동되며, onUI_init함수는 호출되지 않습니다. 실행되는 액티비티가 디스플레이되면 직전 최상위 액티비티는 숨겨집니다.아래는 mainActivity에서 subActivity가 실행될 때의 과정을 보여줍니다. 이 과정에서 중요하게 여길 부분은 mainActivity hide ------> subActivity display 입니다. 액티비티 종료 과정 액티비티를 종료하는 방법에는 3가지의 방법이 있습니다. goBack() - 최상위 액티비티를 즉시 종료합니다. 액티비티가 종료될 때 onUI_quit함수가 호출되며, 만약 해제가 필요한 리소스들이 있다면 이 함수에서 해제하는 것을 권장합니다. 최상위 액티비티가 종료된 후 다음 액티비티의 onUI_show함수가 호출되고 액티비티가 디스플레이됩니다. goHome() - 즉시 mainActivity로 이동되며, mainActivity를 제외한 모든 액티비티가 종료됩니다. closeActivity(\"xxx\") - 특정 액티비티를 종료합니다.(mainActivity 제외) 해당 액티비티가 최상위 액티비티가 아니면, 하위 액티비티의 onUI_show는 호출되지 않습니다. powered by Gitbooklast modified: 2020-12-08 18:41:46 "},"internal_app.html":{"url":"internal_app.html","title":"시스템 내장 액티비티","keywords":"","body":"개발자가 직접 만든 액티비티 이외에, 시스템에서 제공되는 몇 가지 내장된 액티비티가 있습니다. 예를 들어 TF카드를 이용해 시스템을 업데이트 시 자동으로 실행되는 내장 액티비티가 있습니다. 이외에 설정 액티비티가 있고 아래의 방법으로 실행할 수 있습니다. EASYUICONTEXT->openActivity(\"ZKSettingActivity\"); 또한 버튼 등을 이용해 설정 액티비티를 실행할 수도 있습니다. (다른 여러 내장 액티비티도 이러한 방법으로 실행이 가능합니다.) static bool onButtonClick_Button1(ZKButton *pButton) { EASYUICONTEXT->openActivity(\"ZKSettingActivity\"); return false; } 각각의 아이템이 선택되면, 각기 내장된 다른 액티비티가 실행됩니다. 먼저 Network을 선택합니다. EASYUICONTEXT->openActivity(\"NetSettingActivity\"); WIFI 설정: EASYUICONTEXT->openActivity(\"WifiSettingActivity\"); 만약 사용중인 보드가 WIFI를 지원한다면, 오른쪽 상단의 WIFI on버튼을 활성 화 시 WIFI를 검생하여 액티비티에 표시합니다. Hotspot 설정: EASYUICONTEXT->openActivity(\"SoftApSettingActivity\"); Language 설정: EASYUICONTEXT->openActivity(\"LanguageSettingActivity\"); Touch calibration 설정: EASYUICONTEXT->openActivity(\"TouchCalibrationActivity\"); Developer options 설정: EASYUICONTEXT->openActivity(\"DeveloperSettingActivity\"); 현재는 오직 ADB 디버깅에 대한 설정이 가능합니다. powered by Gitbooklast modified: 2020-12-09 14:45:41 "},"system_app.html":{"url":"system_app.html","title":"시스템 어플리케이션","keywords":"","body":"시스템 액티비티 IDE를 통해 새로운 UI 파일을 만들 때 기본 UI 유형은 Normal이며, 일반적인 상황에서는 충분합니다. 일부 장면에서 UI액티비티 위에 떠있는 디스플레이 영역이 필요한 경우 Normal UI파일이 아닌 다른 유형의 UI파일을 사용해야 합니다. UI Type 옵션에는 세 가지 특수 유형의 옵션이 있습니다. 이 세 가지 특수 유형에는 다음에 해당하는 특수 UI파일 이름이 있습니다. statusbar.ftu navibar.ftu screensaver.ftu 확인을 클릭하면 IDE가 자동으로 해당 코드를 생성합니다. 이 세 가지 유형의 액티비티의 작업은 일반 액티비티의 작업과 동일합니다. Status bar 설명 : 이 Status bar는 Android 및 iOS 휴대폰의 상태 표시 줄과 동일한 개념으로 UI 위에 떠있는 일반 표시 영역입니다. 일반적으로 몇 가지 공통 정보를 표시하거나 복귀 버튼 또는 홈 버튼 등을 배치하는 데 사용됩니다. 시스템은 Status bar을 작동하는 데 사용할 수 있는 두 가지 인터페이스를 제공합니다. Show status bar： EASYUICONTEXT->showStatusBar(); Hide status bar： EASYUICONTEXT->hideStatusBar(); 전체 코드는 Sample Code의 StatusBarDemo 프로젝트를 참고하십시오. Navigation bar 이 Navigation bar는 안드로이드 폰의 Navigation bar와 동일한 개념을 가지고 있으며, 일반적으로 페이지 하단에 있는 UI 위에 떠있는 일반 작업 또는 표시 영역입니다. 일반적으로 일부 조작 키를 표시하는 데 사용됩니다. Navigation bar은 실제로 Status bar과 다르지 않습니다. Show navigation bar： EASYUICONTEXT->showNaviBar(); Hide navigation bar： EASYUICONTEXT->hideNaviBar(); Screensaver Screensaver 어플리케이션은 사용자가 정해진 시간동안 시스템과 상호 작용하지 않을 때 시스템이 자동으로 페이지를 엽니다.프로젝트를 마우스 오른쪽 버튼으로 클릭하고 속성 옵션을 선택합니다. 팝업 속성 상자에서 화면 보호기 초과 시간을 초 단위로 설정할 수 있습니다. -1은 화면 보호기가 없음을 의미합니다. 코드를 통해 몇 가지 설정을 할 수도 있습니다. jni/include/entry/EasyUIContext.h를 참조하십시오. 필요한 헤더 파일 #include \"entry/EasyUIContext.h\" Screensaver timeout 시간 설정 //Set the screensaver timeout time to 5 seconds EASYUICONTEXT->setScreensaverTimeOut(5); Screensaver 허용 여부 설정 EASYUICONTEXT->setScreensaverEnable(false); //Turn off screensaver detection EASYUICONTEXT->setScreensaverEnable(true); //Turn on screensaver detection 어플리케이션 시나리오 : 만약 업그레이드 UI에서 스크린세이버로 진입하지 않게 하려면 진입 시 EASYUICONTEXT->setScreensaverEnable(false)를 호출하십시오. Screensaver 실행 EASYUICONTEXT->screensaverOn(); Screensaver 종료 EASYUICONTEXT->screensaverOff(); 현재 Screensaver가 동작중인지 확인 EASYUICONTEXT->isScreensaverOn(); 더 자세한 내용은 Sample Code의 ScreensaverDemo 프로젝트를 참고하십시오. powered by Gitbooklast modified: 2020-12-10 15:45:01 "},"timer.html":{"url":"timer.html","title":"타이머","keywords":"","body":"타이머 어떤 경우에는 정기적으로 특정 작업을 수행해야 할 수도 있습니다. 예를 들어, 정기적으로 하트 비트 패킷을 보내거나, 정기적으로 데이터를 쿼리하여 UI를 새로 고치거나, 몇 가지 폴링 작업을 수행합니다. 이러한 요구 사항이 있는 경우는 타이머가 좋은 선택입니다. 타이머 사용법 타이머사용 편의성을 위해 구조체를 채우는 형태로 타이머를 추가합니다. Logic.cc파일에는 기본적으로 다음과 같은 구조체 배열이 있습니다. /** * Register timer * Just add to this array */ static S_ACTIVITY_TIMEER REGISTER_ACTIVITY_TIMER_TAB[] = { //{0, 6000}, //Timer id=0, Period 6second //{1, 1000}, }; 타이머를 추가하려면 이 구조체 배열에 값을 추가하기만 하면 됩니다. 이 구조체의 정의는 다음과 같습니다. typedef struct { int id; // Timer ID, can not redefine int time; // Timer period unit/ms }S_ACTIVITY_TIMEER; 타이머 로직 코드 추가배열에 타이머를 등록한 후 타이머가 트리거되면 시스템은 해당 Logic.cc파일에서 void onUI_Timer (int id)함수를 호출합니다. 이 타이머의 코드는 다음과 같습니다. 이 함수에 필요한 코드를 추가하십시오. /** * Timer trigger function * It is not recommended to write time-consuming operations in this function, otherwise it will affect UI refresh * @param id * The id of the currently triggered timer is the same as the id at registration * @return true * Keep running the current timer * false * Stop running the current timer */ static bool onUI_Timer(int id){ switch (id) { default: break; } return true; } 이 함수는 기본적으로 Logic.cc파일에 생성됩니다. 구조체 배열에 정의 된 id값과 함수의 파라미터 id는 동일하며, id값에 따라 필요한 조작을 할 수 있습니다. [!Note] 참고 : 각 액티비티의 타이머는 독립적이며 다른 액티비티의 타이머 ID는 동일 할 수 있습니다. 액티비티가 파괴되지 않는 한 등록 된 타이머(액티비티 라이프 사이클참조)는 항상 실행됩니다. 등록 후 수동으로 중지 할 필요가 없으며 액티비티가 종료되면 자동으로 중지됩니다. 예제 다음으로 구체적인 예를 들어 타이머 사용을 설명하겠습니다.정수 변수가 있고 매초 1씩 증가하여 결과를 화면에 표시하는 함수를 구현해야 한다고 가정 해 보겠습니다. 구체적인 구현 과정은 다음과 같습니다. 먼저 UI 파일에 누적 된 결과를 표시할 Text View 컨트롤을 추가합니다. mainLogic.cc의 타이머 배열 구조체를 수정하여 타이머를 등록합니다. 타이머 ID는 1이고 시간 간격은 1초입니다. 시간 단위는 ms입니다. mainLogic.cc에서 정적 정수 변수를 정의하고 0으로 초기화합니다. void onUI_Timer(int id)함수에서 증가 코드를 추가하고 Text View컨트롤에 표시합니다. 컴파일 후 다운로드하여 실행합니다. Sample code 더 자세한 내용은 Sample Code의 TimerDemo 프로젝트를 참고하십시오. powered by Gitbooklast modified: 2020-12-10 17:54:21 "},"how_to_register_timer.html":{"url":"how_to_register_timer.html","title":"타이머 수동 조작","keywords":"","body":"임의의 타이머 시작과 중지 타이머를 추가하는 방법으로 REGISTER_ACTIVITY_TIMER_TAB을 이용하는 방법이 있으나 이 방법은 타이머를 임의로 시작/중지 하기에 충분하지 않아 여기서는 타이머를 추가하는 다른 방법을 알아보겠습니다. Activity class에 제공되는 타이머를 컨트롤하는 세 가지 함수가 있는데, 아래는 각 함수들의 사용 예제입니다. /** * Register timer */ void registerUserTimer(int id, int time); /** * Un-register timer */ void unregisterUserTimer(int id); /** * Reset timer */ void resetUserTimer(int id, int time); logic.cc파일에 타이머가 설정되었는지 확인을 위한 변수를 선언합니다. /** * Whether the timer is registered */ static bool isRegistered = false; #define TIMER_HANDLE 2 그리고, 2개의 버튼을 만듭니다. 이 버튼들은 타이머를 설정하고 해제하는 기능을 수행합니다. static bool onButtonClick_ButtonTimerOn(ZKButton *pButton) { //Register the timer if not registered if (!isRegistered) { mActivityPtr->registerUserTimer(TIMER_HANDLE, 500); isRegistered = true; } return false; } static bool onButtonClick_ButtonTimerOff(ZKButton *pButton) { //If the timer is already registered, cancel the registration if (isRegistered) { mActivityPtr->unregisterUserTimer(TIMER_HANDLE); isRegistered = false; } return false; } [!Warning] 위의 3가지 함수 registerUserTimer, unregisterUserTimer, resetUserTimer를 onUI_Timer 함수에서 호출하지 마십시오. Deadlock의 원인이 됩니다. 예제 코드 예제 코드의 TimerDemo 프로젝트를 참고하십시오. 아래는 Timer Demo의 프리뷰입니다. powered by Gitbooklast modified: 2020-12-09 14:32:33 "},"linux_serial_programming.html":{"url":"linux_serial_programming.html","title":"Linux serial programming","keywords":"","body":"Linux serial programming [!Note] 이 챕터의 목적은 개발자에게 FlywizOS프로젝트의 시리얼 포트 파트의 코드를 이해시키는 것입니다. 또한 우리는 개발자의 쉬운 이해를 위해 실제 코드로 해당 과정을 설명할 것이며, 이 과정이 끝나면 개발자들은 스스로 원하는대로 시리얼 포트를 수정할 수 있을 것입니다. FlywizOS는 Linux system을 기반으로 합니다. 따라서, 우리는 standard Linux programming operation으로 시리얼 포트를 사용할 수 있습니다. 기본 과정 우리는 Linux serial port programming을 5개의 과정으로 나누었습니다 : open serial port, configure serial port, read serial port, write serial port, close serial port. Open serial port #include int fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY); open은 시스템 함수로, node의 오픈을 담당합니다. 위 코드의 의미는 : /dev/ttyS0 시리얼 포트를 readable/writable 속성으로 열기를 시도합니다. 만약 성공한다면 음수가 아닌 값을 리턴하고, 그 값은 시리얼 포트의 descriptor를 나타냅니다. 만약 실패한다면 음수를 리턴하고, 그 값은 error code입니다. /dev/ttyS0 시리얼 포트의 번호로, 윈도우의 시스템의 COM1와 유사합니다. Configure serial port시리얼 포트 오픈 성공 후 Baud rate및 다른 파라미터들로 시리얼 포트를 설정해야합니다. int openUart() { int fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY); struct termios oldtio = { 0 }; struct termios newtio = { 0 }; tcgetattr(fd, &oldtio); //Set the baud rate to 115200 newtio.c_cflag = B115200 | CS8 | CLOCAL | CREAD; newtio.c_iflag = 0; // IGNPAR | ICRNL newtio.c_oflag = 0; newtio.c_lflag = 0; // ICANON newtio.c_cc[VTIME] = 0; newtio.c_cc[VMIN] = 1; tcflush(fd, TCIOFLUSH); tcsetattr(fd, TCSANOW, &newtio); //Set to non-blocking mode, this will be used when reading the serial port fcntl(fd, F_SETFL, O_NONBLOCK); return fd; } [!Note]위는 플랫폼의 기본 시리얼 포트 구성입니다. 특별한 경우가 아니라면 수정할 필요가 없습니다.하드웨어와 드라이버의 한계로 수정하려고 하는 구성이 적합하지 않을 수도 있습니다. Read serial port #include unsigned char buffer[1024] = {0}; int ret = read(fd, buffer, sizeof(buffer)); read는 시스템 함수로 시리얼 포트의 데이터를 읽는 함수입니다. 이 함수는 아래 3개의 파라미터가 필요합니다. 첫 번째 파라미터는 시리얼 포트 descriptor로, open함수의 리턴 값입니다. 두 번째 파라미터는 buffer포인터로 읽은 시리얼 데이터가 저장됩니다. 세 번째 파라미터는 buffer의 크기로, 읽어들일 수 있는 데이터의 최대 값을 나타냅니다. 만약 리턴 값이 0보다 크다면 시리얼 포트의 데이터를 정상적으로 읽었다는 의미이며 동시에 리턴값은 읽은 데이터의 byte수 입니다.만약 리턴 값이 0보다 작거나 같다면, 데이터가 없거나 에러가 발생했다는 의미입니다. [!Note]read는 오직 시리얼 포트로 수신된 순차적인 데이터만을 읽습니다. 그러나, 한 번에 모든 데이터를 읽어드리는 것을 보장하지는 않습니다. 예를 들어, 시리얼 포트로 1000bytes를 받았고, buffer의 크기가 1024로 비록 수신된 데이터보다는 크지만, 처음 read 시 오직 일부분만 읽어올 수 있어 모든 데이터를 읽기 위해서는 여러번에 걸쳐 read를 해야합니다. Write serial port #include unsigned char buffer[4] = {0}; buffer[0] = 0x01; buffer[1] = 0x02; buffer[2] = 0x03; buffer[3] = 0x04; int ret = write(fd, buffer, sizeof(buffer)); write는 시스템 함수로, 시리얼 포트롤 데이터로 전송합니다. 이 함수는 아래 3개의 파라미터가 필요합니다. 첫 번째 파라미터는 시리얼 포트 descriptor로, open함수의 리턴 값입니다. 두 번째 파라미터는 전송하려는 buffer의 포인터입니다. 세 번째 파라미터는 전송하려는 buffer의 크기입니다. 만약 리턴 값이 0보다 크다면 리턴 값은 세 번째 파라미터의 값과 같으며 전송 성공을 의미합니다.만약 리턴 값이 0보다 작거나 같다면 예외가 발생했다는 의미입니다. Close serial port #include close(fd); close는 시스템 함수이고, 필요한 파라미터는 시리얼 포트 descriptor입니다. 종합 아래는 간단한 Linux serial port programming의 예제입니다. 위에 언급했던 기본 기능이 모두 사용되었습니다. #include #include #include int main(int argc, char** argv) { int fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY); if (fd 0) { //Output the read data to the log in turn for (int i = 0; i 소프트웨어에서 시리얼 포트의 안정적인 통신을 보장하는 방법 위의 방법을 적용하여 공식적인 제품을 개발할 때, 우리는 종종 아래와 같은 문제에 직면하게 됩니다. 시리얼 통신은 간섭을 받을 수 있어 신뢰할 수 없습니다.그러므로 정형화된 통신 프로토콜을 사용해야 합니다. 이 프로토콜은 일반적으로 frame header, frame end, frame content, checkout, 등을 포함합니다.프로토콜을 사용하면 데이터의 무결성이 보장되어 시리얼 통신을 안정적으로 만들 수 있습니다. 예 :프로토콜의 프레임 헤더가 0xFF, 0x55이고, 뒤의 8bytes로 프레임이 완성된다면, 위의 코드는 아마도 아래처럼 수정될 것입니다. //Only the key parts are listed, the rest of the code is omitted while (true) { unsigned char buffer[1024] = {0}; int ret = read(fd, buffer, sizeof(buffer)); if (ret > 0) { if ((buffer[0] == 0xFF) && (buffer[1] == 0x55)) { if (ret == 10) { LOGD(\"Read a frame of data correctly\"); } else if (ret 위의 코드로 실제 빈번히 데이터를 주고 받는 테스트를 하면, 프로토콜 헤더는 맞지만 프레임의 크기가 틀린 경우를 자주 보게 될 것입니다. 그 이유는 아마 Linux system scheduling에 있거나, 다른 곳에 있을 것입니다. read함수는 한 번에 모든 데이터를 읽는 것을 보장하지 않습니다. 모든 데이터를 읽어드리기 위해서는 여러차례 read함수를 호출해야 하고, 이는 프레임 데이터가 나누어져 읽혀지기 때문에 프로토콜에 맞게 하나의 유효한 프레임을 찾아야 합니다. 이를 위해 코드가 조금 더 복잡해 지겠지만, 이는 필요한 과정입니다. 이러한 분석에 근거하여 수정된 코드는 아래와 같습니다. //Increase the scope of the buffer array so that the data will not be cleared in the while loop unsigned char buffer[1024] = {0}; // Add a `legacy` variable to indicate the length of data left in the buffer int legacy = 0; while (true) { //According to the size of the legacy, adjust the start pointer and size of the buffer to prevent data overwriting int ret = read(fd, buffer + legacy, sizeof(buffer) - legacy); if (ret > 0) { if ((buffer[0] == 0xFF) && (buffer[1] == 0x55)) { if ((ret + legacy) == 10) { LOGD(\"Read a frame of data correctly\"); //clean legacy legacy = 0; } else if (ret 실제 제품에서 우리는 시리얼 통신만을 처리하는 것이 아니라, 화면상의 여러 컨트롤 등에 대한 처리도 필요합니다. 위의 예제는 main함수에서 시작되고, while루프에서 시리얼 데이터를 처리하기 때문에 다른 처리를 할 수가 없습니다. 그러나 Linux system은 multithreading기능을 지원하기 때문에 새로운 thread를 만들고, 그 thread에 while루프 부분을 넣는다면, 동시에 다른 컨트롤들에 대한 처리도 가능해질 것입니다. 요약 Linux의 시리얼 통신 프로그래밍을 할 때 많은 세부 문제들을 처리해야 합니다. 그리고, FlywizOS에서는 문제 해결을 위해 일반 코드를 제공합니다. 시리얼 포트의 open, close, read, write operations 나뉘어진 프로토콜 데이터에 대한 처리 통합 데이터 콜백 인터페이스 제공 이 챕터의 소스코드는 open source입니다. 개발자가 새로운 FlywizOS프로젝트를 만들면 프로젝트의 uart폴더에 이 코드가 있을 것입니다. powered by Gitbooklast modified: 2020-12-09 15:03:32 "},"serial_introdoction.html":{"url":"serial_introdoction.html","title":"소개","keywords":"","body":"시리얼 포트 소개 아래 그림은 가장 간단한 통신 모델입니다. LCD와 MCU는 시리얼 포트를 통해 통신하며 정해진 프로토콜로 서로 상호 작용할 수 있습니다. 여기서 주목할 점이 있는데, 기존의 시리얼 포트 LCD는 슬레이브 장치로 사용되고 MCU를 통해 해당 명령을 전송하여 제어합니다. 그러나 FlywizOS의 시리얼 포트 LCD는 호스트처럼 자체적으로 운영이 가능하며 상호 작용할 수 있습니다. 통신과 관련된 코드를 처음부터 개발하려면 많은 시간이 소요될 수 있습니다. 개발 프로세스를 단순화하고 개발자가 비즈니스 로직 개발에 더 많은 주의를 기울일 수 있도록 FlywizOS IDE는 새 프로젝트를 빌드 할 때 자동으로 시리얼 통신 코드를 생성합니다. 동시에 프로토콜 데이터 및 액티비티의 상호 작용을 위한 콜백 인터페이스도 제공합니다. 개발자가 UI액티비티의 데이터 표시에 더 많은 관심을 기울일 수 있도록 통신 부분은 프레임 워크에 의해 자동으로 완료됩니다. 통신 프레임 워크의 프로토콜 분석 부분은 개발자가 사용하는 통신 프로토콜에 따라 변경되어야 하며, 다음 장의 통신 프레임 워크 설명에서는 원리와 수정이 필요한 부분에 대해 집중적으로 살펴 보겠습니다. 그리고 시리얼 통신 예제의 장에서는 몇 가지 사례를 통해 통신 프레임 워크에 대한 이해를 심화합니다. powered by Gitbooklast modified: 2020-12-10 15:09:27 "},"serial_framework.html":{"url":"serial_framework.html","title":"통신 프레임워크 설명","keywords":"","body":"통신 프레임워크 설명 이 장에서 중요하게 살펴볼 부분은 통신 프레임 워크의 구현 원리입니다. 이론적인 부분이 비교적 많습니다. 처음에는 통신 모델에 대한 대략적인 개요에 대해 이해하고, 제공되는 예제를 직접 수행해 본 후 다시 돌아와 원리를 이해해 보겠습니다. 이러한 과정을 거치고 실제 수행을 하다보면 원하는 방식으로 프로토콜을 정의하고 사용할 수 있을 것입니다. 프레임 소프트웨어 APP 부분은 두 개의 계층으로 나뉩니다. UART - 프로토콜 분석 및 캡슐화, 시리얼 포트 HAL 계층 UartContext：시리얼 포트 컨트롤, 송수신 인터페이스를 제공하는 시리얼 포트의 물리적 제어 계층 ProtocolData：통신 프로토콜에서 변환 된 실제 변수를 저장하는 데 사용되는 통신 데이터 구조 정의 ProtocolSender：데이터를 캡슐화하여 전송 ProtocolParser：데이터의 프로토콜 분석을 완료 한 후 분석 된 데이터를 ProtocolData의 데이터 구조체에 저장하는 동시에 어플리케이션이 시리얼 데이터 변경을 모니터링 할 수 있도록 콜백 인터페이스를 관리합니다. APP - 어플리케이션 인터페이스 계층 ProtocolParser에서 제공하는 인터페이스를 통해 수신 및 모니터링 할 시리얼 포트 데이터를 등록하여 시리얼 포트의 업데이트 된 ProtocolData를 얻습니다. ProtocolSender에서 제공하는 인터페이스를 통해 MCU에 명령 정보 전송 이 과정을 재-정의해 보겠습니다 : receive 및 send 두 프로세스가 위아래로 진행되고 각 레이어의 기능이 비교적 명확하다는 것을 알 수 있습니다. 실제 코드에 해당하는 구체적인 과정은 다음과 같습니다. 수신 또는 송신 프로세스에 관계없이 시리얼 포트에 대한 최종 읽기 및 쓰기 작업은 UartContext를 통해 이루어집니다. 이것은 표준화 된 프로세스이므로 일반적으로 UartContext를 수정할 필요가 없습니다. 물론 필요한 경우에 수정할 수 있습니다. 이 시점에서 우리는 이 통신 모델에 대한 일반적인 이해를 가지고 있을 것이고, 이후 구체적인 코드의 구현을 살펴볼 것입니다. 프로토콜 수신부 사용 및 수정 방법 통신 프로토콜 형식 수정 여기서는 보다 일반적인 통신 프로토콜의 예를 제공합니다. frame header(2bytes) command(2bytes) length of data(1byte) command data(N) verification(1byte, option) 0xFF55 Cmd len data checksum CommDef.h 파일은 동기화 프레임 헤더 정보와 최소 데이터 패킷 크기 정보를 정의합니다. // When you need to print the protocol data, open the following macro //#define DEBUG_PRO_DATA // Support checksum verification, open the following macro //#define PRO_SUPPORT_CHECK_SUM /* SynchFrame CmdID DataLen Data CheckSum (Option) */ /* 2Byte 2Byte 1Byte N Byte 1Byte */ // Minimum length with CheckSum: 2 + 2 + 1 + 1 = 6 // Minimum length without CheckSum: 2 + 2 + 1 = 5 #ifdef PRO_SUPPORT_CHECK_SUM #define DATA_PACKAGE_MIN_LEN 6 #else #define DATA_PACKAGE_MIN_LEN 5 #endif // Sync frame header #define CMD_HEAD1 0xFF #define CMD_HEAD2 0x55 ProtocolParser.cpp파일 /** * Function: Analyze protocol * Parameters: pData - protocol data, len - data length * Return value: the length of the actual protocol */ int parseProtocol(const BYTE *pData, UINT len) { UINT remainLen = len; // Remaining data length UINT dataLen; // Packet length UINT frameLen; // Frame length /** * The following parts need to be modified according to the protocol format to parse out the data of each frame */ while (remainLen >= DATA_PACKAGE_MIN_LEN) { // Find the data header of a frame while ((remainLen >= 2) && ((pData[0] != CMD_HEAD1) || (pData[1] != CMD_HEAD2))) { pData++; remainLen--; continue; } if (remainLen remainLen) { // Incomplete data frame break; } // To print a frame of data, open the DEBUG_PRO_DATA macro in the CommDef.h file when needed #ifdef DEBUG_PRO_DATA for (int i = 0; i 위의 분석 과정은 약간 복잡합니다. 먼저 아래 그림을 본 후 분석하면 이해하기 더 쉬울 것입니다. 데이터 패킷은 0개 또는 여러 개의 프레임 데이터를 포함 할 수 있습니다. 아래 그림에서는 3개의 프레임 데이터를 찾을 수 있습니다. 그리고 아직 데이터가 5byte 부족한 불완전한 데이터 프레임도 볼 수 있습니다. 이 불완전한 데이터 프레임은 다음 데이터 패킷에 이어지게 됩니다. 프로토콜 헤더를 수정 // 1.Modify the definition of the protocol header. If the length of the protocol header changes, pay attention to modifying the // statement of the protocol header judgment part. #define CMD_HEAD1 0xFF #define CMD_HEAD2 0x55 // 2.You need to modify this when the length of the protocol header changes. while ((mDataBufLen >= 2) && ((pData[0] != CMD_HEAD1) || (pData[1] != CMD_HEAD2))) 프로토콜 길이 위치 변경 또는 길이 계산 방법 수정 // Here pData[4] represents the fifth data is the length byte, if it changes, please modify it here. dataLen = pData[4]; // The frame length is generally the data length plus the head and tail length. If the length calculation method passed in the // agreement changes, modify this part. frameLen = dataLen + DATA_PACKAGE_MIN_LEN; 프로토콜 검증 방법이 변경되는 경우 /** * By default, we turn off checksum verification. If you need to support checksum verification, open the PRO_SUPPORT_CHECK_SUM * macro in the CommDef.h file * When the verification is different, the verification method needs to be modified. * 1.Check the content changes to modify this location * if (getCheckSum(pData, frameLen - 1) == pData[frameLen - 1]) * 2.Check the calculation formula changes to modify the content in the getCheckSum function */ /** * Get checksum code */ BYTE getCheckSum(const BYTE *pData, int len) { int sum = 0; for (int i = 0; i 데이터 프레임 수신이 완료되면 프로그램은 procParse를 호출하여 분석합니다. // Support checksum verification, open PRO_SUPPORT_CHECK_SUM macro in CommDef.h file when needed #ifdef PRO_SUPPORT_CHECK_SUM // Get checksum code if (getCheckSum(pData, frameLen - 1) == pData[frameLen - 1]) { // Parse a frame of data procParse(pData, frameLen); } else { LOGE(\"CheckSum error!!!!!!\\n\"); } #else // Parse a frame of data procParse(pData, frameLen); #endif 통신 프로토콜 데이터를 UI컨트롤과 연결하는 방법 이전 프로토콜 프레임워크를 계속하여 procParse의 구문 분석 부분에 들어갑니다.키 코드는 여기에 있습니다 : ProtocolParser.cpp파일을 열고 void procParse (const BYTE * pData, UINT len)를 찾습니다. /* * Protocol analysis * Input parameters : * pData: Start address of a frame of data * len: Length of frame data */ void procParse(const BYTE *pData, UINT len) { /* * Parse the Cmd value to obtain the data and assign it to the sProtocolData structure */ switch (MAKEWORD(pData[2], pData[3])) { case CMDID_POWER: sProtocolData.power = pData[5]; LOGD(\"power status:%d\",sProtocolData.power); break; } notifyProtocolDataUpdate(sProtocolData); } 위의 MAKEWORD (pData [2], pData [3])는 프로토콜 예제에서 Cmd 값을 나타냅니다.데이터 분석이 완료되면 notifyProtocolDataUpdate를 통해 UI에 업데이트를 알립니다. 이 부분은 아래 UI 업데이트 부분을 참고하시기 바랍니다. 데이터 구조위의 프로토콜은 sProtocolData구조로 구문 분석되며 sProtocolData는 MCU(또는 기타 장치)의 시리얼 포트에서 보낸 데이터 값을 저장하는 데 사용되는 정적 변수입니다. 이 데이터 구조는 ProtocolData.h 파일에 있습니다. 여기에서 전체 프로젝트에서 사용하는 통신 변수를 추가 할 수 있습니다. typedef struct { // You can add protocol data variables here BYTE power; } SProtocolData; UI 업데이트IDE가 Activity.cpp를 생성 할 때 UI 액티비티의 registerProtocolDataUpdateListener가 완료됩니다. 이는 데이터가 업데이트될 때 등록된 함수로 데이터를 수신함을 의미합니다. static void onProtocolDataUpdate(const SProtocolData &data) { // Serial data callback interface if (mProtocolData.power != data.power) { mProtocolData.power = data.power; } if (mProtocolData.eRunMode != data.eRunMode) { mProtocolData.eRunMode = data.eRunMode; mbtn_autoPtr->setSelected(mProtocolData.eRunMode == E_RUN_MODE_MANUAL); if (mProtocolData.eRunMode != E_RUN_MODE_MANUAL) { mbtn_external_windPtr->setText(mProtocolData.externalWindSpeedLevel); mbtn_internal_windPtr->setText(mProtocolData.internalWindSpeedLevel); } } ... } 코드에는 페이지의 정적 변수 인 mProtocolData변수가 있습니다. onUI_init()중에 초기화됩니다. 예 : static SProtocolData mProtocolData; static void onUI_init() { //Tips :Add the display code for UI initialization here, example : mText1->setText(\"123\"); mProtocolData = getProtocolData(); // Initialize the structure of the serial port data. //Start the UI display of the initial page } 시리얼 데이터 전송 ProtocolSender.cpp를 엽니다.APP계층이 MCU(또는 기타 장치)에 데이터를 보내야하는 경우 sendProtocol을 직접 호출하는 것으로 충분합니다.특정 프로토콜 캡슐화는 sendProtocol함수에 의해 완료됩니다. 사용자는 자신의 프로토콜 요구 사항에 따라 이 부분의 코드를 수정할 수 있습니다. /** * Need to be spliced according to the protocol format, the following is just a template */ bool sendProtocol(const UINT16 cmdID, const BYTE *pData, BYTE len) { BYTE dataBuf[256]; dataBuf[0] = CMD_HEAD1; dataBuf[1] = CMD_HEAD2; // Sync header dataBuf[2] = HIBYTE(cmdID); dataBuf[3] = LOBYTE(cmdID); // Command ID dataBuf[4] = len; UINT frameLen = 5; // Data for (int i = 0; i send(dataBuf, frameLen); } 액티비티에서 버튼을 누르면 동작 가능합니다. BYTE mode[] = { 0x01, 0x02, 0x03, 0x04 }; sendProtocol(0x01, mode, 4); powered by Gitbooklast modified: 2020-12-14 10:16:32 "},"serial_example.html":{"url":"serial_example.html","title":"시리얼 통신 예제","keywords":"","body":"시리얼 통신 예제 여기서는 먼저 시리얼 통신의 주된 4가지 포인트를 살펴보겠습니다. 데이터 수신 데이터 분석 데이터 디스플레이 데이터 전송 데이타 분석 부분은 비교적 복잡하고, 특정 통신 프로토콜에 따라 변경되야 합니다. 이 장에서는 이론적인 내용에 대해 이야기하지 않고, 몇 가지 실제 사례를 제공합니다. 사례 1 여기서 우리는 이전에 구현했던 간단한 통신 프로그램을 예로 들어보겠습니다. 완전한 코드는 Sample Code의 UartDemo 프로젝트에서 확인할 수 있습니다. 달성하고자하는 최종 효과는 디스플레이에서 미터기의 회전을 제어하기 위해 시리얼 포트를 통해 명령을 보내는 것입니다.UI 렌더링은 다음과 같습니다. 미터기의 회전을 제어하려면 기존 코드 중 세 곳만 수정하면됩니다. 1) 앞서 소개 한 프로토콜 형식을 다시 살펴보고 여기에 0x0001값에 해당하는 자체 프로토콜 명령 CMDID_ANGLE을 추가합니다. Protocol header(2bytes) Command(2bytes) length of data(1byte) data(N) checksum(1byte option) 0xFF55 0x0001（See belowCMDID_ANGLE） 1 angle checksum 프로토콜 데이터 구조에 1개의 변수를 추가합니다. ProtocolData.h를 참조하십시오. /******************** CmdID ***********************/ #define CMDID_POWER 0x0 #define CMDID_ANGLE 0x1 // new command ID /**************************************************/ typedef struct { BYTE power; BYTE angle; // Added variable to save pointer angle value } SProtocolData; 2) 이전에 정의된 프로토콜 형식을 계속 사용하고 있어 프로토콜 구문 분석 부분을 변경할 필요가 없습니다. procParse에서 해당 CmdID 값만 처리하면 됩니다. /** * Parse each frame of data */ static void procParse(const BYTE *pData, UINT len) { // CmdID switch (MAKEWORD(pData[3], pData[2])) { case CMDID_POWER: sProtocolData.power = pData[5]; break; case CMDID_ANGLE: // New part, save angle value sProtocolData.angle = pData[5]; break; } // Notify protocol data update notifyProtocolDataUpdate(sProtocolData); } 3) 프로토콜 데이터를 수신하는 액티비티의 콜백 함수를 살펴 보겠습니다. logic/mainLogic.cc를 참조하십시오. static void onProtocolDataUpdate(const SProtocolData &data) { // Serial data callback function // Set the rotation angle of the pointer mPointer1Ptr->setTargetAngle(data.angle); } 위의 과정을 완료 한 후 MCU를 통해 해당 명령을 보드에 전송하면 미터기가 회전하는 것을 볼 수 있습니다. 간단하게 구현하기 위해 이 프로그램에서는 첵섬 확인을 수행하지 않으며 프로토콜 데이터는 다음과 같습니다. protocol header CmdID length of data angle data 0xFF 0x55 0x00 0x01 0x01 angle CommDef.h 파일에서 DEBUG_PRO_DATA매크로를 열고 수신 된 프로토콜 데이터를 출력할 수 있습니다. 이 시점에서 시리얼 포트는 데이터 수신 ---> 데이터 분석 ---> 데이터 표시로 하나의 커맨드에 대한 처리가 완성되었습니다. 마지막으로 시리얼 포트 데이터 전송을 시뮬레이션해 보겠습니다. 제공하는 프로그램에서 타이머가 실행되고 데이터 전송이 2초마다 시뮬레이션됩니다. static bool onUI_Timer(int id) { // Simulate sending serial data BYTE data = rand() % 200; sendProtocol(CMDID_ANGLE, &data, 1); return true; } 위의 코드는 실제 각도 값 설정을 시뮬레이션하기 위한 것입니다. 보드에서 통신 시리얼 포트의 TX와 RX를 단락시켜 자발 송수신을 구현할 수 있으며, 미터기가 회전하는 것을 볼 수 있습니다. 여기까지 시리얼 포트 데모 프로그램 소개가 완료되었습니다. 개발자는 데모 프로그램을 컴파일하고 보드에 레코딩하여 효과를 확인할 수 있습니다. 그런 다음 이를 기반으로 몇 가지 프로토콜을 추가하여 테스트하고 전체 통신 프로세스에 익숙해집시다. powered by Gitbooklast modified: 2020-12-10 14:29:51 "},"serial_configuration.html":{"url":"serial_configuration.html","title":"시리얼 포트 구성","keywords":"","body":"시리얼 포트를 구성하는 방법 시리얼 포트 번호 선택 소프트웨어와 하드웨어의 설계 호환성으로 인해 소프트웨어의 일련 번호가 하드웨어의 일련 번호 식별과 다를 수 있습니다. 구체적인 관계는 다음과 같습니다. FW9311s Series platform Software serial port number Hardware serial port number ttyS0 UART1 ttyS1 UART2 FW9606 Series platform Software serial port number Hardware serial port number ttyS0 UART0 ttyS1 UART1 ttyS2 UART2 시리얼 포트 Baud rate 구성 새 프로젝트를 만들 때 Baud rate를 구성합니다. 프로젝트 속성에서 Baud rate 구성 프로젝트를 마우스 오른쪽 버튼으로 클릭하고 팝업 메뉴에서 Property를 선택하면 다음 속성 상자가 나타납니다. 시리얼 포트 열기 및 닫기 jni/Main.cpp를 엽니다. 프로그램이 초기화되고 종료될 때 시리얼 포트가 열리고 닫히는 것을 볼 수 있습니다. void onEasyUIInit(EasyUIContext *pContext) { LOGD(\"onInit\\n\"); // open serial port UARTCONTEXT->openUart(CONFIGMANAGER->getUartName().c_str(), CONFIGMANAGER->getUartBaudRate()); } void onEasyUIDeinit(EasyUIContext *pContext) { LOGD(\"onDestroy\\n\"); // close serial port UARTCONTEXT->closeUart(); } powered by Gitbooklast modified: 2020-12-10 14:08:39 "},"multiuart.html":{"url":"multiuart.html","title":"다중 시리얼 포트 구성","keywords":"","body":"다중 시리얼 포트 구성 기본적으로 만들어지는 프로젝트는 오직 하나의 시리얼 포트만을 지원하지만, 필요한 경우 2개 또는 그 이상의 시리얼 포트를 사용할 수 있습니다. 먼저 DoubleUartDemo 예제를 다운로드 하십시오. 이 예제 안에 다중 시리얼 포트를 지원하는 프로젝트에 관한 코드가 담겨있습니다. 변경 사항 변경 사항은 아래와 같습니다. Uart의 몇몇 코드들이 수정되었습니다. 그래서 project properties에서 설정한 속성은 더 이상 유효하지 않습니다. 사용하는 시리얼 포트의 넘버와 Baud rate는 jni/uart/UartContext.cpp파일의 init()함수를 참고해서 수정하십시오. void UartContext::init() { uart0 = new UartContext(UART_TTYS0); uart0->openUart(\"/dev/ttyS0\", B9600); uart1 = new UartContext(UART_TTYS1); uart1->openUart(\"/dev/ttyS1\", B9600); } 시리얼 포트로 데이타를 보냅니다. unsigned char buf[2] = {1, 1}; sendProtocolTo(UART_TTYS1, 1, buf, 2); //Send to TTYS1 serial port unsigned char buf[2] = {0}; sendProtocolTo(UART_TTYS0, 1, buf, 2);//Send to TTYS0 serial port 시리얼 포트 데이터를 받는 방법은 기존 프로젝트와 동일합니다.만약 어디에서 온 시리얼 포트 데이타인지를 구분할 필요가 있다면 SProtocolData structure에 멤버 변수를 추가하여 구분을 할 수 있습니다.uart/ProtocolData.h변경 typedef struct { BYTE power; int uart_from; //From which serial port } SProtocolData; uart/ProtocolParser.cpp변경 /** * Analyze each frame of data */ static void procParse(int uart, const BYTE *pData, UINT len) { // CmdID switch (MAKEWORD(pData[3], pData[2])) { case CMDID_POWER: sProtocolData.power = pData[5]; break; } sProtocolData.uart_from = uart; //Identify which serial port the frame comes from // Notify protocol data update notifyProtocolDataUpdate(sProtocolData); } Logic.cc에서 uart_from필드를 확인하여 어떤 시리얼 포트로부터 수신된 데이타인지 판단할 수 있습니다. static void onProtocolDataUpdate(const SProtocolData &data) { LOGD(\"onProtocol %d\", data.uart_from); char buf[128] = {0}; snprintf(buf, sizeof(buf), \"Receive serial port %d data\", data.uart_from); mTextview1Ptr->setText(buf); } 예제 코드 예제 코드의 DoubleUartDemo프로젝트를 참고하십시오. powered by Gitbooklast modified: 2020-12-09 15:35:58 "},"wifi.html":{"url":"wifi.html","title":"WIFI 설정","keywords":"","body":"WIFI 설정 액티비티 시작 EASYUICONTEXT->openActivity(\"WifiSettingActivity\"); WiFi 작동 함수 설명 WifiManager 객체 가져오기 #include \"net/NetManager.h\" WifiManager *pWM = NETMANAGER->getWifiManager(); // You can define a macro to facilitate the following function calls #define WIFIMANAGER NETMANAGER->getWifiManager() 기기가 WIFI를 지원하는지 확인 WIFIMANAGER->isSupported(); WIFI가 On인지 확인 WIFIMANAGER->isWifiEnable(); WIFI 켜기 WIFIMANAGER->enableWifi(true); WIFI 검색 WIFIMANAGER->startScan(); WIFI 연결 WIFIMANAGER->connect(ssid, pw); WIFI 연결 해제 WIFIMANAGER->disconnect(); WIFI가 연결되었는지 확인 WIFIMANAGER->isConnected(); 연결된 WIFI 정보 가져오기 WIFIMANAGER->getConnectionInfo(); WIFI정보 모니터링 함수 등록 및 등록해제 void addWifiListener(IWifiListener *pListener); void removeWifiListener(IWifiListener *pListener); Sample code 더 자세한 내용은 Sample Code의 NetDemo 프로젝트를 참고하세요. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"wifi_ap.html":{"url":"wifi_ap.html","title":"Hotspot 설정","keywords":"","body":"Hotspot 설정 액티비티 시작 EASYUICONTEXT->openActivity(\"SoftApSettingActivity\"); Hotspot 작동 함수 설명 SoftApManager 객체 가져오기 #include \"net/NetManager.h\" SoftApManager *pSAM = NETMANAGER->getSoftApManager(); // You can define a macro to facilitate the following functino calls #define SOFTAPMANAGER NETMANAGER->getSoftApManager() Hotspot 켜기 SOFTAPMANAGER->setEnable(true); Hotspot이 on인지 확인 SOFTAPMANAGER->isEnable(); 현재 hotspot 상태 가져오기 SOFTAPMANAGER->getSoftApState(); // There are the following states E_SOFTAP_DISABLED // Disabled E_SOFTAP_ENABLING // During tunning on E_SOFTAP_ENABLED // Turn on successfully E_SOFTAP_DISABLING // During tunning off E_SOFTAP_ENABLE_ERROR // Turn on failed Hotspot 이름 및 패스워드 설정 SOFTAPMANAGER->setSsidAndPwd(\"zkswe\", \"abcd1234\"); Hotspot 이름 및 패스워드 가져오기 SOFTAPMANAGER->getSsid(); SOFTAPMANAGER->getPwd(); Hotspot 상태 모니터링함수 등록 및 해제 void addSoftApStateListener(ISoftApStateListener *pListener); void removeSoftApStateListener(ISoftApStateListener *pListener); powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"audio.html":{"url":"audio.html","title":"Audio 플레이","keywords":"","body":"Music player ZKMediaPlayer::E_MEDIA_TYPE_AUDIO타입의 ZKMediaPlayer 클래스 오브젝트를 생성합니다 static ZKMediaPlayer sPlayer(ZKMediaPlayer::E_MEDIA_TYPE_AUDIO); 메세지 모니터링 함수를 등록합니다. // The message monitoring interface is as follows class PlayerMessageListener : public ZKMediaPlayer::IPlayerMessageListener { public: virtual void onPlayerMessage(ZKMediaPlayer *pMediaPlayer, int msg, void *pMsgData) { switch (msg) { case ZKMediaPlayer::E_MSGTYPE_ERROR_INVALID_FILEPATH: case ZKMediaPlayer::E_MSGTYPE_ERROR_MEDIA_ERROR: // Error message break; case ZKMediaPlayer::E_MSGTYPE_PLAY_STARTED: // Start playback message break; case ZKMediaPlayer::E_MSGTYPE_PLAY_COMPLETED: // Stop playback message break; } } }; static PlayerMessageListener sPlayerMessageListener; // Register message monitoring sPlayer.setPlayerMessageListener(&sPlayerMessageListener); 멤버 함수 설명 sPlayer.play(\"/mnt/extsd/music/test.mp3\"); // Play the file in the specified path sPlayer.pause(); // Pause playback sPlayer.resume(); // Resume playback sPlayer.seekTo(int msec); // Jump to msec time to play, msec unit: ms sPlayer.stop(); // Stop playback sPlayer.isPlaying(); // Is it playing?, return type is bool sPlayer.getDuration(); // Get the total time of current playing music sPlayer.getCurrentPosition(); // Get the current playing time of the currently playing song sPlayer.setVolume(0.5, 0.5); // Set media volume, volume range: 0.0 ~ 1.0 [!Note] 오디오 파일의 재생시간이 너무 짧을 경우 플레이가 불가능할 수 있습니다. Sample Code의 MusicDemo 프로젝트 참고하십시오 powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"thread.html":{"url":"thread.html","title":"Thread","keywords":"","body":"Thread 시스템은 pthread를 지원합니다. pthread 인터페이스를 이해하면 posix 인터페이스를 사용하여 thread를 구현할 수도 있습니다. 또한 pthread에 대한 래퍼 클래스도 제공합니다. 여기에는 다음 세 부분이 포함됩니다. Thread.h：Thread class Mutex.h：Mutex class Condition.h：Condition class 사용법 헤더 파일을 인클루드한 후 Thread클래스를 상속하고 virtual bool threadLoop()함수를 구현합니다. 또한 필요에 따라 readyToRun()함수를 구현합니다. #include class MyThread: public Thread { public: /** * After the thread is created successfully, this function will be called, and some initialization operations can be done * in this function * return true Continue thread * false Exit thread */ virtual bool readyToRun() { LOGD(\"Thread has been created\"); return true; } /** * Thread loop function * * return true Continue thread loop * false Exit thread */ virtual bool threadLoop() { LOGD(\"Thread loop function\"); //Check if there is a request to exit the thread, if so, return false and exit the thread immediately if (exitPending()) { return false; } //Accumulate the count and display it on the screen loop_count += 1; mTextView2Ptr->setText(loop_count); //To observation, add sleep 500ms here usleep(1000 * 500); //Return true, continue the next thread loop return true; } }; Thread object 인스턴스화 static MyThread my_thread; Thread 시작 //Call the run function of the thread class to start the thread //The parameter is the thread name, which can be arbitrarily specified. my_thread.run(\"this is thread name\"); Thread 종료 Thread클래스는 thread의 종료를 요청하는 동기식과 비동기식의 두 가지 함수를 제공하며 차이점은 다음과 같습니다. void requestExitAndWait() //Request to exit the thread and wait. The function does not return until the thread completely exits my_thread.requestExitAndWait(); void requestExit() //Request to exit the thread, the function returns immediately after sending the request but at this time, it does not mean //that the thread has also exited my_thread.requestExit(); 위의 두 함수 중 하나를 호출 한 후 threadLoop함수에서 bool exitPending()멤버 함수를 사용하여 스레드 종료 요청이 있는지 확인할 수 있습니다. virtual bool threadLoop() { LOGD(\"Thread loop function\"); //Check if there is a request to exit the thread, if so, return false and exit the thread immediately if (exitPending()) { return false; } return true; } [!Note] 위의 함수는 thread를 강제로 종료하지 않고 thread 종료를 요청하는 표시를 추가합니다. threadLoop함수에서 특정 작업을 수행하고 있고 threadLoop함수가 종료되지 않은 경우 thread가 중지되지 않습니다. 올바른 접근 방식은 threadLoop에서 thread 종료 요청을 확인하거나 종료 조건을 확인한 다음 false를 반환하는 것입니다. [!Warning] threadLoop함수에서 requestExitAndWait 및 requestExit 함수를 호출하는 것은 교착 상태를 유발할 수 있어 금지되어 있습니다. Thread가 실행 중인지 확인if (my_thread.isRunning()) { mTextView4Ptr->setText(\"Now running\"); } else { mTextView4Ptr->setText(\"Already stop\"); } Thread 프로세스 위의 단계를 순서도와 함께 이해하면 더 쉽고 깊게 이해가 가능합니다. Sample code 더 자세한 내용은 Sample Code의 ThreadDemo 프로젝트를 참고하십시오. powered by Gitbooklast modified: 2020-12-10 16:51:01 "},"mutex.html":{"url":"mutex.html","title":"Mutex","keywords":"","body":"Mutex/lock 다른 챕터에서 소개했던 thread는 어떤 경우에 프로그램에 버그를 일으킬 수 있습니다.Multi-threaded 프로그래밍에서 이러현 상황은 매우 일반적입니다.쉬운 이해를 위해 아래의 코드로 이 상황을 설명하겠습니다.struct Student를 전역 변수로 선언 후 2개의 thread를 정의합니다. A thread는 student변수에 값을 할당하고, B thread는 student의 값을 복사하여 각 멤버변수의 값을 로그로 출력합니다. Question : 만약 두 thread가 동시에 시작되면 B thread에서 출력되는 결과는 어떻게 될까요? #include struct Student { char name[24]; int age; int number; }; struct Student student = {0}; class AThread: public Thread { public: virtual bool threadLoop() { snprintf(student.name, sizeof(student.name), \"David\"); student.age = 10; student.number = 20200101; return true; } }; class BThread: public Thread { public: virtual bool threadLoop() { struct Student s = student; LOGD(\"name : %s\", s.name); LOGD(\"age : %d\", s.age); LOGD(\"student id number : %d\", s.number); return true; } }; static AThread athread; static BThread bthread; 먼저 우리가 원하는 결과는 아래와 같습니다. name：David age：10 student id number：20200101 그러나 실제로 많은 테스트를 할 경우, 대부분의 결과는 우리가 예상했던 결과를 출력하지만 아래와 같은 결과가 출력되는 경우도 발생합니다. name： age：0 student id number：0 name：xiaoming age：0 student id number：0 name：xiaoming age：10 student id number：0 만약 프로그램에서 \"abnormal\"한 결과가 나온다면, 이것은 버그로 판단할 수 있습니다. 원인 분석 Multiple threads 프로그램에서 thread의 실행 순서는 시스템의 스케쥴링에 의해 결졍됩니다. A thread의 instructions를 모두 실행한 후 B thread의 instruction을 실행하고, 다시 A thread의 instructions를 실행할 수도 있습니다. 위의 예제에서 student변수에 완전한 값을 할당하기 위한 3개의 statements가 있습니다. 만약 첫 statement만 실행되었을 때(name의 값만 할당됨), 시스템이 B thread로 스위칭을 했습니다. 그러면 이때 B thread가 읽는 student에는 name만 유효하고, age와 number는 0인 상태로 'abnormal'이 발생합니다. 해결 방법 이러한 이유로 A thread의 instructions들이 모두 완료가 된 후 B thread로 스위칭한다는 것을 확립할 수 있다면 이 문제는 해결됩니다. 구현 방법 이러한 프로그램에서 mutual exclusion lock은 데이터 공유에 대한 무결성을 확립해줄 수 있는 개념입니다. \"mutual exclusion lock\"이라 불릴 수 있는 해당 객체는 어떤 순간에서든 하나의 thread에서만 해당 객체에 접근할 수 있습니다.아래는 FlywizOS에서 제공하는 mutual exclusion lock 기능입니다. Mutex 정의 static Mutex mutex1; Lock이 필요한 곳에 Mutex::Autolock class instance를 정의합니다. // This class utilizes the life cycle of local variables and the structure and destructor of C++ classes to automatically // implement locking and unlocking operations. Mutex::Autolock _l(mutex1); 아래 코드는 위의 A와 B thread 예제를 이용해 수정된 코드입니다. #include struct Student { char name[24]; int age; int number; }; struct Student student = {0}; //Define a mutex static Mutex mutext1; class AThread: public Thread { public: virtual bool threadLoop() { //Lock the statement of the function, and automatically unlock after the function ends Mutex::Autolock _lock(mutext1); snprintf(student.name, sizeof(student.name), \"David\"); student.age = 10; student.number = 20200101; return true; } }; class BThread: public Thread { public: virtual bool threadLoop() { //Lock the statement of the function, and automatically unlock after the function ends Mutex::Autolock _lock(mutext1); struct Student s = student; LOGD(\"nanme：%s\", s.name); LOGD(\"age：%d\", s.age); LOGD(\"student id number：%d\", s.number); return true; } }; static AThread athread; static BThread bthread; 코드에서 lock은 두 thread에서 student와 관련하여 동작합니다.A thread가 실행되었을 때, Mutex::Autolock _lock(mutext1); statement를 통해 mutex1의 mutex가 얻어집니다. 이후 A thread가 unlock되지 않고 B thread가 실행되면 B thread 역시 Mutex::Autolock _lock(mutext1); statement로 mutext1 의 mutex을 원하게 됩니다. 그러나 이 mutex는 이미 A thread에 의해 획득되었기에 B thread가 이를 획득하기 위해서는 A thread가 해당 mutex를 unlock하는 것을 기다릴 수 밖에 없고, mutex를 획득 한 후에야 정상적으로 다음 statement로 진행할 수 있습니다. 기본적인 프로젝트에도 이와 관련한 코드를 찾아볼 수 있습니다.(jni/uart/ProtocolParser.cpp) void registerProtocolDataUpdateListener(OnProtocolDataUpdateFun pListener) { Mutex::Autolock _l(sLock); LOGD(\"registerProtocolDataUpdateListener\\n\"); if (pListener != NULL) { sProtocolDataUpdateListenerList.push_back(pListener); } } Note : 이상의 예제로 mutex에 대한 개념을 충분히 이해하지 못했다면 인터넷을 통해 더 많은 정보를 얻을 수 있습니다.Note : FlywizOS의 시스템은 Linux를 기반으로 하고 있어 standard Linux의 mutex도 사용할 수 있습니다. powered by Gitbooklast modified: 2020-12-14 10:20:28 "},"screenshot.html":{"url":"screenshot.html","title":"스크린샷","keywords":"","body":"스크린샷 제품 개발 후 매뉴얼 작성시 실행중인 인터페이스의 스크린샷이 필요한 경우 아래 스크린샷 코드를 참고하십시오. 준비 screenshot.h 소스 파일을 다운로드하여 프로젝트jni 디렉토리에 저장합니다. 사용 필요한 헤더 파일#include \"screenshot.h\" 함수를 호출하여 스크린샷 찍기static bool onButtonClick_Button1(ZKButton *pButton) { //Capture the current screen, save it as a bmp picture, and save it to the TF card directory //Each time this function is called, the name of the saved picture is incremented //Example - screenshot01.bmp、screenshot02.bmp、screenshot03.bmp Screenshot::AutoSave(); return false; } 사진은 기본적으로 TF카드에 저장되므로 TF 카드를 장착하고 스크린샷을 찍으십시오. 다른 위치에 저장해야하는 경우 소스 코드를 직접 수정할 수 있습니다. powered by Gitbooklast modified: 2020-12-10 11:50:58 "},"data.html":{"url":"data.html","title":"데이타 저장소","keywords":"","body":"데이타 저장소 어떤 어플리케이션 시나리오에서는 특정 정보(계정 번호, 비밀번호, 설정 정보 등)를 영원히 저장할 필요가 있습니다. 이러한 데이타들의 특징은 데이타 양이 작지만 접근이 용이해야 합니다. 이 경우 데이타베이스를 이용할 필요 없이 FlywizOS에서는 간단하게 key-value 조합형식으로 데이터를 저장할 수 있는 기능을 제공합니다. 필요 헤더 파일 #include \"storage/StoragePreferences.h\" 관련 함수 // Storage function static bool putString(const std::string &key, const std::string &val); static bool putInt(const std::string &key, int val); static bool putBool(const std::string &key, bool val); static bool putFloat(const std::string &key, float val); // Delete the specified key static bool remove(const std::string &key); // Clear storage data static bool clear(); // Get function. The corresponding key value cannot be obtained, then the default value of defVal is returned static std::string getString(const std::string &key, const std::string &defVal); static int getInt(const std::string &key, int defVal); static bool getBool(const std::string &key, bool defVal); static float getFloat(const std::string &key, float defVal); [!Warning] 이 인터페이스는 플래시에 데이터를 파일 형태로 저장하므로 잦은 저장은 플래시 손상을 유발할 수 있으니 지양해야 합니다. 데이터 저장을 위한 파티션의 크기가 제한되어 있습니다. 모델에 따라 파티션의 크기는 다르지만, 512KB를 넘지 않게 유지하는 것을 권장합니다. 사용 예제 저장 //Save the string, use \"username\" as the alias, the value is the name string const char* name = \"zhang san\"; StoragePreferences::putString(\"username\", name); //Save the boolean variable, alias \"power\", the value is true StoragePreferences::putBool(\"power\", true); //Save a floating point number, aliased to \"temperature\", the value is 30.12 StoragePreferences::putFloat(\"temperature\", 30.12); //Save the integer, use \"age\" as the alias, the value is 20 StoragePreferences::putInt(\"age\", 20); 읽기 //Read the value of the \"username\" key, if there is no value, return an empty string std::string name = StoragePreferences::getString(\"username\", \"\"); //Log print the read string LOGD(\"username %s\\n\", username.c_str()); //Read the Boolean variable, if there is no value, then specify to return false bool power = StoragePreferences::getBool(\"power\", false); //Read floating-point number, if there is no value, specify to return 0 float temperature = StoragePreferences::getFloat(\"temperature\", 0); //Read floating-point number, if there is no value, specify to return 0 int age = StoragePreferences::getInt(\"age\", 18); 삭제 // Clear a value individually StoragePreferences::remove(\"username\"); StoragePreferences::remove(\"power\"); StoragePreferences::remove(\"temperature\"); StoragePreferences::remove(\"age\"); // Clear all values StoragePreferences::clear(); 수정만약 특정 값을 수정하고 싶다면, 같은 키를 이용해 새로운 값을 저장합니다. powered by Gitbooklast modified: 2020-12-09 11:09:06 "},"vireeprom.html":{"url":"vireeprom.html","title":"Emulated EEPROM","keywords":"","body":"EEPROM 기능 에뮬레이션 EEPROM (전원이 공급되는 동안 읽기-쓰기 가능한 메모리)은 사용자가 변경할 수 있는 메모리(ROM)로, 정상보다 높은 전압으로 삭제 및 재 프로그래밍 (다시 쓰기)을 할 수 있습니다. 에뮬레이션 원리 이 시스템은 자체 파일 시스템이 있는 Linux 기반으로 저장된 데이터를 NorFlash에 기록합니다 (삭제 횟수가 100,000 회 이상, Nandfalsh가 아닙니다. NandFlash는 불량 블록이 나타난 후 다양한 위험이 발생할 수 있습니다). /data 파티션은 사용자 데이터를 위해 FlywizOS 내부에 예약되어 있습니다. 마이크로 컨트롤러 작동에 익숙한 사용자의 편의를 위해 /data 파티션 아래에 파일을 생성하여 EEPROM 공간을 시뮬레이션합니다.(/data 파티션의 크기는 특정 시스템 버전에 따라 1M 또는 수백 KB 범위) 사용 시나리오 전원이 꺼진 상태에서 데이터를 유지하십시오. 구현 단계 먼저 프로젝트의 jni 디렉토리에 헤더 파일을 만듭니다.프로젝트에서 jni를 선택하고 마우스 오른쪽 버튼을 클릭 한 다음 팝업 컨텍스트 메뉴에서 New -> Header File 옵션을 선택한 다음 이름을 vireeprom.h로 지정하고 Finish를 클릭합니다. 방금 추가 한 헤더 파일에 다음 코드를 복사합니다. (헤더 파일 생성 시 일부 내용이 자동으로 추가 및 삭제 될 수 있습니다.) 이 코드는 EEPROM의 에뮬레이션 기능을 구현합니다. #ifndef JNI_VIREEPROM_H_ #define JNI_VIREEPROM_H_ #include #include #include /** * The storage size of the emulated EEPROM, in bytes, it is recommended not to be too large */ #define EEPROM_SIZE 1024 /** * Actually saved as a file /data/eeprom.eep */ #define EEPROM_FILE \"/data/eeprom.eep\" class VirEEPROM { public: VirEEPROM() { memset(buff_, 0, sizeof(buff_)); file_ = fopen(EEPROM_FILE, \"rb+\"); if (file_) { fread(buff_, 1, EEPROM_SIZE, file_); fseek(file_, 0, SEEK_END); int f_size = ftell(file_); //Adjust the file to a suitable size if (f_size != sizeof(buff_)) { ftruncate(fileno(file_), sizeof(buff_)); fseek(file_, 0, SEEK_SET); fwrite(buff_, 1, sizeof(buff_), file_); fflush(file_); sync(); } } else { file_ = fopen(EEPROM_FILE, \"wb+\"); //Adjust the file to a suitable size ftruncate(fileno(file_), sizeof(buff_)); } } virtual ~VirEEPROM() { if (file_) { fflush(file_); fclose(file_); sync(); } } /** * Return : less than 0 is failure, greater than 0 is the actual number of bytes written * Parameter: The data pointer that value needs to save, which can be a structure pointer, char*, int*..., size is the * size of the data to be saved * Examples of use: * const char buff[]=\"12345678\"; * VIREEPROM->WriteEEPROM(0,buff,sizeof(buff); */ int Write(int addr, const void* value, int size) { if (file_ == NULL) { return -1; } if ((addr >= EEPROM_SIZE) || ((addr + size) > EEPROM_SIZE)) { //Oversize return -2; } memcpy(buff_ + addr, value, size); if (0 != fseek(file_, addr, SEEK_SET)) { return -3; } int n = fwrite((char*)value, 1, size, file_); fflush(file_); sync(); return n; } /** * Return : less than 0 is a failure, greater than 0 is the number of bytes actually read * Parameter: the data pointer to be read by value, which can be a structure pointer, char*, int*..., size is the size of * the data to be read * Examples of use: * char buff[9]; * VIREEPROM->ReadEEPROM(0,buff,sizeof(buff); */ int Read(int addr,void* value,int size) { if (file_ == NULL) { return -1; } if ((addr >= EEPROM_SIZE) || ((addr + size) > EEPROM_SIZE)) { //Oversize return -2; } memcpy(value, buff_ + addr, size); return size; } /** * Return： * 0 Success * Less than 0 failed */ int Erase() { if (file_ == NULL) { return -1; } if (0 != fseek(file_, 0, SEEK_SET)) { return -2; } memset(buff_, 0, sizeof(buff_)); if (sizeof(buff_) != fwrite(buff_, 1, sizeof(buff_), file_)) { return -3; } fflush(file_); sync(); return 0; } static VirEEPROM* getInstance() { static VirEEPROM singleton; return &singleton; } private: unsigned char buff_[EEPROM_SIZE]; FILE* file_; }; #define VIREEPROM VirEEPROM::getInstance() #endif /* JNI_VIREEPROM_H_ */ 지금까지 준비 작업이 완료되었으므로 정상인지 테스트하기 위해 몇 가지 예제를 작성하겠습니다. mainLogic.cc 소스 파일을 열고 파일 맨 위에있는 \"vireeprom.h\" 헤더 파일을 인용하십시오. #include \"vireeprom.h\" Test code static void onUI_init(){ //The value array, starting from address 0, is written sequentially char value[4] = {1, 2, 3, 4}; VIREEPROM->Write(0, value, sizeof(value)); //Start reading from address 0, read 4 bytes in sequence, and save the read content in buf char buf[4] = {0}; VIREEPROM->Read(0, buf, sizeof(buf)); //Output log LOGD(\"Data read : %02x, %02x, %02x, %02x\", buf[0], buf[1], buf[2], buf[3]); //Clear all eeprom to 0 VIREEPROM->Erase(); } powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"brightness.html":{"url":"brightness.html","title":"화면 밝기 조정","keywords":"","body":"밝기 조절 필요한 헤더 파일#include \"utils/BrightnessHelper.h\" Dimming 스크린 밝기 조절 밝기의 범위는 0 ~ 100입니다. (Note : 0은 스크린이 꺼지는 것을 의미하지 않습니다) //Adjust the screen brightness to 80 BRIGHTNESSHELPER->setBrightness(80); 현재 밝기 값 가져오기BRIGHTNESSHELPER->getBrightness(); 스크린 온/오프 스크린 끄기 BRIGHTNESSHELPER->screenOff(); 스크린 켜기 BRIGHTNESSHELPER->screenOn(); 밝기 값 저장 시스템이 시작되면 스크린은 마지막으로 조정된 밝기 값을 기본으로 설정됩니다. 만약 밝기 값을 저장하고 싶지 않다면 프로젝트의 프로퍼티에서 이를 변경 할 수 있습니다. powered by Gitbooklast modified: 2020-12-09 09:42:33 "},"system_time.html":{"url":"system_time.html","title":"시스템 시간","keywords":"","body":"시스템 시간 필요한 헤더 파일 #include \"utils/TimeHelper.h\" tm 구조체의 각 변수에 대한 설명 struct tm { int tm_sec; /* second - the value range is [0,59] */ int tm_min; /* minute - the value range is [0,59] */ int tm_hour; /* hour - the value range is [0,23] */ int tm_mday; /* Day of the month - the value range is[1,31] */ int tm_mon; /* Month (starting from January, 0 means January) - the value range is[0,11] */ int tm_year; /* Year, the value starts from 1900 */ ... } 현재 날짜 및 시간 가져오기 struct tm *t = TimeHelper::getDateTime(); 시간 표시 예제 static void updateUI_time() { char timeStr[20]; static bool bflash = false; struct tm *t = TimeHelper::getDateTime(); sprintf(timeStr, \"%02d:%02d:%02d\", t->tm_hour,t->tm_min,t->tm_sec); mTextTimePtr->setText(timeStr); // Pay attention to modify the control name sprintf(timeStr, \"%d / %02d / %02d\", 1900 + t->tm_year, t->tm_mon + 1, t->tm_mday); mTextDatePtr->setText(timeStr); // Pay attention to modify the control name static const char *day[] = { \"Sun.\", \"Mon.\", \"Tue.\", \"Wed.\", \"Thu.\", \"Friu\", \"Sat.\" }; sprintf(timeStr, \"day of the week %s\", day[t->tm_wday]); mTextWeekPtr->setText(timeStr); // Pay attention to modify the control name } 시간 설정 예제 // Use tm structure to set time static void setSystemTime() { struct tm t; t.tm_year = 2017 - 1900; t.tm_mon = 9 - 1; t.tm_mday = 13; t.tm_hour = 16; t.tm_min = 0; t.tm_sec = 0; TimeHelper::setDateTime(&t); } // Or set the time with a string date str format: 2017-09-13 16:00:00 TimeHelper::setDateTime(\"2017-09-13 16:00:00\"); 더 자세한 내용은 Sample Code를 참고하십시오. powered by Gitbooklast modified: 2020-12-14 10:23:28 "},"machine_unique_id.html":{"url":"machine_unique_id.html","title":"기기 고유 ID","keywords":"","body":"Device unique ID code How to read Required header file#include \"security/SecurityManager.h\" Read device ID // Device id 8 bytes unsigned char devID[8]; // Return true on success, false on failure bool ret = SECURITYMANAGER->getDevID(devID); powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"tf.html":{"url":"tf.html","title":"TF card","keywords":"","body":"TF card TF카드를 삽입하면 시스템이 자동으로 /mnt/extsd디렉토리로 마운트합니다. 파일 경로 TF카드의 루트 디렉토리에 test.txt파일이 있는 경우 보드에서 이 파일의 절대 경로는 /mnt/extsd/test.txt입니다. TF카드 쓰기에서 주의 사항 TF카드에 파일을 쓰려면 다음 순서를 따르시기 바랍니다. 그렇지 않으면 제대로 쓰여지지 않는 상황이 발생할 수 있습니다. 카드 삽입->전원 켜기->파일 열기->파일 읽기 및 쓰기->fflush()->파일 닫기->sync()->카드 분리 즉, TF카드를 쓸 필요가 있는 경우 보드를 켜기 전에 TF 카드가 삽입되었는지 확인하십시오. 그리고 파일 쓴 후에는 동기화 문제에 주의하십시오. TF카드 장착 여부 확인 #include \"os/MountMonitor.h\" if (MOUNTMONITOR->isMount()) { //TF card has been mounted } else { //TF card is not mounted } [!Note] /mnt/extsd디렉토리는 TF카드 삽입 여부에 관계없이 항상 존재합니다. TF카드가 삽입되지 않은 경우 해당 디렉토리를 읽고 쓰면 내용이 메모리에 저장되지만 전원이 꺼진 후에는 사라집니다. powered by Gitbooklast modified: 2020-12-10 16:47:04 "},"mount.html":{"url":"mount.html","title":"카드 모니터링","keywords":"","body":"TF card plug-in monitor TF 카드 모니터링 함수를 등록하는 것으로 TF카드의 상태를 알 수 있습니다. 아래는 구현을 위해 가장 먼저 필요한 것입니다. #include \"os/MountMonitor.h\" class MyMountListener : public MountMonitor::IMountListener { public: virtual void notify(int what, int status, const char *msg) { switch (status) { case MountMonitor::E_MOUNT_STATUS_MOUNTED: // insert // msg is the mount path LOGD(\"mount path: %s\\n\", msg); mMountTextviewPtr->setText(\"TF inserted\"); break; case MountMonitor::E_MOUNT_STATUS_REMOVE: // remove // msg is the unmount path LOGD(\"remove path: %s\\n\", msg); mMountTextviewPtr->setText(\"TF removed\"); break; } } }; Listener 정의 : static MyMountListener sMyMountListener; 등록 : MOUNTMONITOR->addMountListener(&sMyMountListener); 등록 해제 : MOUNTMONITOR->removeMountListener(&sMyMountListener); 더 자세한 사항은 예제 코드의 MountDemo 프로젝트를 참고하십시오. powered by Gitbooklast modified: 2020-12-09 15:33:05 "},"gpio.html":{"url":"gpio.html","title":"GPIO","keywords":"","body":"GPIO operation [!Note] If you purchased SV50PB module or SV50PC module, you need to enable the GPIO function in Module Configuration before use , and then re-upgrade the system for normal use. More about the module Using Tutorial. Required header file #include \"utils/GpioHelper.h\" Operating function class GpioHelper { public: /** * Set the pin to input mode and return to the high and low state of the pin * @param pPin pin number * @return -1 fail * 1 high * 0 low */ static int input(const char *pPin); /** * Set the pin to output mode, and specify the output high or low level * @param pPin pin number * @param val 1 high * 0 low * @return -1 fail * 0 success */ static int output(const char *pPin, int val); }; Definition of the name of each platform operable pin Z11S platform At present, the platform only retains 3 groups of io ports for operation. // 3 groups of io port definition #define GPIO_PIN_B_02 \"B_02\" #define GPIO_PIN_B_03 \"B_03\" #define GPIO_PIN_E_20 \"E_20\" #include \"utils/GpioHelper.h\" // Read B02 io port status GpioHelper::input(GPIO_PIN_B_02); // B02 io port output high level GpioHelper::output(GPIO_PIN_B_02, 1); SV50PB module The following 12 groups of io ports can be operated : // SV50PB #define SV50PB_PIN7 \"PIN7\" #define SV50PB_PIN8 \"PIN8\" #define SV50PB_PIN9 \"PIN9\" #define SV50PB_PIN10 \"PIN10\" #define SV50PB_PIN11 \"PIN11\" #define SV50PB_PIN12 \"PIN12\" #define SV50PB_PIN13 \"PIN13\" #define SV50PB_PIN14 \"PIN14\" #define SV50PB_PIN23 \"PIN23\" #define SV50PB_PIN24 \"PIN24\" #define SV50PB_PIN26 \"PIN26\" #define SV50PB_PIN27 \"PIN27\" #include \"utils/GpioHelper.h\" // Read PIN7 io port status GpioHelper::input(SV50PB_PIN7); // PIN7 io port output high level GpioHelper::output(SV50PB_PIN7, 1); SV50PC module The following 25 groups of io ports can be operated : // SV50PC #define SV50PC_PIN2 \"PIN2\" #define SV50PC_PIN3 \"PIN3\" #define SV50PC_PIN4 \"PIN4\" #define SV50PC_PIN5 \"PIN5\" #define SV50PC_PIN6 \"PIN6\" #define SV50PC_PIN7 \"PIN7\" #define SV50PC_PIN8 \"PIN8\" #define SV50PC_PIN9 \"PIN9\" #define SV50PC_PIN10 \"PIN10\" #define SV50PC_PIN11 \"PIN11\" #define SV50PC_PIN13 \"PIN13\" #define SV50PC_PIN14 \"PIN14\" #define SV50PC_PIN15 \"PIN15\" #define SV50PC_PIN16 \"PIN16\" #define SV50PC_PIN17 \"PIN17\" #define SV50PC_PIN18 \"PIN18\" #define SV50PC_PIN22 \"PIN22\" #define SV50PC_PIN24 \"PIN24\" #define SV50PC_PIN25 \"PIN25\" #define SV50PC_PIN26 \"PIN26\" #define SV50PC_PIN27 \"PIN27\" #define SV50PC_PIN28 \"PIN28\" #define SV50PC_PIN29 \"PIN29\" #define SV50PC_PIN30 \"PIN30\" #define SV50PC_PIN31 \"PIN31\" #include \"utils/GpioHelper.h\" // Read PIN7 io port status GpioHelper::input(SV50PC_PIN7); // PIN7 io port output high level GpioHelper::output(SV50PC_PIN7, 1); 86 box The following 4 groups of io ports can be operated : // 86 Box #define Z6X86BOX_PIN7 \"PIN7\" // Corresponding to IO1 on the hardware #define Z6X86BOX_PIN8 \"PIN8\" // IO2 #define Z6X86BOX_PIN9 \"PIN9\" // IO3 #define Z6X86BOX_PIN10 \"PIN10\" // IO4 #include \"utils/GpioHelper.h\" // Read PIN7 io port status GpioHelper::input(Z6X86BOX_PIN7); // PIN7 io port output high level GpioHelper::output(Z6X86BOX_PIN7, 1); Sample The complete source code can be found in the GpioDemo project in Sample Code Package powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"spi.html":{"url":"spi.html","title":"SPI","keywords":"","body":"SPI操作 [!Note] 目前仅SV50PB模组支持该功能。 使用前，需要在模组配置中使能 SPI 功能，用生成的新系统包升级，才能正常使用。 更多有关模组的使用教程。 引入头文件 #include \"utils/SpiHelper.h\" 具体操作 // 所需头文件 #include \"utils/SpiHelper.h\" static void testSpi() { uint8_t tx[512], rx[512]; /** * 定义变量 * * 参数1： spi总线号 * 参数2： 模式，可选值： SPI_MODE_0、SPI_MODE_1、SPI_MODE_2、SPI_MODE_3 * 参数3： spi时钟频率，这里设置了50M * 参数4： 一个字有多少位，默认值： 8 * 参数5： 位顺序，true： 表示低位在前，false： 表示高位在前； 默认值： false，高位在前 */ SpiHelper spi(1, SPI_MODE_0, 50*1000*1000, 8, false); memset(tx, 0, 512); memset(rx, 0, 512); tx[0] = 0x4B; /** * 单工写 * * 参数1： 写数据地址 * 参数2： 数据长度 */ if (!spi.write(tx, 5)) { LOGD(\"spi tx error!\\n\"); } /** * 单工读 * * 参数1： 读数据地址 * 参数2： 数据长度 */ if (!spi.read(rx, 8)) { LOGD(\"spi rx error!\\n\"); } for (int i = 0; i 其他接口操作请参见头文件注释说明。 powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"i2c.html":{"url":"i2c.html","title":"I2C","keywords":"","body":"I2C [!Note] Currently only SV50P series modules support this function. Before use, you need to enable the TWI function in Module Configuration and upgrade with the generated new system package before it can be used normally. More about the module Using Tutorial. Required header file #include \"utils/I2CHelper.h\" Specific operation #include \"utils/I2CHelper.h\" #define CFG_L 0x47 #define CFG_H 0x80 #define VER_L 0x41 #define VER_H 0x81 static void testI2C() { uint8_t tx[512], rx[512]; memset(tx, 0, 512); memset(rx, 0, 512); /** * Define variables * * Parameter 1: i2c bus number * Parameter 2: Slave address, be sure to pay attention to the 7bit address * Parameter 3: Timeout time, unit: ms * Parameter 4: Number of retries */ I2CHelper i2c(0, 0x5e, 1000, 5); tx[0] = CFG_H; tx[1] = CFG_L; /** * Simple write * * Parameter 1: Write data address * Parameter 2: Data length */ if (!i2c.write(tx, 2)) { LOGD(\"i2c tx cfg error!\\n\"); } /** * Simple read * * Parameter 1: Read data address * Parameter 2: Data length */ if (!i2c.read(rx, 1)) { LOGD(\"i2c rx cfg error!\\n\"); } LOGD(\"i2c reg[0x%x%x]=%x\\n\", CFG_H, CFG_L, rx[0]); memset(rx, 0, 512); /** * Half-duplex transmission, that is, shared read and write, no stop signal in the middle * * Parameter 1: Write data address * Parameter 2: Write data length * Parameter 3: Read data address * Parameter 4: Read data length */ if (!i2c.transfer(tx, 2, rx, 1)) { LOGD(\"i2c i2c_transfer cfg error!\\n\"); } LOGD(\"i2c reg[0x%x%x]=%x\\n\", CFG_H, CFG_L, rx[0]); tx[0] = VER_H; tx[1] = VER_L; if (!i2c.write(tx, 2)) { LOGD(\"i2c tx ver error!\\n\"); } if (!i2c.read(rx, 1)) { LOGD(\"i2c rx ver error!\\n\"); } LOGD(\"i2c reg[0x%x%x]=%x\\n\", VER_H, VER_L, rx[0]); memset(rx, 0, 512); if (!i2c.transfer(tx, 2, rx, 1)) { LOGD(\"twi i2c_transfer ver error!\\n\"); } LOGD(\"i2c reg[0x%x%x]=%x\\n\", VER_H, VER_L, rx[0]); } For other interface operations, please refer to the header file notes. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"adc.html":{"url":"adc.html","title":"ADC","keywords":"","body":"ADC [!Note] 현재 SV50P series 모듈만 ADC를 지원합니다. 사용 전, 사용자는 Module Configuration에서 ADC기능을 활성화 하고, 이를 위해 시스템 패키지를 업데이트해야 합니다. 모듈에 대한 더 자세한 사항은 Using Tutorial을 참고하십시오 필요 헤더 파일 #include \"utils/AdcHelper.h\" 예제 #include \"utils/AdcHelper.h\" static void testAdc() { /** * Set the adc enable state * * @param true enable * false disable * The default is enable */ AdcHelper::setEnable(true); for (int i = 0; i powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"reboot.html":{"url":"reboot.html","title":"시스템 재 시작","keywords":"","body":"시스템 재부팅 다음 코드를 사용하여 시스템을 다시 시작할 수 있습니다. 필요한 헤더 파일 #include #include 코드 //Synchronize data and save cached data to prevent data loss sync(); reboot(RB_AUTOBOOT); powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"i18n.html":{"url":"i18n.html","title":"다중 언어","keywords":"","body":"다중 언어 FlywizOS는 다중 언어를 지원합니다. 사용법 먼저 new wizard를 통해 다중 언어를 위한 파일을 생성합니다. 파일 생성 후, 프로젝트 폴더에 i18n폴더가 생성되고 기본적인 tr파일들이 생성될 것입니다. 각 tr의 파일 이름은 해당하는 언어를 나타냅니다.(파일 이름은 임의로 바꾸지 않을 것을 권장합니다.) tr파일을 더블 클릭으로 오픈하면 xml포맷으로 된 컨텐츠를 볼 수 있습니다. 여기서 string tag의 name은 alias로 사용되고, 코드상에서 문자열을 대표합니다. Note : 동일한 tr파일에서 alias는 중복될 수 없습니다. Hello world! Hello, FlywizOS 만약 문자열에 줄바꿈을 원한다면 &#x000A;을 추가하십시오. 아래는 예제입니다. first line&#x000A;second line 위에서는 문자 \"hello, world!\"의 alias를 hello_world로 그리고 문자 \"hello, FlywizOS\"의 alias를 hello_flywizos로 정했습니다. 만약 더 많은 문자열과 alias를 추가하고자 한다면 예제의 string tag를 참고하십시오. 다중 언어를 위해 각 언어에 동일한 name tag를 추가합니다. 이러한 방법으로, 설정 언어를 바꿨을 때 시스템은 자동으로 해당 언어에 해당하는 동일 name tag의 문자로 교체됩니다. 언어 파일이 추가된 후 개발자는 UI파일과 코드에서 그것을 사용할 수 있습니다. UI파일을 열고, 컨트롤의 속성 중 Text에 @hello_world를 입력한 후 보드에 다운로드하여 실행하면, 해당 컨트롤에 Hello, world!가 표시되는 것을 확인할 수 있습니다.(@ 심볼은 @뒤의 텍스트가 언어 파일의 alias임을 나타냅니다) 또한 코드상에서도 동일하게 alias를 사용할 수 있습니다. setTextTr() 함수가 바로 그 방법입니다. 예 : /** * Triggered when the activity is constructed */ static void onUI_init() { // The parameter of setTextTr() is the name value in the language file. Note: The string passed in here does not need to be // preceded by the @ symbol mTextview1Ptr->setTextTr(\"hello_world\"); } 프로그램을 보드에 다운로드 후 실행하면 해당 컨트롤에 alias에 해당하는 문자가 표시되는 것을 확인할 수 있습니다. 또한 언어 파일의 alias를 이용하여 컨텐츠를 가져올 수 도 있습니다.예: #include \"manager/LanguageManager.h\" static bool onButtonClick_Button1(ZKButton *pButton) { //LOGD(\" ButtonClick Button1 !!!\\n\"); std::string hello = LANGUAGEMANAGER->getValue(\"hello\"); std::string world = LANGUAGEMANAGER->getValue(\"world\"); std::string ret = hello + \" \" + world; LOGD(\"ret: %s\\n\", ret.c_str()); return false; } 언어 변경 시스템의 기본 언어는 zh_CN(Simplified Chinese)입니다. 시스템에 내장된 언어 설정 액티비티를 통해 언어를 변경할 수 있습니다.아래 코드는 언어 설정 액티비티를 실행하는 예제입니다. EASYUICONTEXT->openActivity(\"LanguageSettingActivity\"); 또는 제공되는 API 함수를 통해서도 언어를 자유롭게 변경할 수 있습니다. EASYUICONTEXT->updateLocalesCode(\"zh_CN\"); //Set to Chinese EASYUICONTEXT->updateLocalesCode(\"en_US\"); //Set to English EASYUICONTEXT->updateLocalesCode(\"ko_KR\"); //Set to Korean 폰트 요구사항 다중 언어는 폰트의 지원이 필요합니다. 만약 해당 문자가 폰트에 없다면 비 정상적으로 표시될 것입니다. 그러므로 사용되는 폰트도 다중 언어를 포함하고 있어야 합니다. 시스템의 기본 폰트는 간체 중국어입니다. 다중 언어를 위해 커스텀 폰트를 추가하는 것을 권장합니다. Font cutting을 참고하십시오. 예제 전체 소스는 예제 코드의 TranslationDemo를 참고하십시오. powered by Gitbooklast modified: 2020-12-09 14:39:04 "},"adb_debug.html":{"url":"adb_debug.html","title":"ADB 디버그","keywords":"","body":"ADB 다운로드 및 디버깅 FlywizOS는 USB또는 WIFI를 통해 프로그램을 빠르게 다운로드 할 수 있으며, 구체적인 단계는 다음과 같습니다. 먼저, 컴퓨터와 보드를 연결하는데, 여기에는 두 가지 방법이 있습니다. [!Note] Note: 만약 WIFI가 내장된 보드를 구매하였다면, WIFI를 통해서만 연결이 가능합니다.(USB연결 불가) WIFI가 없는 버전을 구매하였다면, USB를 이용해 컴퓨터를 연결하면 아래와 같이 연결 상태를 확인 가능합니다. 컴퓨터와 보드를 USB케이블을 이용하여 연결 - USB 케이블을 사용하여 컴퓨터와 기기를 연결합니다. 컴퓨터가 기기를 Android 장치로 인식 할 수 있으면 연결이 정상입니다. 정상적으로 연결할 수없는 경우 컴퓨터에 드라이버 문제가 표시됩니다. 드라이버 다운로드 및 설치를 시도해보세요. WIFI를 통해 연결(이 방법은 보드가 WIFI를 지원해야 합니다.)먼저 보드의 WIFI 설정을 통해 보드를 컴퓨터와 같은 네트워크에 연결합니다. 네트워크 설정 후 보드의 IP주소를 확인하고 해당 IP주소를 FlywizOS IDE의 설정하면 IDE는 보드와의 연결을 시도하여 성공할 시 성공 확인 팝업이 표시됩니다. (만약 실패한다면 보드의 IP주소가 정확한지 확인하십시오.) WIFI 설정 액티비티 IDE의 IP주소 설정 다운로드 및 디버깅 위 과정을 완료되면 사용자는 프로그램 직접 보드에 다운로드 할 수 있습니다. 프로젝트 탐색기에서 다운로드 할 프로젝트의 이름을 선택 후 마우스 오른쪽 클릭을하여 팝업된 메뉴에서 Download and Debug를 찾아 클릭하면 자동으로 프로그램이 컴파일되고, 컴파일이 성공하면 보드에 프로그램이 다운로드됩니다. 이후 정상적으로 다운로드에 성공하면 보드에서 다운로드한 프로그램이 실행되는 것을 볼 수 있습니다. 유사하게, 프로젝트 선택 후 Ctrl + Alt + R키를 누름으로 다운로드가 가능합니다. 로그를 이용한 디버깅 주의사항 만약 컴퓨터에 다른 안드로이드 디바이스가 연결되어 있다면 해당 기기의 연결을 해제해야 합니다.다. 그렇지 않을 경우 다운로드 실패의 원인이 될 수 있습니다. Note: 이 방법으로 프로그램을 실행할 경우 프로그램은 보드에 저장되지 않기 때문에 전원을 해제할 경우 다음 전원 연결 시 기존 보드에 내장되어 있는 프로그램으로 실행됩니다. (만약 프로그램을 보드에 저장하고 싶다면 \"업데이트 이미지 만들기\" 참고하십시오) powered by Gitbooklast modified: 2020-12-14 10:25:23 "},"logcat.html":{"url":"logcat.html","title":"View log","keywords":"","body":"View log Log 추가 필요한 헤더 파일#include \"utils/Log.h\" FlywizOS는 LOGD또는 LOGE매크로를 통해 로그를 출력합니다. 사용 방법은 C언어의 printf와 같습니다.아래는 자동적으로 생성된 코드에 있는 예제입니다. static bool onButtonClick_Button1(ZKButton *pButton) { LOGD(\"onButtonClick_Button1\\n\"); return true; } 로그 확인 ADB를 연결 후, 툴을 통해 프로그램에 있는 로그를 확인할 수 있습니다. 방법은 아래와 같습니다. 메뉴에서 FlywizOS -> Show Log Perspective를 선택하면 IDE는 다른 화면으로 전환됩니다. 새로운 화면의 왼쪽 아래에서 LogCat을 선택합니다. 만약 정상이라면 오른쪽의 빨간 색 박스 영역에서 출력되는 로그를 확인할 수 있습니다. 만약 코딩 화면으로 다시 전환하고 싶다면 IDE의 우측 상단 코너의 FlywizOS 아이콘을 클릭하십시오. powered by Gitbooklast modified: 2020-12-09 15:17:33 "},"start_from_sdcard.html":{"url":"start_from_sdcard.html","title":"TF card에서 프로그램 시작","keywords":"","body":"TF 카드에서 프로그램 시작 ADB를 사용하여 프로그램을 다운로드 할 수 없는 경우 프로그램을 TF카드에 저장하고 TF카드에서 프로그램을 시작할 수도 있습니다. [!Note] Note : FAT32 형식의 TF카드만 지원합니다. 제작 과정 먼저 프로그램의 출력 디렉토리를 구성해야합니다. IDE에서 아래 버튼 찾습니다. 검은 색 드롭 다운 화살표를 클릭하고 팝업 메뉴에서 Path Setup을 선택합니다. 팝업 상자에서 TF카드의 드라이브를 선택하고 (TF 카드를 정상적으로 사용할 수 있는지 확인하십시오) 확인을 클릭하십시오. 위의 단계에서 출력 디렉토리를 구성했습니다. 이제 아래 그림의 버튼을 클릭하여 컴파일을 시작하면 컴파일된 결과를 설정한 드라이브로 패키징하여 저장합니다. 작업이 성공하면 EasyUI.cfg, ui, lib 및 font와 같은 디렉토리 및 파일이 구성된 드라이브에 생성됩니다. TF카드를 기기에 삽입 한 후 기기의 전원을 다시 켜십시오. 이 때 시스템이 TF카드의 파일을 감지하면 시스템의 프로그램 대신 카드에서 프로그램을 시작합니다. powered by Gitbooklast modified: 2020-12-10 15:36:15 "},"update_logo.html":{"url":"update_logo.html","title":"Boot LOGO 업그레이드","keywords":"","body":"부팅 로고 업그레이드 먼저 다음 조건을 충족하는 부팅 로고 이미지를 준비합니다. [!Note] 이미지 이름은 boot_logo.JPG로 고정됩니다. 파일 확장자는 jpg로 다른 확장자는 인식되지 않습니다. 이미지 크기는 128 KB를 초과 할 수 없습니다. 이미지 해상도는 화면 해상도와 정확히 같아야합니다. boot_logo.jpg를 TF 카드의 루트 디렉토리에 복사합니다. TF 카드를 보드에 삽입하면 자동으로 업그레이드 액티비티를 표시합니다. boot_logo를 선택하고 업그레이드를 클릭하십시오. 업그레이드가 완료되면 시스템이 종료되고 다시 시작됩니다. 이때 시스템이 다시 업그레이드 되지 않도록 방지하기 위해 바로 TF 카드를 꺼냅니다. 비고 : 전체가 검은색인 이미지로 업그레이드하여 부팅 로고를 제거할 수 있습니다. powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"make_image.html":{"url":"make_image.html","title":"Upgrade image 파일 만들기","keywords":"","body":"Upgrade image 파일 만들기 앞선 챕터에서 우리는 다운로드 및 디버그 메뉴를 통해 프로그램을 실행했습니다. 그러나 그것은 프로그램을 보드에 저장하는 것이 아니라서 보드의 전원을 해제했다 재 시작하면 다운로드 이전의 프로그램이 실행됩니다. 따라서 만약 보드에 프로그램을 저장하기 원한다면 먼저 프로그램을 업데이트 이미지 파일로 만들고 보드를 업데이트하십시오. 그러면 업데이트 후 재 시작 시 업데이트 된 프로그램이 실행됩니다. 사용법 먼저 업데이트 이미지 파일이 생성될 경로를 설정합니다. 툴바에서 아래 이미지를 찾습니다. 드랍 다운 화살표 버튼을 클릭 후 팝업 메뉴의 Path Setup을 선택합니다. 팝업 박스에서 업데이트 이미지 파일을 저장할 경로를 선택 후 OK를 클릭합니다. 위 과정에서 우리는 업데이트 이미지 파일의 생성 경로를 설정했습니다. 이제 아래 그림의 버튼을 누릅니다. 그러면 IDE는 컴파일을 수행하고, 해당 결과물을 패키지화하여 update.img파일을 설정된 경로에 생성합니다. update.img파일이 성공적으로 생성되면 TF카드(주의 : FAT32 형식의 TF 카드만 지원)의 root 디렉토리에 복사 후 보드에 삽입합니다. 그러면 시스템은 TF 카드의 파일을 감지하고 아래 그림처럼 업데이트 프로그램을 실행합니다. 그 후 체크박스를 터치해서 체크 한 후 업데이트 버튼을 누르면 업데이트가 시작됩니다. 업데이트가 완료된 후에는 바로 카드를 제거하여 다시 업데이트되는 것을 방지합니다. 보드의 터치가 손상되었거나 터치가 없는 보드의 경우 버튼을 클릭할 수 없어 업데이트가 불가능합니다. 이 이러한 경우에는 자동 업데이트를 참고하여 업데이트 하십시오. powered by Gitbooklast modified: 2020-12-09 15:32:18 "},"autoupgrade.html":{"url":"autoupgrade.html","title":"자동 TF card 업데이트","keywords":"","body":"자동 TF card 업데이트 보드의 화면 또는 터치에 문제가 있을 경우 TF카드에 아래 파일을 추가하면 시스템을 자동 업데이트 할 수 있습니다. zkautoupgrade (Note: 확장자는 없음) 이 방법을 사용하면, TF card를 삽입 후 특정 대기 시간(기본 2초) 후에 보드를 자동으로 업데이트 할 수 있습니다. 만약 업데이트 전 대기 시간을 조절하고 싶다면 zkautoupgrade파일에 원하는 시간(단위 : 초)을 추가합니다. 업데이트가 완료되면 TF card를 제거하여 자동으로 재 업데이트 되는 것을 방지합니다. powered by Gitbooklast modified: 2020-12-09 09:40:14 "},"sd_boot.html":{"url":"sd_boot.html","title":"플래쉬 카드 만들기","keywords":"","body":"업데이트 전용 카드 만들기 [!Warning] 참고 : 최대 16G까지의 TF카드를 지원합니다. 그 이상의 TF카드는 인식 할 수 없어 업그레이드가 불가능합니다. 최신 소프트웨어 업데이트 패키지는 QQ371608200에서 다운로드 하십시오. 다운로드 시 보드에 해당하는 소프트웨어 버전(보드의 후면 Tag를 확인)을 확인 하십시오. 만약 다른 버전이 사용되면 업그레이드 후 정상동작 하지 않을 수 있습니다! Computer Flash Tool를 다운로드 합니다. 컴퓨터에서 TF카드 드라이브를 선택하십시오. 업그레이드 이미지 파일을 선택하십시오. Burn 버튼을 클릭하십시오. 프로그래밍이 성공하면 TF 카드를 꺼내고 보드에 삽입 한 다음 전원을 켜서 업그레이드하십시오. TF카드 복구 컴퓨터에서 TF카드 드라이브를 선택하십시오. Recover 버튼을 클릭합니다. 포맷 후 카드는 정상적으로 사용 가능합니다. powered by Gitbooklast modified: 2020-12-10 12:17:58 "},"remote_update.html":{"url":"remote_update.html","title":"원격 업그레이드","keywords":"","body":"원격 업그레이드 현재 시스템에는 원격 업그레이드를 위한 액티비티가 없습니다.그러나 우리는 TF카드 감지 및 업그레이드 메커니즘을 이해하면 이를 응용하여 원격 업그레이드 구현을 위한 자체 코드를 추가 할 수 있습니다.이를 위해 먼저 TF 카드를 삽입하는 일반적인 업그레이드 프로세스를 소개합니다. TF 카드 감지 업그레이드 프로세스 시스템을 시작하거나 TF카드를 삽입 할 때 TF 카드가 정상적으로 장착되어있는 경우 시스템은 TF 카드의 루트 디렉토리에 update.img파일이 있는지 확인합니다.(TF카드의 루트 디렉토리는/mnt/extsd에 매핑됩니다) 이후 파일이 있는 경우 파일이 요구 사항을 충족하는지 추가로 확인하여 통과하면 업그레이드 액티비티가 나타나고 사용자가 업그레이드를 선택할 수 있습니다. 파일이 존재하지 않는 경우 프로세스가 종료되고 액티비티에는 어떤 행동도 일어나지 않습니다. 구현 단계 먼저 업그레이드 이미지 update.img를 다운로드해야 합니다. 정상적인 상황에서는 HTTP 프로토콜을 통해 파일을 다운로드하는 것이 가장 쉬운 방법이며 실제 상황에 따라 다른 프로토콜을 선택할 수도 있습니다.다운로드 후 이미지 파일을 TF 카드 디렉토리/mnt/extsd/에 저장합니다. [!Note] 보드에 TF카드가 삽입되어 있지 않은 경우에도 이 디렉토리는 메모리에 매핑되기 때문에 파일 저장이 가능합니다. 그러나 메모리 크기에 의해 제한되며 이미지 파일이 너무 크면 비정상 동작 또는 업그레이드 실패의 원인이 될 수 있습니다.TF카드를 삽입 한 경우 메모리 크기 문제를 무시할 수 있습니다. 업그레이드 모니터링 함수 호출먼저 UpgradeMonitor.h 소스 파일을 다운로드하여 프로젝트의jni/include/os디렉토리에 저장합니다. 그런 다음 아래 함수를 호출하여 업그레이드를 모니터링 하십시오. #include \"os/UpgradeMonitor.h\" //Actively detect whether there is a correct update.img file in the /mnt/extsd directory, //If yes, an upgrade prompt box will pop up //If not, nothing happens UpgradeMonitor::getInstance()->checkUpgradeFile(\"/mnt/extsd\"); 업그레이드 액티비티가 나타나면 사용자가 업그레이드 여부를 선택할 수 있습니다.지금까지 원격 업그레이드 기능이 완전히 구현되었습니다. 파일 다운로드 후 자동 업데이트 업그레이드 파일을 다운로드 한 후 강제로 업데이트하려면 자동 업데이트 문서를 참조하여 코드로 zkautoupgrade파일을 생성하기만 하면 됩니다. 반복적인 업그레이드 방지 위 단계에서 이미지 파일을 /mnt/extsd/디렉토리에 저장합니다. 성공적으로 업그레이드하면 보드가 자동으로 다시 시작됩니다. 이때 시스템은 정기적인 업그레이드 모니터링 프로세스를 수행하며 이미지 파일이 존재하기 때문에 업그레이드 액티비티가 다시 팝업되어 업그레이드가 반복됩니다. 해결책 이미지 파일을 다운로드 할 때 /mnt/extsd/가 아닌 다른 디렉토리에 저장하십시오. 예 :/mnt/extsd/temp/또한 모니터링 함수 호출 시 파라미터도 수정합니다. UpgradeMonitor::getInstance()->checkUpgradeFile(\"/mnt/extsd/temp\"); Sample Complete sample download샘플은 단순히 http클라이언트를 구현하여 파일을 다운로드합니다. 소스 코드의 http 부분을 참조하십시오. 파일 다운로드는 시간이 많이 걸리는 작업이므로 인터페이스의 즉각적인 응답에 영향을 주지 않도록 파일을 별도의 스레드에 배치하는 것이 좋습니다. 키 코드 class DownloadThread : public Thread { protected: virtual bool threadLoop(){ http::HttpClient http; mTextview1Ptr->setText(\"Download the upgrade file\"); //Create a save path for the upgrade file system(\"mkdir /mnt/extsd/temp\"); //Modify here to the real service IP string err = http.Download(\"192.168.1.1/update.img\", 80, \"/mnt/extsd/temp/update.img\"); mTextview1Ptr->setText(err); if (err.empty()) { UpgradeMonitor::getInstance()->checkUpgradeFile(\"/mnt/extsd/temp\"); } mButton1Ptr->setInvalid(false); return false; }; }; 서버 구현테스트의 편의를 위해 예제에는 실행파일 http.exe가 포함되어 있습니다. 업그레이드 이미지 파일 update.img와 http.exe를 같은 폴더에 넣은 다음 http.exe를 더블 클릭하여 실행합니다. 네트워크가 정상이면 웹 사이트 미러 파일를 통해 같은 디렉토리에 있는 파일을 다운로드 할 수 있습니다. 예 :http://192.168.1.1/update.img(IP 주소를 컴퓨터의 현재 IP로 수정하십시오.) 서버가 시작된 후 샘플 코드를 실행하여 원격 업그레이드를 테스트하십시오. powered by Gitbooklast modified: 2020-12-10 10:49:28 "},"demo_download.html":{"url":"demo_download.html","title":"샘플 코드","keywords":"","body":"샘플 코드 download [!Note] 먼저 원하는 해당하는 플랫폼과 LCD해상도에 맞는 샘플 코드를 다운로드 하십시오. 만약 해당 플랫폼에 사용중인 해상도에 맞는 샘플 코드가 없다면, 다른 플랫폼의 동일 해상도의 샘플코드를 다운로드 한 후 convert compile platform를 참조하여 직접 변환하세요. FW9306 또는 FW9306s 플랫폼 480x272 샘플 코드 기타 샘플 코드(Modbus、Sqlite、CURL HTTP、Mqtt) FW9311 플랫폼 800x480 샘플 코드 1024x600 샘플 코드 기타 샘플 코드(Modbus、Sqlite、CURL HTTP、Mqtt) powered by Gitbooklast modified: 2020-12-14 10:36:42 "},"file_read_write.html":{"url":"file_read_write.html","title":"파일 읽기/쓰기","keywords":"","body":"File read/write 만약 C언어의 File read/write에 친숙하다면, C언어의 스탠다드로 File read/write가 가능합니다.쉬운 File read/write를 위해 우리는 C언어로 제공되는 간단한 File read/write 패키지를 제공합니다. 만약 필요하다면 아래의 과정을 프로젝트에 추가하십시오. /** * Write a file. If the file exists, it will be overwritten. If the file does not exist, create a new file and write the content * Successfully returned true */ bool WriteFile(const char* filename, const void* data, int len); /** * Append content at the end of the file, if the file does not exist, create a new file first, and then write the content * Successfully returned true */ bool AppendFile(const char* filename, const void* data, int len); /** * Read file * Success - save the file in the data of string in binary form, read the binary content with string.data() * Failure - Return empty string */ string ReadFile(const char* filename); Porting steps 프로젝트의 jni폴더에 io 폴더 생성합니다. ioutil.h, ioutil.cpp를 다운로드하여 io 폴더에 저장합니다. 사용법 Include header file#include \"io/ioutil.h\" Write file //Write the string \"0123456789\" into the file 123.txt const char* filename = \"/mnt/extsd/123.txt\"; //Path to save the file const char* str = \"0123456789\"; ioutil::WriteFile(filename, str, strlen(str)); Append file //Append the content to the end of the file, if the specified file does not exist, create a new file. const char* append_str = \"abcdefgh\"; ioutil::AppendFile(filename, append_str, strlen(append_str)); Read file const char* filename = \"/mnt/extsd/123.txt\"; //Read all the contents of the file and save it in content string content = ioutil::ReadFile(filename); //Output each byte read to the log in hexadecimal for (size_t i = 0 ; i [!Warning] ioutil::ReadFile함수는 파일의 모든 내용을 메모리로 읽어들입니다. 만약 파일이 너무 크다면, 메모리 부족으로 예외가 발생합니다. Write file continuously, suitable for large file const char* filename = \"/mnt/extsd/123.txt\"; const char* append_str = \"abcdefgh\"; ioutil::Writer w; if (w.Open(filename, false)) { for (int i = 0; i Read file continuously, suitable for large file const char* filename = \"/mnt/extsd/123.txt\"; ioutil::Reader r; if (r.Open(filename)) { char buf[1024] = {0}; while (true) { int n = r.Read(buf, sizeof(buf)); if (n > 0) { //Have read content, output every byte for (int i = 0; i Test code /** * Triggered when the interface is constructed */ static void onUI_init() { //Write file const char* filename = \"/mnt/extsd/123.txt\"; const char* str = \"0123456789\"; ioutil::WriteFile(filename, str, strlen(str)); string content = ioutil::ReadFile(filename); LOGD(\"Number of bytes read %d, content:%s\", content.size(), content.c_str()); //Append file const char* append_str = \"abcdefgh\"; ioutil::AppendFile(filename, append_str, strlen(append_str)); content = ioutil::ReadFile(filename); LOGD(\"Number of bytes read %d, content:%s\", content.size(), content.c_str()); ioutil::Writer w; if (w.Open(filename, false)) { for (int i = 0; i 0) { //Have read content, output every byte for (int i = 0; i powered by Gitbooklast modified: 2020-12-09 11:47:14 "},"net.html":{"url":"net.html","title":"소켓 프로그래밍","keywords":"","body":"Socket programming 만약 Linux socket programming에 익숙한 개발자라면 standard Linux socket programming interface에 따라 네트워크 프로그래밍을 할 수 있습니다. 우리는 TCP 클라이언트를 구축하기 위해 일반적으로 사용되는 소켓 프로그래밍 구현 작업에 사용하기 편리한 Linux의 표준 인터페이스를 기반으로 간단한 패키지를 만들었습니다. 필요한 경우 아래 단계에 따라 소스 코드를 프로젝트에 통합 할 수 있습니다. Porting steps 프로젝트의 jni폴더 아래에 새로운폴더를 만들고 이름을 net으로 합니다. net.h, net.cpp 두 파일을 다운받아 net폴더에 저장합니다. 사용법 TCP Client 필요한 헤더 파일#include \"net/net.h\" 예제//Use TCP protocol to connect to port 80 of the domain name www.baidu.com, and change the domain name to IP. net::Conn* conn = net::Dial(\"tcp\", \"www.baidu.com:80\"); //net::Conn* conn = net::Dial(\"tcp\", \"14.215.177.38:80\"); if (conn) { byte buf[2048] = {0}; const char* req = \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"; //send conn->Write((byte*)req, strlen(req)); while (true) { //read，1000ms timeout int n = conn->Read(buf, sizeof(buf) - 1, 1000); if (n > 0) { buf[n] = 0; LOGD(\"read %d bytes： %s\", n, buf); } else if (n == 0) { LOGD(\"Normal disconnection\"); break; } else if (n == net::E_TIMEOUT) { LOGD(\"read timeout\"); } else { LOGD(\"error\"); break; } } //Close the connection conn->Close(); //Release memory delete conn; conn = NULL; UDP Client 필요한 헤더 파일#include \"net/net.h\" 예제//Use udp protocol to connect IP: 192.168.1.100 port 8080 net::Conn* conn = net::Dial(\"udp\", \"192.168.1.100:8080\"); if (conn) { byte buf[2048] = {0}; const char* req = \"hello\"; conn->Write((byte*)req, strlen(req)); while (true) { //read，1000ms timeout int n = conn->Read(buf, sizeof(buf) - 1, 1000); if (n > 0) { buf[n] = 0; LOGD(\"read %d bytes： %s\", n, buf); } else if (n == 0) { LOGD(\"Normal disconnection\"); break; } else if (n == net::E_TIMEOUT) { LOGD(\"read timeout\"); //Set timeout here to exit break; } else { LOGD(\"error\"); break; } } //Close the connection conn->Close(); //Release memory delete conn; conn = NULL; } powered by Gitbooklast modified: 2020-12-09 17:21:24 "},"http.html":{"url":"http.html","title":"HTTP","keywords":"","body":"HTTP 만약 HTTP Get, Post request의 구현이 필요하다면, C언어 오픈 소스 라이브러리인 libcurl은 매우 좋은 선택입니다.사용의 편이성을 위해서, FlywizOS는 컴파일된 라이브러리를 제공합니다.예제 코드에서 Third-party porting code의 CURLDemo프로젝트를 참고하십시오. [!Note] 플랫폼에 맞는 예제 코드를 다운로드하십시오. 그렇지 않을 시 정상적으로 동작하지 않습니다. powered by Gitbooklast modified: 2020-12-09 14:33:21 "},"transcoding.html":{"url":"transcoding.html","title":"트랜스코딩","keywords":"","body":"UTF-8 encoding 현재 시스템은 UTF-8 인코딩 만 지원합니다. 예를 들어 Text View 같은 컨트롤은 일반적으로 UTF-8로 인코딩 된 문자열 만 표시 할 수 있습니다. 따라서 다른 코드를 정상적으로 표시하려면 직접 트랜스 코딩해야합니다. sconv Sconv는 트랜스 코딩을 위한 오픈 소스 라이브러리로 utf-8과 gbk간의 변환에 사용됩니다. 준비 sconv 소스 파일 다운로드 후 프로젝트jni 폴더에 압축을 풉니 다. UTF-8 to GBK 필요한 헤더 파일 #include #include \"utf8cover/sconv.h\" 함수 추가 string utf8_to_gbk(const char* utf8_str) { int size = sconv_utf8_to_unicode(utf8_str, -1, NULL, 0); wchar *unicode = new wchar[size / 2 + 1]; size = sconv_utf8_to_unicode(utf8_str, -1, unicode, size); unicode[size / 2] = 0; size = sconv_unicode_to_gbk(unicode, -1, NULL, 0); char *ansi_str = new char[size + 1]; size = sconv_unicode_to_gbk(unicode, -1, ansi_str, size); ansi_str[size] = 0; string gbk(ansi_str, size); delete[] ansi_str; delete[] unicode; return gbk; } 함수를 사용하여 인코딩 변환을 수행합니다. 예는 다음과 같습니다. const char* utf8_str = \"This is utf8 encoding\"; string gbk = utf8_to_gbk(utf8_str); LOGD(\"After conversion, a total of %d bytes\", gbk.size()); for (size_t i = 0; i GBK to UTF-8 필요한 헤더 파일 #include #include \"utf8cover/sconv.h\" 함수 추가 string gbk_to_utf8(const char* gbk_str) { int size = sconv_gbk_to_unicode(gbk_str, -1, NULL, 0); wchar *unicode_str = new wchar[size / 2 + 1]; size = sconv_gbk_to_unicode(gbk_str, -1, unicode_str, size); unicode_str[size / 2] = 0; size = sconv_unicode_to_utf8(unicode_str, -1, NULL, 0); char *utf8_str = new char[size + 1]; size = sconv_unicode_to_utf8(unicode_str, -1, utf8_str, size); utf8_str[size] = 0; string utf8(utf8_str, size); delete[] unicode_str; delete[] utf8_str; return utf8; } 함수를 사용하여 인코딩 변환을 수행합니다. 예는 다음과 같습니다. //To testing, here is a gbk encoding array whose content is \"This is gbk encoding\" const char gbk_str[] = {0xd5, 0xe2, 0xca, 0xc7, 0x67, 0x62, 0x6b, 0xb1, 0xe0, 0xc2, 0xeb,0}; string utf8 = gbk_to_utf8(gbk_str); LOGD(\"After conversion, a total of %d bytes\", utf8.size()); LOGD(\"Content is：%s\", utf8.c_str()); powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"json.html":{"url":"json.html","title":"JSON","keywords":"","body":"JSON 구성과 해석 기본적으로 프로젝트에는 오픈 소스 cppjson library가 포함되어 있어 바로 사용이 가능합니다. 사용 방법 필요한 헤더 파일 #include \"json/json.h\" JSON string 구성 Json::Value root; //Add integer value root[\"int\"] = 1; //Add string root[\"str\"] = \"hello\"; //Due to the accuracy printing problem of floating-point numbers, it is not recommended to use, try to convert to integer root[\"float\"] = 3.14f; //add array Json::Value array; array.append(\"123\"); array.append(\"456\"); array.append(\"789\"); root[\"array\"] = array; //json nesting Json::Value sub; sub[\"int\"] = 1; sub[\"str\"] = \"sub str value\"; root[\"subJson\"] = sub; LOGD(\"The generated json string is : \"); LOGD(\"%s\", root.toStyledString().c_str()); ParsingJSON //Parsing json Json::Reader reader; Json::Value root2; //For convenience, Use the constructed json string as input for parsing json std::string test_json_string = root.toStyledString(); if (reader.parse(test_json_string, root2, false)) { LOGD(\"Parsed successfully\"); //When parsing json, you must check the legitimacy of the input more to avoid the program crash caused by illegal input. if (root2.isMember(\"int\")) { LOGD(\"int = %d\", root2[\"int\"].asInt()); } if (root2.isMember(\"str\")) { LOGD(\"str = %s\", root2[\"str\"].asString().c_str()); } if (root2.isMember(\"array\")) { Json::Value obj = root2[\"array\"]; if (obj.isArray()) { for (Json::ArrayIndex i = 0; i powered by Gitbooklast modified: 2020-12-09 14:46:25 "},"cpp_base.html":{"url":"cpp_base.html","title":"C++ basic ","keywords":"","body":"c++ 기본 지식 이 장에서는 C++에 대한 기본 지식이 없는 사람들에게 C++의 기본 문법과 클래스에 대해 설명합니다. Class C++의 경우 먼저 class를 언급해야합니다. 너무 복잡하다고 생각하지 말고 C 언어의 structure로 이해하도록 합니다.예를 들어 : 구조체 정의 // C struct Position { int left; int top; int width; int height; }; // c++ class Position { public: int left; int top; int width; int height; }; 변수 정의 : // C struct Position pos; // c++ Position pos; 변수 운영 : // C is the same as c++ pos.left = 0; class에는 C 언어의 구조보다 상속, 다형성, 오버로딩 및 액세스 권한에 대한 개념이 더 많습니다. C에 익숙한 사람들은 이것을 어떻게 사용해야 하는지 충분히 알기 위해서가 아니라면, 많은 노력을 기울일 필요가 없습니다.추가적으로 C언어에서는 함수 포인터만 정의하지만 C++의 class에서는 함수를 바로 구현 가능합니다. 이 부분이 C와는 다른 점으로, class에 정의된 함수는 일종의 변수처럼 사용됩니다. 아래는 자주 사용되는 예제입니다. // Set the text content, where mTextView1Ptr is a pointer variable of type ZKTextView mTextView1Ptr->setText(\"Hello\"); 기본 class string class string class는 실제 string과 이를 위해 제공되는 많은 함수들이 캡슐화 되어있습니다. 그러나 C에 익숙한 사용자는 c_str()함수만 알아도 충분히 활용 가능합니다. 이 함수는 string class에서 characters만 반환하는 함수로 아래와 같이 사용할 수 있습니다. // Input box callback function static void onEditTextChanged_Edittext1(const std::string &text) { // The return value type of c_str() function : const char * const char *pStr = text.c_str(); // Then you can operate like ordinary strings, such as getting the string length strlen(pStr), etc. } 아래는 텍스트 컨트롤에서 텍스트를 가져오는 예제입니다. // std is the namespace, std::string means to use the string class under std, don’t worry too much // When encountering the string class, we can refer to the following definition std::string text = mTextView1Ptr->getText(); // The subsequent operations are the same const char *pStr = text.c_str(); snprintf 함수 프로토타입 : int snprintf(char* dest_str,size_t size,const char* format,...); 기능 : 여러 파라미터를 정해진 포맷에 맞게 string화 하여 dest_str에 저장 (1) 만약 formatted string의 length가 size보다 작은 경우 string이 복사되고 string의 끝에 '\\0'이 추가됩니다. (2) 만약 formatted string의 length가 size보다 크거나 같은 경우 오직 size-1의 string만 카피되고 마지막에 '\\0'이 추가됩니다. 필요 헤더 파일 : #include 포맷 형식 Specifier%d Decimal signed integer%u Decimal unsigned integer%f Floating point%s String%c Character%p Pointer value%e Exponential floating point%x, %X Unsigned integer in hexadecimal%o Unsigned integer in octal%g Output the value according to the smaller output length in %e or %f type%p Output address%lu Output long integer %llu 64-bit unsigned integer Description (1) 최대 필드 너비를 나타 내기 위해 \"%\"와 문자 사이에 숫자를 삽입 할 수 있습니다. 예 : %3d는 3개의 정수 출력을 의미합니다. 3자리가 안된다면 오른쪽으로 정렬됩니다. %9.2f는 필드 너비가 9인 부동 소수점 숫자를 나타냅니다. 여기서 소수점 자리는 2이고 정수 자리는 6입니다. 소수점이 한 자리이며 9자리가 안된다면 오른쪽으로 정렬됩니다. %8s는 8자 문자열을 출력하는 것을 의미하며, 8자가 안된다면 오른쪽 정렬됩니다. 문자열의 길이나 정수의 개수가 지정된 필드 너비를 초과하면 실제 길이에 따라 출력됩니다. 그러나 부동 소수점 숫자의 경우 정수 개수가 지정된 정수 너비를 초과하면 실제 정수로 출력됩니다. 소수점 이하 자릿수가 지정된 소수점 이하 자릿수를 초과하면 지정된 너비에 따라 출력이 반올림됩니다. 또한 출력 값 앞에 0을 추가하려면 필드 너비 용어 앞에 0을 추가해야합니다. 예 : %04d는 4 자리 미만의 값을 출력 할 때 앞에 0이 추가되어 총 너비가 4 자리가됨을 의미합니다. 부동 소수점 숫자를 사용하여 문자 또는 정수의 출력 형식을 나타내는 경우 소수점 뒤의 숫자는 최대 너비를 나타내고 소수점 앞의 숫자는 최소 너비를 나타냅니다. 예 : %6.9s는 길이가 6 이상 9 이하인 문자열을 표시 함을 의미합니다. 9보다 크면 9 번째 문자 이후의 내용은 삭제됩니다. (2) \"%\"와 문자 사이에 소문자 l을 추가하여 출력이 긴 숫자임을 나타낼 수 있습니다. 예 : %ld는 long 출력을 의미합니다. %lf는 출력 double-float 숫자를 의미합니다. (3) 출력을 왼쪽 정렬 또는 오른쪽 정렬로 제어 할 수 있습니다. 즉, \"%\"와 문자 사이에 \"-\"기호를 추가하여 출력이 왼쪽 정렬됨을 나타내며 그렇지 않으면 오른쪽 정렬됩니다. 예 : %-7d는 출력 7개 정수가 왼쪽 정렬됨을 의미합니다. % -10s는 왼쪽 정렬 된 10 자 출력을 의미합니다. Special specifier\\n 줄 바꿈\\f 화면 지우기 및 페이지 변경\\r 캐리지 리턴\\t Tab 예제 정수 출력 char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%d\", 314); LOGD(\"%s\", buf);//Log output buf 출력된 log : 314 정수의 자릿수 지정 출력 char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%05d\", 314); //Format as 5 digits, less than 5 digits, add 0 in front LOGD(\"%s\", buf);//Log output buf string 출력된 log : 00314 부동 소수점 출력 char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%f\", 3.14); LOGD(\"%s\", buf);//Log output buf string 출력된 log : 3.140000 부동 소수점 자리수 지정 출력 char buf[64] = {0}; //Output decimals, a total of 6 characters wide (including the decimal point), 3 decimal places, two integer digits, and 0 if //the integer is less than two digits snprintf(buf, sizeof(buf), \"%06.3f\", 3.14); LOGD(\"%s\", buf);//Log output buf string 출력된 log : 03.140 powered by Gitbooklast modified: 2020-12-14 10:27:32 "},"touchcalibration.html":{"url":"touchcalibration.html","title":"터치 보정","keywords":"","body":"터치 보정 압력식 터치 스크린 보드는 처음 켜지면 터치 보정이 수행됩니다. 터치 보정 액티비티는 다음과 같습니다. 터치를 보정하려면 \"십자 아이콘\"을 클릭합니다. 추후 다시 보정하고 싶은 경우에는 다음의 세 가지 방법이 있습니다. IDE를 통해 프로젝트 속성을 열고 Touch calibration after booting 옵션을 체크하여 전원을 켤 때마다 터치 보정 액티비티가 실행되도록 합니다. TF 카드의 루트 디렉토리에 zktouchcalib 파일을 생성합니다 (참고 : 파일에는 확장자가 없음). 카드를 삽입하면 터치 보정 액티비티로 들어갑니다. 아래 코드로 터치 보정 액티비티를 시작합니다.EASYUICONTEXT->openActivity(\"TouchCalibrationActivity\"); powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"font_setting.html":{"url":"font_setting.html","title":"Font 설정","keywords":"","body":"Font setting FlywizOS IDE의 기본 폰트는 思源黑体字体库입니다. 폰트의 옵션이 Default로 설정되어 있으면, 컴파일 및 업데이트 파일 생성 시 내장된 기본 폰트인 fzcircle.ttf가 포함됩니다. 만약 다른 폰트를 사용하고 싶다면, Default 체크 옵션을 해제하고 새로운 폰트를 설정하십시오. (Note : ttf 포맷의 폰트만 지원 가능) : Z6S and later platforms Our system has built-in fzcircle.ttf font library directly, the purpose is to speed up the boot speed, if any fonts are missing, we need to customize an extended font library by ourselves, the same as 思源黑体字体, the name of the font library is also fzcircle.ttf, the import method is the same as above, so that when the system loads fonts, the built-in fonts in the system are loaded first, and the corresponding fonts in the extended font library are loaded if the loading fails; if you want to use other fonts Library, the name of the imported font library does not need to be called fzcircle.ttf, so the loaded fonts are all external fonts. Conclusion: Z11S platform: Because the platform system does not have a built-in font library, the system directly uses the font library packaged by the tool. There is no extension of the font library. Remember, the default package is the 思源黑体字体; Z6S and later platforms: The system has a built-in fzcircle.ttf font library, supports extended font library, the same as 思源黑体字体, the name of the font library must be fzcircle.ttf; When using other font libraries, the name of the imported font library cannot be fzcircle.ttf; powered by Gitbooklast modified: 2020-12-09 14:04:40 "},"font_cut_tool.html":{"url":"font_cut_tool.html","title":"Font 자르기","keywords":"","body":"Font cutting 대부분의 프로젝트에서는 커스텀 폰트를 사용할 것입니다. 그러나 어떤 폰트는 매우 큰 사이즈로 프로젝트에 적합하지 않을 수 있습니다. 또한 일반적으로 폰트의 특정 글자만을 사용하는 경우에는 필요한 폰트만을 잘라내어 사용하면 폰트가 차지하는 점유율을 줄여 전체적인 성능 향상에도 매우 도움을 줄 수 있습니다. Font cutting tool의 사용 상단 메뉴의 Toos에서 Font cutting tool을 찾을 수 있습니다. 먼저 \"Set the font cutting method\"를 설정합니다. 여기서는 어떤 글자들을 사용할지 결정합니다. Regular expression java정규 표현식을 지원합니다. 예 : \\d는 모든 숫자를 의미합니다. Specify textUTF-8으로 인코딩된 특정 txt파일 내의 컨텐츠만으로 폰트를 재 구성합니다.(권장하는 방법으로 간단하고 직관적입니다.) Set the font사용할 폰트를 설정합니다. Set the output path재 구성된 폰트가 저장될 경로를 설정합니다. 만약 기존에 만들었던 폰트 파일이 있다면, 새로운 파일로 교체됩니다. 모든 설정이 끝난 후 Cut를 클릭합니다. 만약 완료 메시지가 표시된다면 성공한 것이고, 새로운 폰트가 설정된 out path에 생성됩니다. 예제 새로운 txt파일을 만들어 오직 \"Hello\"라는 단어만 추가하고, UTF-8으로 저장하십시오. 그 후 Font cutting tool에 파라미터들을 설정하고, Cut버튼을 누르면 10KB이하의 ttf파일이 만들어지는 것을 확인할 수 있습니다. Online Font Editor 등으로 이 폰트는 오직 txt파일 안의 글자만을 포함하고 있는 것을 확인할 수 있습니다. powered by Gitbooklast modified: 2020-12-09 14:02:53 "},"hardware.html":{"url":"hardware.html","title":"하드웨어 사용 설명","keywords":"","body":"하드웨어 사용 설명 使用前注意事项 确定电源电压一定为4.5-5.5V。如果电源超过高于或者低于这个范围，机器无法工作正常，如果电源电压过高，会损坏模组屏。 确定好串口电平是RS232还得TTL还是RS485，根据要求结合第4点说明选择。 注意电源接口座的接口定义说明，不要接错。 模组功能接口示意图 z11s z6s 电源接口说明 PH2.0-8PIN座子接口定义 | 1PIN | 2PIN |3PIN | 4PIN | 5PIN | 6PIN | 7PIN | 8PIN | | --- | --- | --- | --- |--- | --- |--- | --- | | DC5V | RESET | CTS | TXOUT/B | RXIN/A | RTS | GND | GND | |直流电源输入4.5-5.5V |模组RESET,默认是NC |流控CTS |串口TX或者RS485-B。（接外部设备RX/RS485B） |串口RX或者RS485-A（接外部设备TX/RS485A）| 流控RTS| 电源地 |电源地 | 10PIN1.0FPC座子接口定义 | 1/2/3PIN | 4PIN | 5PIN | 6PIN | 7PIN | 8/9/10PIN | | --- | --- | --- | --- |--- | --- | | DC5V | RTS | RXIN/A | TXOUT/B | CTS | GND | |直流电源输入4.5-5.5V | 流控RTS | 串口RX或者RS485-A（接外部设备TX/RS485A）| 串口TX或者RS485-B。（接外部设备RX/RS485B） | 流控CTS | 电源地 | 串口输出方式选择 如图说明0R电阻是TTL，0R不要是RS232。 模组屏对应外部设备接口示意图 样品配送电源线说明 电源线为单端PH2.0-8PIN 10CM带扣的白蓝或者白红线。如图 powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"problems.html":{"url":"problems.html","title":"FAQ","keywords":"","body":"FAQ UI 메인 스레드에서 시간이 많이 걸리는 작업으로 인해 카드 업그레이드 액티비티가 표시되지 않음 액티비티의 갱신은 기본 UI 스레드에서 처리됩니다. 시간이 많이 걸리는 작업이나 기본 UI 스레드에 무한 루프가 있는 경우 UI 갱신에 영향을 미치고 카드 업그레이드 액티비티가 표시되지 않습니다. onUI_init,onUI_intent,onUI_show,onUI_hide,onUI_quit,onUI_Timer 및 컨트롤과 관련된 일부 콜백 함수, 이러한 함수는 모두 UI 메인 스레드에서 호출되므로 먼저 이러한 기능에 시간이 많이 걸리는 작업이 있는지 확인하십시오. 이 경우 카드를 삽입한 상태에서 보드를 다시 시작해야만 시스템이 가동되며 먼저 업그레이드가 필요한지 여부를 확인하여 업그레이드 인터페이스가 정상적으로 표시됩니다. 다운로드 및 디버그 불가능 / 다운로드 및 디버그 실패 먼저 컴퓨터와 보드가 올바르게 연결되어 있는지 확인하세요. WIFI가 있는 보드인 경우 WIFI 연결만 지원하고 USB 케이블 연결을 사용할 수 없습니다. 마찬가지로 WIFI가 없는 보드인 경우 USB 케이블로만 연결할 수 있습니다. 일반적으로 컴퓨터는 USB 장치로 인식합니다. 지원되는 연결 모드를 확인한 후 IDE의 메뉴 표시 줄로 이동하여 Debug Configuration -> ADB Configuration을 선택하고 저장합니다. 이후 다시 다운로드 해보십시오.ADB를 통한 다운로드 및 디버그 방법 프로그램이 갑자기 저절로 다시 시작되거나 중단됨 먼저 프로그램에서 예상치 못한 상황이 발생하면 로그 (로그 보는 방법)를 확인하고 문제를 반복적으로 재현하여 로그를 기반으로 문제의 코드를 확인해야합니다. 프로그램이 충돌하고 다시 시작되면 최초 부팅 시와 유사한 로그가 나타납니다. 이러한 로그는 프로그램이 시작되고 초기화 될 때 출력되므로 이를 사용하여 프로그램이 다시 시작되었는지 확인할 수 있습니다. 대부분의 프로그램 충돌 원인은 잘못된 포인터 사용 때문일 수 있습니다. 예 : Null pointer 범위를 벗어난 배열 포인터의 life cycle 신경 쓰지 않아 메모리가 해제 된 후에도 사용 등등. 프로젝트가 C와 C++프로그래밍을 사용하기 때문에 포인터 메모리 측면에서 원시 포인터를 처리하는 것이 불가피하므로 각별히 주의해야합니다. Divisor는 0이 될 수 없습니다라는 오류에 주의를 기울이지 않아 발생할 수 있는 또 다른 종류의 충돌이 있습니다. 프로그램이 멈춘 경우 로그에서 재시작 현상을 찾을 수 없습니다. 이 경우 스레드 데드락, 코드 무한 루프, 시간이 오래 걸리는 작업등을 분석하여 확인합니다. powered by Gitbooklast modified: 2020-12-10 09:43:36 "},"install_adb_driver.html":{"url":"install_adb_driver.html","title":"ADB driver 설치","keywords":"","body":"Windows XP/Vista/7/8/10를 위한 Android ADB driver 설치 먼저 ADB driver 설치 프로그램을 다운로드하여 압축을 해제 하십시오. USB를 이용하여 컴퓨터와 Android device를 연결하십시오. ADBDriverInstaller.exe를 실행 후 Install버튼을 클릭하십시오. Universal android usb드라이버가 자동으로 컴퓨터에 설치됩니다. 끝으로 설치가 완료되면 설치 성공 메시지가 표시됩니다. Windows XP 사용자는 드라이버 설치 후 컴퓨터를 재 시작하는 것을 권장합니다. powered by Gitbooklast modified: 2020-12-09 14:41:05 "},"convert_platform.html":{"url":"convert_platform.html","title":"플랫폼 전환","keywords":"","body":"플랫폼 전환 FlywizOS IDE는 동일한 프로젝트의 소스를 다른 하드웨어 플랫폼으로 전환하는 기능(Convert Compie Platform)을 제공합니다. 사용법 : 전환하려는 프로젝트를 선택 후 마우스 오른쪽으로 클릭한 후 팝업 메뉴의 Convert Compile Platform에서 전환하려는 플랫폼을 선택하여 클릭합니다. 플랫폼 전환 기능의 주의 사항 플랫폼 전환 기능은 툴 체인등과 같은 기본적인 컴파일 환경만 전환되고, 소스 코드등은 바뀌지 않습니다. 하드웨어 플랫폼 간의 기본적인 차이(ex: 시리얼 포트, GPIO등..)가 있어 이러한 부분은 사용자가 직접 수정해야 합니다. 툴 체인의 변경으로 플랫폼 전환 후 컴파일이 실패하는 경우가 발생할 수 있습니다. 이 경우 Makefile이나 소스코드를 직접 수정해서 해결해야 합니다. powered by Gitbooklast modified: 2020-12-09 10:22:11 "},"board_tag_explain.html":{"url":"board_tag_explain.html","title":"제품 사양 및 모델 설명","keywords":"","body":"Product specification and model description(产品规格型号说明) There is a model label on the back of the board, the model description is as follows(板子的背后贴有型号标签，型号说明如下) : For example, SW80480070A_CWM is a 7-inch 800x480 capacitive WIFI multimedia version(如 SW80480070A_CWM是7寸800*480的电容WIFI多媒体版本) powered by Gitbooklast modified: 2020-12-08 18:24:17 "},"core_module.html":{"url":"core_module.html","title":"핵심 모듈 사용법 튜토리얼","keywords":"","body":"核心模组 核心模组需要自行生成镜像，刷机，方可使用模组的多种功能。 使用教程 注册并登录网址 https://superv.flythings.cn 选择硬件版型 选择每个脚位功能 注意： 电容触摸PIN：CTPSCL、CTPSDA、CTPINT、CTPRST 电阻触摸PIN：RTPY2、RTPY1、RTPX2、RTPX1 选择屏幕分辨率; 如果有需要，可再次调整屏幕参数 选择触摸类型 注意： 触摸类型应该与PIN脚对应。 电容触摸PIN：CTPSCL、CTPSDA、CTPINT、CTPRST 电阻触摸PIN：RTPY2、RTPY1、RTPX2、RTPX1 以上都设置完毕后，点击提交， 将根据配置下载新的系统镜像。 新的镜像下载完毕后，再参照制作刷机卡教程，对设备进行刷机。 刷机成功后，可查看FlyThings开发文档进行应用开发。 powered by Gitbooklast modified: 2020-12-08 18:24:17 "}}